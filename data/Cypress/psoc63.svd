<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd"><addressUnitBits>0x8</addressUnitBits>
<cpu>
  <dcachePresent>
    <dcachePresen></dcachePresen>
  </dcachePresent>
  <deviceNumInterrupts>0x0</deviceNumInterrupts>
  <dtcmPresent>
    <dtcmPresen></dtcmPresen>
  </dtcmPresent>
  <endian>little</endian>
  <fpuPresent>0x1</fpuPresent>
  <icachePresent>
    <icachePresen></icachePresen>
  </icachePresent>
  <itcmPresent>
    <itcmPresen></itcmPresen>
  </itcmPresent>
  <mpuPresent>0x1</mpuPresent>
  <name>CM4</name>
  <nvicPrioBits>0x3</nvicPrioBits>
  <revision>r0p1</revision>
  <sauNumRegions>0x0</sauNumRegions>
  <vendorSystickConfig>0x0</vendorSystickConfig>
  <vtorPresent>0x1</vtorPresent>
</cpu>
<description>PSoC 63 (Connectivity Line): Dual-core Cortex-M4/M0+ MCU series with programmable digital and analog peripherals, advanced graphics, CapSense, crypto and secure boot security, with integrated high-speed wired and wireless connectivity.</description>
<name>psoc63</name>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010000</baseAddress>
    <description>Peripheral interconnect</description>
    <interrupts></interrupts>
    <name>PERI</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>Divider command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>(TYPE_SEL, DIV_SEL) specifies the divider on which the command (DISABLE/ENABLE) is performed.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies the divider type of the divider on which the command is performed:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>(PA_TYPE_SEL, PA_DIV_SEL) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
             
            If PA_DIV_SEL is '63' and PA_TYPE_SEL is '3', 'clk_peri' is used as reference.</description>
            <name>PA_DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>PA_TYPE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
             
            The DIV_SEL and TYPE_SEL fields specify which divider is to be disabled.
             
            The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
            <name>DISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
            0: Disable the divider using the DIV_CMD.DISABLE field.
            1: Configure the divider's DIV_XXX_CTL register.
            2: Enable the divider using the DIV_CMD_ENABLE field.
             
            The DIV_SEL and TYPE_SEL fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_peri' (typical usage) or to ANY enabled divider.
             
            The PA_DIV_SEL and PA_TYPE_SEL fields specify the reference divider.
             
            The HW sets the ENABLE field to '0' when the enabling is performed and the HW set the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_peri'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_peri' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>DIV_CMD</name>
        <resetMask>0xC000FFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1000</addressOffset>
        <description>Trigger command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the activated trigger when ACTIVATE is '1'. OUT_SEL specifies whether the activated trigger is an input trigger or output trigger to the trigger multiplexer. During activation (ACTIVATE is '1'), SW should not modify this register field. If the specified trigger is not present, the trigger activation has no effect.</description>
            <name>TR_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Specifies the trigger group.</description>
            <name>GROUP_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Amount of 'clk_peri' cycles a specific trigger is activated. During activation (ACTIVATE is '1'), HW decrements this field to '0' using a cycle counter. During activation, SW should not modify this register field. A value of 255 is a special case: HW does NOT decrement this field to '0' and trigger activation is under direct control of ACTIVATE when ACTIVATE is '1' the trigger is activated and when ACTIVATE is '0' the trigger is deactivated.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies whether trigger activation is for a specific input or ouput trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.TR_SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
            '0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
            '1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.</description>
            <name>OUT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW sets this field to '1' by to activate (set to '1') a trigger as identified by TR_SEL and OUT_SEL for COUNT cycles. HW sets this field to '0' when the cycle counter is decremented to '0'. Note: a COUNT value of 255 is a special case and trigger activation is under direct control of the ACTIVATE field (the counter is not decremented).</description>
            <name>ACTIVATE</name>
          </field>
        </fields>
        <name>TR_CMD</name>
        <resetMask>0xC0FF0FFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x800</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[0]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x804</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[1]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x808</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[2]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[3]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x810</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[4]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x814</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[5]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x818</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[6]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x81C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[7]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x820</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[8]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x824</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[9]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x828</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[10]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x82C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[11]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x830</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[12]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x834</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[13]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x838</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[14]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x83C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[15]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x840</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[16]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x844</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[17]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x848</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[18]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[19]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x850</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[20]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x854</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[21]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x858</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[22]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x85C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[23]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x860</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[24]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x864</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[25]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x868</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[26]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x86C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[27]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x870</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[28]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x874</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[29]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x878</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[30]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x87C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[31]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x880</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[32]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x884</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[33]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x888</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[34]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[35]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x890</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[36]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x894</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[37]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x898</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[38]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x89C</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[39]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8A0</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[40]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8A4</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[41]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8A8</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[42]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8AC</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[43]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8B0</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[44]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8B4</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[45]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8B8</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[46]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8BC</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[47]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C0</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[48]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C4</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[49]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C8</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[50]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8CC</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[51]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8D0</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[52]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8D4</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[53]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8D8</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[54]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8DC</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[55]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8E0</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[56]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8E4</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[57]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8E8</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[58]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8EC</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[59]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8F0</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[60]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8F4</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[61]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8F8</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[62]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8FC</addressOffset>
        <description>Divider control register (for 8.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 256].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is resticited to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT8_DIV</name>
          </field>
        </fields>
        <name>DIV_8_CTL[63]</name>
        <resetMask>0xFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x900</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[0]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x904</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[1]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x908</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[2]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[3]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x910</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[4]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x914</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[5]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x918</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[6]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x91C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[7]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x920</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[8]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x924</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[9]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x928</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[10]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x92C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[11]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x930</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[12]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x934</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[13]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x938</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[14]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x93C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[15]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x940</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[16]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x944</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[17]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x948</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[18]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[19]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x950</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[20]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x954</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[21]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x958</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[22]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x95C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[23]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x960</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[24]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x964</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[25]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x968</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[26]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x96C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[27]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x970</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[28]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x974</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[29]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x978</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[30]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x97C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[31]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x980</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[32]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x984</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[33]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x988</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[34]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[35]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x990</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[36]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x994</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[37]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x998</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[38]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x99C</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[39]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9A0</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[40]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9A4</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[41]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9A8</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[42]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9AC</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[43]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9B0</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[44]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9B4</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[45]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9B8</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[46]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9BC</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[47]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C0</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[48]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C4</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[49]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C8</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[50]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9CC</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[51]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9D0</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[52]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9D4</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[53]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9D8</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[54]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9DC</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[55]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9E0</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[56]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9E4</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[57]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9E8</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[58]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9EC</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[59]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9F0</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[60]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9F4</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[61]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9F8</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[62]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9FC</addressOffset>
        <description>Divider control register (for 16.0 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
             
            For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_CTL[63]</name>
        <resetMask>0xFFFF01</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA00</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[0]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA04</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[1]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA08</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[2]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[3]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA10</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[4]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA14</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[5]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA18</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[6]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA1C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[7]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA20</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[8]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA24</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[9]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA28</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[10]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA2C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[11]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA30</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[12]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA34</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[13]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA38</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[14]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA3C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[15]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA40</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[16]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA44</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[17]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA48</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[18]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[19]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA50</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[20]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA54</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[21]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA58</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[22]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA5C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[23]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA60</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[24]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA64</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[25]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA68</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[26]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA6C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[27]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA70</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[28]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA74</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[29]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA78</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[30]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA7C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[31]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA80</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[32]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA84</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[33]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA88</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[34]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA8C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[35]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA90</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[36]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA94</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[37]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA98</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[38]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA9C</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[39]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAA0</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[40]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAA4</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[41]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAA8</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[42]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAAC</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[43]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAB0</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[44]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAB4</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[45]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAB8</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[46]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xABC</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[47]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC0</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[48]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC4</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[49]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC8</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[50]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xACC</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[51]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAD0</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[52]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAD4</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[53]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAD8</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[54]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xADC</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[55]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAE0</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[56]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAE4</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[57]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAE8</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[58]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAEC</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[59]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAF0</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[60]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAF4</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[61]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAF8</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[62]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAFC</addressOffset>
        <description>Divider control register (for 16.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT16_DIV</name>
          </field>
        </fields>
        <name>DIV_16_5_CTL[63]</name>
        <resetMask>0xFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB00</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[0]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB04</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[1]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB08</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[2]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB0C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[3]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB10</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[4]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB14</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[5]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB18</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[6]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB1C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[7]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB20</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[8]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB24</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[9]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB28</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[10]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB2C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[11]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB30</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[12]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB34</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[13]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB38</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[14]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB3C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[15]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB40</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[16]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB44</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[17]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB48</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[18]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB4C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[19]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB50</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[20]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB54</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[21]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB58</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[22]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB5C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[23]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB60</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[24]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB64</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[25]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB68</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[26]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB6C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[27]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB70</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[28]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB74</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[29]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB78</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[30]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB7C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[31]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB80</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[32]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB84</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[33]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB88</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[34]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB8C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[35]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB90</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[36]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB94</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[37]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB98</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[38]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB9C</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[39]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBA0</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[40]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBA4</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[41]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBA8</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[42]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBAC</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[43]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBB0</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[44]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBB4</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[45]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBB8</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[46]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBBC</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[47]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC0</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[48]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC4</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[49]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC8</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[50]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBCC</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[51]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBD0</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[52]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBD4</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[53]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBD8</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[54]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBDC</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[55]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBE0</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[56]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBE4</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[57]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBE8</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[58]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBEC</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[59]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBF0</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[60]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBF4</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[61]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBF8</addressOffset>
        <description>Divider control register (for 24.5 divider)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
             
            Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_peri' cycle longer than other clock periods.
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FRAC5_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
             
            For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
             
            For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>INT24_DIV</name>
          </field>
        </fields>
        <name>DIV_24_5_CTL[62]</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC00</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[0]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC04</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[1]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC08</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[2]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[3]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC10</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[4]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC14</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[5]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC18</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[6]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC1C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[7]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC20</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[8]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC24</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[9]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC28</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[10]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC2C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[11]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC30</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[12]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC34</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[13]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC38</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[14]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC3C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[15]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC40</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[16]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC44</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[17]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC48</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[18]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC4C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[19]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC50</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[20]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC54</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[21]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC58</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[22]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC5C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[23]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC60</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[24]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC64</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[25]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC68</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[26]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC6C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[27]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC70</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[28]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC74</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[29]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC78</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[30]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC7C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[31]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC80</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[32]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC84</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[33]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC88</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[34]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC8C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[35]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC90</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[36]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC94</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[37]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC98</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[38]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC9C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[39]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCA0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[40]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCA4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[41]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCA8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[42]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCAC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[43]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCB0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[44]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCB4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[45]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCB8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[46]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCBC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[47]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCC0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[48]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCC4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[49]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCC8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[50]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCCC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[51]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCD0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[52]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCD4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[53]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCD8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[54]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCDC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[55]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCE0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[56]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCE4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[57]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCE8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[58]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCEC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[59]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCF0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[60]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCF4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[61]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCF8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[62]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xCFC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[63]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD00</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[64]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD04</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[65]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD08</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[66]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD0C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[67]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD10</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[68]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD14</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[69]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD18</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[70]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD1C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[71]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD20</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[72]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD24</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[73]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD28</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[74]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD2C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[75]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD30</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[76]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD34</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[77]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD38</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[78]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD3C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[79]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD40</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[80]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD44</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[81]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD48</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[82]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD4C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[83]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD50</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[84]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD54</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[85]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD58</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[86]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD5C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[87]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD60</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[88]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD64</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[89]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD68</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[90]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD6C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[91]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD70</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[92]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD74</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[93]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD78</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[94]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD7C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[95]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD80</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[96]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD84</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[97]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD88</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[98]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD8C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[99]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD90</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[100]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD94</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[101]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD98</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[102]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD9C</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[103]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDA0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[104]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDA4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[105]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDA8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[106]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDAC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[107]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDB0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[108]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDB4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[109]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDB8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[110]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDBC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[111]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDC0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[112]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDC4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[113]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDC8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[114]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDCC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[115]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDD0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[116]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDD4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[117]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDD8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[118]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDDC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[119]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDE0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[120]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDE4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[121]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDE8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[122]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDEC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[123]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDF0</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[124]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDF4</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[125]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDF8</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[126]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xDFC</addressOffset>
        <description>Clock control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Specifies one of the dividers of the divider type specified by TYPE_SEL.
             
            If DIV_SEL is '63' and TYPE_SEL is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
             
            When transitioning a clock between two out-of-phase dividers, spurious clock control signals may be generated for one 'clk_peri' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (DIV_SEL is '63' and TYPE_SEL is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
            <name>DIV_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies divider type:
            0: 8.0 (integer) clock dividers.
            1: 16.0 (integer) clock dividers.
            2: 16.5 (fractional) clock dividers.
            3: 24.5 (fractional) clock dividers.</description>
            <name>TYPE_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL[127]</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40210000</baseAddress>
    <description>CPU subsystem (CPUSS)</description>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <value>0x0</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <value>0x1</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <value>0x2</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_3</name>
        <value>0x3</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_4</name>
        <value>0x4</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_5</name>
        <value>0x5</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_6</name>
        <value>0x6</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_7</name>
        <value>0x7</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_8</name>
        <value>0x8</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_9</name>
        <value>0x9</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_10</name>
        <value>0xA</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_11</name>
        <value>0xB</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_12</name>
        <value>0xC</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_13</name>
        <value>0xD</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupts_gpio_14</name>
        <value>0xE</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <value>0xF</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>ioss_interrupt_vdd</name>
        <value>0x10</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <value>0x11</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_8_interrupt</name>
        <value>0x12</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>srss_interrupt_mcwdt_0</name>
        <value>0x13</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>srss_interrupt_mcwdt_1</name>
        <value>0x14</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>srss_interrupt_backup</name>
        <value>0x15</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>srss_interrupt</name>
        <value>0x16</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>pass_interrupt_ctbs</name>
        <value>0x17</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>bless_interrupt</name>
        <value>0x18</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_0</name>
        <value>0x19</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_1</name>
        <value>0x1A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_2</name>
        <value>0x1B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_3</name>
        <value>0x1C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_4</name>
        <value>0x1D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_5</name>
        <value>0x1E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_6</name>
        <value>0x1F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_7</name>
        <value>0x20</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_8</name>
        <value>0x21</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_9</name>
        <value>0x22</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_10</name>
        <value>0x23</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_11</name>
        <value>0x24</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_12</name>
        <value>0x25</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_13</name>
        <value>0x26</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_14</name>
        <value>0x27</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_ipc_15</name>
        <value>0x28</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_0_interrupt</name>
        <value>0x29</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_1_interrupt</name>
        <value>0x2A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_2_interrupt</name>
        <value>0x2B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_3_interrupt</name>
        <value>0x2C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_4_interrupt</name>
        <value>0x2D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_5_interrupt</name>
        <value>0x2E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_6_interrupt</name>
        <value>0x2F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>scb_7_interrupt</name>
        <value>0x30</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>csd_interrupt</name>
        <value>0x31</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_0</name>
        <value>0x32</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_1</name>
        <value>0x33</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_2</name>
        <value>0x34</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_3</name>
        <value>0x35</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_4</name>
        <value>0x36</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_5</name>
        <value>0x37</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_6</name>
        <value>0x38</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_7</name>
        <value>0x39</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_8</name>
        <value>0x3A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_9</name>
        <value>0x3B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_10</name>
        <value>0x3C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_11</name>
        <value>0x3D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_12</name>
        <value>0x3E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_13</name>
        <value>0x3F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_14</name>
        <value>0x40</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw0_15</name>
        <value>0x41</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_0</name>
        <value>0x42</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_1</name>
        <value>0x43</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_2</name>
        <value>0x44</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_3</name>
        <value>0x45</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_4</name>
        <value>0x46</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_5</name>
        <value>0x47</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_6</name>
        <value>0x48</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_7</name>
        <value>0x49</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_8</name>
        <value>0x4A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_9</name>
        <value>0x4B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_10</name>
        <value>0x4C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_11</name>
        <value>0x4D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_12</name>
        <value>0x4E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_13</name>
        <value>0x4F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_14</name>
        <value>0x50</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_dw1_15</name>
        <value>0x51</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_fault_0</name>
        <value>0x52</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_fault_1</name>
        <value>0x53</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupt_crypto</name>
        <value>0x54</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupt_fm</name>
        <value>0x55</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_0</name>
        <value>0x56</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_cm0_cti_1</name>
        <value>0x57</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_0</name>
        <value>0x58</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>cpuss_interrupts_cm4_cti_1</name>
        <value>0x59</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_0</name>
        <value>0x5A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_1</name>
        <value>0x5B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_2</name>
        <value>0x5C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_3</name>
        <value>0x5D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_4</name>
        <value>0x5E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_5</name>
        <value>0x5F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_6</name>
        <value>0x60</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_0_interrupts_7</name>
        <value>0x61</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_0</name>
        <value>0x62</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_1</name>
        <value>0x63</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_2</name>
        <value>0x64</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_3</name>
        <value>0x65</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_4</name>
        <value>0x66</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_5</name>
        <value>0x67</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_6</name>
        <value>0x68</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_7</name>
        <value>0x69</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_8</name>
        <value>0x6A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_9</name>
        <value>0x6B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_10</name>
        <value>0x6C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_11</name>
        <value>0x6D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_12</name>
        <value>0x6E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_13</name>
        <value>0x6F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_14</name>
        <value>0x70</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_15</name>
        <value>0x71</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_16</name>
        <value>0x72</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_17</name>
        <value>0x73</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_18</name>
        <value>0x74</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_19</name>
        <value>0x75</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_20</name>
        <value>0x76</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_21</name>
        <value>0x77</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_22</name>
        <value>0x78</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>tcpwm_1_interrupts_23</name>
        <value>0x79</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_0</name>
        <value>0x7A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_1</name>
        <value>0x7B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_2</name>
        <value>0x7C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_3</name>
        <value>0x7D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_4</name>
        <value>0x7E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_5</name>
        <value>0x7F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_6</name>
        <value>0x80</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_7</name>
        <value>0x81</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_8</name>
        <value>0x82</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_9</name>
        <value>0x83</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_10</name>
        <value>0x84</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_11</name>
        <value>0x85</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_12</name>
        <value>0x86</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_13</name>
        <value>0x87</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_14</name>
        <value>0x88</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>udb_interrupts_15</name>
        <value>0x89</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>pass_interrupt_sar</name>
        <value>0x8A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>audioss_interrupt_i2s</name>
        <value>0x8B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>audioss_interrupt_pdm</name>
        <value>0x8C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>profile_interrupt</name>
        <value>0x8D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>smif_interrupt</name>
        <value>0x8E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>usb_interrupt_hi</name>
        <value>0x8F</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>usb_interrupt_med</name>
        <value>0x90</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>usb_interrupt_lo</name>
        <value>0x91</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>pass_interrupt_dacs</name>
        <value>0x92</value>
      </interrupt>
    </interrupts>
    <name>CPUSS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>CM0+ control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Processor debug access control:
            '0': Access.
            '1': Stall access.
            
            This field is used to stall/delay debug accesses. This is useful to protect execution of code that needs to be protected from debug accesses.</description>
            <name>SLV_STALL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Processor enable:
            '0': Disabled. Processor clock is turned off and reset is activated. After SW clears this field to '0', HW automatically sets this field to '1'. This effectively results in a CM0+ reset, followed by a CM0+ warm boot.
            '1': Enabled.
            Note: The intent is that this bit is modified only through an external probe or by the CM4 while the CM0+ is in Sleep or DeepSleep power mode. If this field is cleared to '0' by the CM0+ itself, it should be done under controlled conditions (such that undesirable side effects can be prevented).
            
            Note: The CM0+ CPU has a AIRCR.SYSRESETREQ register field that allows the CM0+ to reset the complete device (ENABLED only disables/enables the CM0+), resulting in a warm boot. This CPU register field has similar 'built-in protection' as this CM0_CTL register to prevent accidental system writes (the upper 16-bits of the register need to be written with a 0x05fa key value; see CPU user manual for more details).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>CM0_CTL</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CM0+ status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
            - Active power mode: SLEEPING is '0'.
            - Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
            - DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
            <name>SLEEPING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
            <name>SLEEPDEEP</name>
          </field>
        </fields>
        <name>CM0_STATUS</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>CM0+ clock control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the slow clock divider (from the peripheral clock 'clk_peri' to the slow clock 'clk_slow'). Integer division by (1+SLOW_INT_DIV). Allows for integer divisions in the range [1, 256] (SLOW_INT_DIV is in the range [0, 255]).
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>SLOW_INT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the peripheral clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_peri'). Integer division by (1+PERI_INT_DIV). Allows for integer divisions in the range [1, 256] (PERI_INT_DIV is in the range [0, 255]).
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.
            
            Note that Fperi &lt;= Fperi_max. Fperi_max is likely to be smaller than Fhf_max. In other words, if Fhf = Fhf_max, PERI_INT_DIV should not be set to '0'.</description>
            <name>PERI_INT_DIV</name>
          </field>
        </fields>
        <name>CM0_CLOCK_CTL</name>
        <resetMask>0xFF00FF00</resetMask>
        <resetValue>0x1000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>CM0+ interrupt control 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 0. If the field value is 240, no system interrupt is connected and the CPU interrupt source is always '0'/de-activated.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 1.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 2.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 3.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>CM0+ interrupt control 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 4.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 5.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 6.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 7.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>CM0+ interrupt control 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 8.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 9.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 10.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 11.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>CM0+ interrupt control 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 12.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 13.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 14.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 15.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>CM0+ interrupt control 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 16.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 17.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 18.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 19.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>CM0+ interrupt control 5</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 20.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 21.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 22.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 23.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>CM0+ interrupt control 6</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 24.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 25.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 26.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 27.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>CM0+ interrupt control 7</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 28.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 29.</description>
            <name>MUX1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 30.</description>
            <name>MUX2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU interrupt source 31.</description>
            <name>MUX3_SEL</name>
          </field>
        </fields>
        <name>CM0_INT_CTL7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF0F0F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>CM4 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for CM4</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Switch CM4 off
                Power off, clock off, isolate, reset and no retain.</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset CM4
                Clock off, no isolated, no retain and reset.
                
                Note: The CM4 CPU has a AIRCR.SYSRESETREQ register field that allows the CM4 to reset the complete device (RESET only resets the CM4), resulting in a warm boot.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Put CM4 in Retained mode
                This can only become effective if CM4 is in SleepDeep mode. Check PWR_DONE flag to see if CM4 RETAINED state has been reached.
                Power off, clock off, isolate, no reset and retain.</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Switch CM4 on.
                Power on, clock on, no isolate, no reset and no retain.</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>CM4_PWR_CTL</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>CM4 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number clock cycles delay needed after power domain power up</description>
            <name>UP</name>
          </field>
        </fields>
        <name>CM4_PWR_DELAY_CTL</name>
        <resetMask>0x3FF</resetMask>
        <resetValue>0x12C</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x88</addressOffset>
        <description>CM4 status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if the CPU is in Active, Sleep or DeepSleep power mode:
            - Active power mode: SLEEPING is '0'.
            - Sleep power mode: SLEEPING is '1' and SLEEPDEEP is '0'.
            - DeepSleep power mode: SLEEPING is '1' and SLEEPDEEP is '1'.</description>
            <name>SLEEPING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if the CPU is in Sleep or DeepSleep power mode. See SLEEPING field.</description>
            <name>SLEEPDEEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>After a PWR_MODE change this flag indicates if the new power mode has taken effect or not. 
            Note: this flag can also change as a result of  a change in debug power up req</description>
            <name>PWR_DONE</name>
          </field>
        </fields>
        <name>CM4_STATUS</name>
        <resetMask>0x13</resetMask>
        <resetValue>0x13</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>CM4 clock control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the fast clock divider (from the high frequency clock 'clk_hf' to the peripheral clock 'clk_fast'). Integer division by (1+FAST_INT_DIV). Allows for integer divisions in the range [1, 256] (FAST_INT_DIV is in the range [0, 255]).
             
            Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
            <name>FAST_INT_DIV</name>
          </field>
        </fields>
        <name>CM4_CLOCK_CTL</name>
        <resetMask>0xFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>CM4 NMI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU NMI. The reset value ensure that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <name>CM4_NMI_CTL</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xF0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>RAM 0 control 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>SLOW_WS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>FAST_WS</name>
          </field>
        </fields>
        <name>RAM0_CTL0</name>
        <resetMask>0x303</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>RAM 1 control 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>SLOW_WS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>FAST_WS</name>
          </field>
        </fields>
        <name>RAM1_CTL0</name>
        <resetMask>0x303</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x190</addressOffset>
        <description>RAM1 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for SRAM1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM1_PWR_CTL</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1A0</addressOffset>
        <description>RAM 2 control 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>SLOW_WS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>FAST_WS</name>
          </field>
        </fields>
        <name>RAM2_CTL0</name>
        <resetMask>0x303</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1B0</addressOffset>
        <description>RAM2 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for SRAM2</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM2_PWR_CTL</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C0</addressOffset>
        <description>Power up delay used for all SRAM power domains</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number clock cycles delay needed after power domain power up</description>
            <name>UP</name>
          </field>
        </fields>
        <name>RAM_PWR_DELAY_CTL</name>
        <resetMask>0x3FF</resetMask>
        <resetValue>0x96</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1D0</addressOffset>
        <description>ROM control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the slow clock domain ('clk_slow'). The number of wait states is expressed in 'clk_hf' clock domain cycles.
            
            Timing paths to and from the memory have a (fixed) minimum duration  that always needs to be considered/met. The 'clk_hf' clock domain frequency determines this field's value such that the timing paths minimum duration is met. A table/formula will be provided for this field's values for different 'clk_hf' frequencies.</description>
            <name>SLOW_WS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Memory wait states for the fast clock domain ('clk_fast'). The number of wait states is expressed in 'clk_hf' clock domain cycles.</description>
            <name>FAST_WS</name>
          </field>
        </fields>
        <name>ROM_CTL</name>
        <resetMask>0x303</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1F0</addressOffset>
        <description>UDB power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for UDBs</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>UDB_PWR_CTL</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1F4</addressOffset>
        <description>UDB power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number clock cycles delay needed after power domain power up</description>
            <name>UP</name>
          </field>
        </fields>
        <name>UDB_PWR_DELAY_CTL</name>
        <resetMask>0x3FF</resetMask>
        <resetValue>0x12C</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Debug port status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if the SWJ debug port is connected; i.e. debug host interface is active:
            '0': Not connected/not active.
            '1': Connected/active.</description>
            <name>SWJ_CONNECTED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if SWJ debug is enabled, i.e. CDBGPWRUPACK is '1' and thus debug clocks are on:
            '0': Disabled.
            '1': Enabled.</description>
            <name>SWJ_DEBUG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if the JTAG or SWD interface is selected. This signal is valid when DP_CTL.PTM_SEL is '0' (SWJ mode selected) and SWJ_CONNECTED is '1' (SWJ is connected).
            '0': SWD selected.
            '1': JTAG selected.</description>
            <name>SWJ_JTAG_SEL</name>
          </field>
        </fields>
        <name>DP_STATUS</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x220</addressOffset>
        <description>Buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if write transfer can be buffered in the bus infrastructure bridges:
            '0': Write transfers are not buffered, independent of the transfer's bufferable attribute.
            '1': Write transfers can be buffered, if the transfer's bufferable attribute indicates that the transfer is a bufferable/posted write.</description>
            <name>WRITE_BUFF</name>
          </field>
        </fields>
        <name>BUFF_CTL</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x230</addressOffset>
        <description>DDFT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Select signal for CPUSS DDFT[0]
            0: clk_r of the Main flash (which is clk_hf for SONOS Flash)
            1: Flash data output bit '0' (r_q[0])
            2: Flash data output bit '32' (r_q[32])
            3: Flash data output bit '64' (r_q[64])
            4: Flash data output bit '127' (r_q[127])
            5: bist_fm_enabled
            6: bist_fail
            7: cm0_sleeping
            8: cm0_sleepdeep
            9: cm0_sleep_hold_ack_n
            10: cm4_sleeping
            11: cm4_sleepdeep
            12: cm4_sleep_hold_ack_n
            13: cm4_power
            14: cm4_act_retain_n
            15: cm4_act_isolate_n
            16: cm4_enabled
            17: cm4_reset_n
            18: cm4_pwr_done
            19: mmio_ram0_ctl1_power[0] (Power control for SRAM0 macro0)
            20: mmio_ram0_ctl1_retain_n[0] (Retention control for SRAM0 macro0)
            21: mmio_ram0_ctl1_isolate_n[0] (Isolation control for SRAM0 macro0)</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Select signal for CPUSS DDFT[0]
            0: clk_r of the Main flash (which is clk_hf for SONOS Flash)
            1: Flash data output bit '0' (r_q[0])
            2: Flash data output bit '32' (r_q[32])
            3: Flash data output bit '64' (r_q[64])
            4: Flash data output bit '127' (r_q[127])
            5: bist_fm_enabled
            6: bist_fail
            7: cm0_sleeping
            8: cm0_sleepdeep
            9: cm0_sleep_hold_ack_n
            10: cm4_sleeping
            11: cm4_sleepdeep
            12: cm4_sleep_hold_ack_n
            13: cm4_power
            14: cm4_act_retain_n
            15: cm4_act_isolate_n
            16: cm4_enabled
            17: cm4_reset_n
            18: cm4_pwr_done
            19: mmio_ram0_ctl1_power[0] (Power control for SRAM0 macro0)
            20: mmio_ram0_ctl1_retain_n[0] (Retention control for SRAM0 macro0)
            21: mmio_ram0_ctl1_isolate_n[0] (Isolation control for SRAM0 macro0)</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTL</name>
        <resetMask>0x1F1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x240</addressOffset>
        <description>SysTick timer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Specifies the number of clock source cycles (minus 1) that make up 10 ms. E.g., for a 32,768 Hz reference clock, TENMS is 328 - 1 = 327.</description>
            <name>TENMS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies an external clock source:
            '0': The low frequency clock 'clk_lf' is selected. The precision of this clock depends on whether the low frequency clock source is a SRSS internal RC oscillator (imprecise) or a device external crystal oscillator (precise).
            '1': The internal main oscillator (IMO) clock 'clk_imo' is selected. The MXS40 platform uses a fixed frequency IMO clock.
            o '2': The external crystal oscillator (ECO) clock 'clk_eco' is selected.
            '3': The SRSS 'clk_timer' is selected ('clk_timer' is a divided/gated version of 'clk_hf' or 'clk_imo').
            
            Note: If NOREF is '1', the CLOCK_SOURCE value is NOT used.
            Note: It is SW's responsibility to provide the correct NOREF, SKEW and TENMS field values for the selected clock source.</description>
            <name>CLOCK_SOURCE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies the precision of the clock source and if the TENMS field represents exactly 10 ms (clock source frequency is a multiple of 100 Hz). This affects the suitability of the SysTick timer as a SW real-time clock:
            '0': Precise.
            '1': Imprecise.</description>
            <name>SKEW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies if an external clock source is provided:
            '0': An external clock source is provided. 
            '1': An external clock source is NOT provided and only the CPU internal clock can be used as SysTick timer clock source.</description>
            <name>NOREF</name>
          </field>
        </fields>
        <name>SYSTICK_CTL</name>
        <resetMask>0xC3FFFFFF</resetMask>
        <resetValue>0x40000147</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2B0</addressOffset>
        <description>CM0+ vector table base</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Address of CM0+ vector table.
            
            Note: the CM0+ vector table is at an address that is a 256 B multiple.</description>
            <name>ADDR24</name>
          </field>
        </fields>
        <name>CM0_VECTOR_TABLE_BASE</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C0</addressOffset>
        <description>CM4 vector table base</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x16</bitWidth>
            <description>Address of CM4 vector table.
            
            Note: the CM4 vector table is at an address that is a 1024 B multiple.</description>
            <name>ADDR22</name>
          </field>
        </fields>
        <name>CM4_VECTOR_TABLE_BASE</name>
        <resetMask>0xFFFFFC00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>CM0+ protection context 0 handler</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Address of the protection context 0 handler. This field is used to detect entry to Cypress 'trusted' code through an exception/interrupt.</description>
            <name>ADDR</name>
          </field>
        </fields>
        <name>CM0_PC0_HANDLER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x400</addressOffset>
        <description>Identity</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the privileged setting ('0': user mode; '1': privileged mode) of the transfer that reads the register.</description>
            <name>P</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the security setting ('0': secure mode; '1': non-secure mode) of the transfer that reads the register.</description>
            <name>NS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field specifies the protection context of the transfer that reads the register.</description>
            <name>PC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This field specifies the bus master identifier of the transfer that reads the register.</description>
            <name>MS</name>
          </field>
        </fields>
        <name>IDENTITY</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>Protection status</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Protection state:
            '0': UNKNOWN.
            '1': VIRGIN.
            '2': NORMAL.
            '3': SECURE.
            '4': DEAD.
            
            The following state transistions are allowed (and enforced by HW):
            - UNKNOWN =&gt; VIRGIN/NORMAL/SECURE/DEAD
            - NORMAL =&gt; DEAD
            - SECURE =&gt; DEAD
            An attempt to make a NOT allowed state transition will NOT affect this register field.</description>
            <name>STATE</name>
          </field>
        </fields>
        <name>PROTECTION</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x520</addressOffset>
        <description>CM0+ NMI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System interrupt select for CPU NMI. The reset value ensures that the CPU NMI is NOT connected to any system interrupt after DeepSleep reset.</description>
            <name>MUX0_SEL</name>
          </field>
        </fields>
        <name>CM0_NMI_CTL</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0xF0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5A0</addressOffset>
        <description>Memory BIST status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flag indicating the BIST run is done. Note that after starting a BIST run this flag must be set before a new run can be started. For the first BIST run this will be 0.</description>
            <name>SFP_READY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Report status of the BIST run, only valid if SFP_READY=1</description>
            <name>SFP_FAIL</name>
          </field>
        </fields>
        <name>MBIST_STAT</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF000</addressOffset>
        <description>ROM trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>RM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read-Write margin enable control. This selects between the default Read-Write margin setting, and the external pin Read-Write margin settting.</description>
            <name>RME</name>
          </field>
        </fields>
        <name>TRIM_ROM_CTL</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF004</addressOffset>
        <description>RAM trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>RM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read-Write margin enable control. This selects between the default Read-Write margin setting, and the external RM[3:0] Read-Write margin settting.</description>
            <name>RME</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Write Assist Pulse to control pulse width of negative voltage on SRAM bitline.</description>
            <name>WPULSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Read Assist control for WL under-drive.</description>
            <name>RA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Write assist enable control (Active High).
            - WA[1:0] Write Assist pins to control negative voltage on SRAM bitline.</description>
            <name>WA</name>
          </field>
        </fields>
        <name>TRIM_RAM_CTL</name>
        <resetMask>0x73FF</resetMask>
        <resetValue>0x6002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x140</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[0]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x144</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[1]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x148</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[2]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14C</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[3]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x150</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[4]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x154</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[5]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x158</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[6]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x15C</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[7]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x160</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[8]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x164</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[9]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x168</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[10]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x16C</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[11]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x170</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[12]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x174</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[13]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x178</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[14]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x17C</addressOffset>
        <description>RAM 0 power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for 1 SRAM0 Macro</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>RAM0_PWR_MACRO_CTL[15]</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40220000</baseAddress>
    <description>Fault structures</description>
    <interrupts></interrupts>
    <name>FAULT</name>
    <registers></registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40230000</baseAddress>
    <description>IPC</description>
    <interrupts></interrupts>
    <name>IPC</name>
    <registers></registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40240000</baseAddress>
    <description>Protection</description>
    <interrupts></interrupts>
    <name>PROT</name>
    <registers></registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40250000</baseAddress>
    <description>Flash controller</description>
    <interrupts></interrupts>
    <name>FLASHC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>FLASH macro main interface wait states:
            '0': 0 wait states.
            ...
            '15': 15 wait states</description>
            <name>MAIN_WS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies remapping of FLASH macro main region.
            '0': No remapping.
            '1': Remapping. The highest address bit of the FLASH main region is inverted. This effectively remaps the location of FLASH main region physical sectors in the logical address space. In other words, the higher half physical sectors are swapped with the lower half physical sectors.
            
            Note: remapping only affects reading of the FLASH main region (over the R interface). It does NOT affect programming/erasing of the FLASH memory region (over the C interface).
            
            E.g., for a 512 KB / 4 Mb main region, the logical address space ranges from  [0x1000:0000, 0x1007:ffff] (the highest bit if the FLASH main region is bit 18). The memory has four physical sectors: sectors 0, 1, 2 and 3. If REMAP is '0', the physical regions logical addresses are as follows:
            - The physical region 0: [0x1000:0000, 0x1001:ffff].
            - The physical region 1: [0x1002:0000, 0x1003:ffff].
            - The physical region 2: [0x1004:0000, 0x1005:ffff].
            - The physical region 3: [0x1006:0000, 0x1007:ffff].
            If REMAP is '1', the physical regions logical addresses are as follows:
            - The physical region 0: [0x1004:0000, 0x1005:ffff].
            - The physical region 1: [0x1006:0000, 0x1007:ffff].
            - The physical region 2: [0x1000:0000, 0x1001:ffff].
            - The physical region 3: [0x1002:0000, 0x1003:ffff].
            
            Note: when the REMAP is changed, SW should invalidate the caches and buffers.</description>
            <name>REMAP</name>
          </field>
        </fields>
        <name>FLASH_CTL</name>
        <resetMask>0x10F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Flash power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls 'enable' pin of the Flash memory.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Controls 'enable_hv' pin of the Flash memory.</description>
            <name>ENABLE_HV</name>
          </field>
        </fields>
        <name>FLASH_PWR_CTL</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x3</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FLASH cache and buffer invalidation for ALL cache and buffers. SW writes a '1' to clear the cache and buffers. HW sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The caches' LRU structures are also reset to their default state.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>FLASH_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>BIST control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>This field specifies how the data check should be performed after reading the data from Flash memory.
            '0': Read the Flash and compare the output to BIST_DATA (R0).
            '1': Read the Flash and compare the output to the binary complement of BIST_DATA (R1).
            '2': Read the Flash and compare with BIST_DATA[] and compliment of BIST_DATA alternately (R01). The expected data of the first read is BIST_DATA, expected data of the second read is binary compliment of BIST_DATA, third read expected data is BIST_DATA, fourth read expected data is binary compliment of BIST_DATA and so on.</description>
            <name>OPCODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies direction in which Flash BIST steps through addresses:
            ''0': BIST steps through the Flash from the maximum row and column addresses (as specified by a design time configurtion parameter when ADDR_START_ENABLED is '0' and as specified by BIST_ADDR_START when ADDR_START_ENABLED is '1')  to the minimum row and column addresses. 
            '1': BIST steps through the Flash from the minimum row and column addresses ('0' when ADDR_START_ENABLED is '0' and as specified by BIST_ADDR_START when ADDR_START_ENABLED is '1') to the maximum row and column addresses.</description>
            <name>UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies how the Flash BIST addresses are generated:
            '0': Column address is incremented/decremented till it reaches its maximum/minimum value. Once it reach its maximum/minimum value, it is set to its mimimum/maximum value and only then is the row address incremented/decremented.
            '1': Row address is incremented/decremented till it reaches its maximum/minimum value. Once it reach its maximum/minimum value, it is set to its mimimum/maximum value and only then is the column address incremented/decremented.</description>
            <name>ROW_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies Flash BIST start addresses:
            '0': Row and column addresses start with their maximum/minimum values.
            '1': Row and column addresses start with their values as specified by BIST_ADDR_START.
            
            This feature is supported only for simple increment/decrement patterns. It is not supported with address compliment pattern (BIST_CTL.ADDR_COMPLIMENT_ENABLED) or address pattern which increments/decrements both row address and column address (BIST_CTL.INCR_DECR_BOTH) for every read.</description>
            <name>ADDR_START_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies to generate address compliment patterns.
            '0': Generate normal increment/decrement patterns.
            '1': Generate address patterns which interleaves compliment of previous address in between.
            Example: The following is an exaple pattern, With UP=1 and ROW_FIRST =0
            00_00
            11_11
            00_01
            11_10
            00_10
            11_01
            ...</description>
            <name>ADDR_COMPLIMENT_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies to generate patterns where both column address and row address are incremented/decremented simultaneously.
            '0': Generate normal increment/decrement patterns.
            '1': Generate address patterns with both row and column address changing.
            Example: With UP = 1 and ROW_FIRST = 0
            00_00
            01_01
            10_10
            11_11
            00_01
            01_10
            10_11
            11_00
            00_10
            ...</description>
            <name>INCR_DECR_BOTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies the BIST to continue indefinitely, regardless of occurrence of errors or not.
            '0': BIST controller doesn't stop on the data failures, it continues regardless of the errors.
            '1': BIST controller stops on when the first data failure is encounted.</description>
            <name>STOP_ON_ERROR</name>
          </field>
        </fields>
        <name>BIST_CTL</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>BIST command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1': Start FLASH BIST. Hardware set this field to '0' when BIST is completed.</description>
            <name>START</name>
          </field>
        </fields>
        <name>BIST_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>BIST address start register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Column start address. Useful to apply BIST to a part of an Flash. The value of this field should be in a legal range (a value outside of the legal range has an undefined result, and may lock up the BIST state machine). This legal range is dependent on the number of columns of the SRAM the BIST is applied to (as specified by BIST_CTL.SRAMS_ENABLED). E.g. for a Flash with n columns, the legal range is [0, n-1].</description>
            <name>COL_ADDR_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Row start address. Useful to apply BIST to a part of an Flash.  The value of this field should be in a legal range (a value outside of the legal range has an undefined result, and may lock up the BIST state machine). This legal range is dependent on the number of rows of the SRAM the BIST is applied to (as specified by BIST_CTL.SRAMS_ENABLED). E.g. for a Flash with m columns, the legal range is [0, m-1].</description>
            <name>ROW_ADDR_START</name>
          </field>
        </fields>
        <name>BIST_ADDR_START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x16C</addressOffset>
        <description>BIST address register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Current column address.</description>
            <name>COL_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Current row address.</description>
            <name>ROW_ADDR</name>
          </field>
        </fields>
        <name>BIST_ADDR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x170</addressOffset>
        <description>BIST status register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>0': BIST passed.
            '1': BIST failed.</description>
            <name>FAIL</name>
          </field>
        </fields>
        <name>BIST_STATUS</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>CM0+ cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies the cache way for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
            <name>WAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the cache set for which cache information is provided in CM0_CA_STATUS0/1/2.</description>
            <name>SET_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Prefetch enable:
            '0': Disabled.
            '1': Enabled.
            
            Prefetching requires the cache to be enabled; i.e. ENABLED is '1'.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cache enable:
            '0': Disabled. The cache tag valid bits are reset to '0's and the cache LRU information is set to '1's (making way 0 the LRU way and way 3 the MRU way).
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CM0_CA_CTL0</name>
        <resetMask>0xC7030000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x404</addressOffset>
        <description>CM0+ cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for CM0 cache</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>CM0_CA_CTL1</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x408</addressOffset>
        <description>CM0+ cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number clock cycles delay needed after power domain power up</description>
            <name>PWRUP_DELAY</name>
          </field>
        </fields>
        <name>CM0_CA_CTL2</name>
        <resetMask>0x3FF</resetMask>
        <resetValue>0x12C</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40C</addressOffset>
        <description>CM0+ cache command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FLASH cache invalidation. SW writes a '1' to clear the cache. W sets this field to '0' when the operation is completed. The operation takes a maximum of three clock cycles on the slowest of the clk_slow and clk_fast clocks. The cache's LRU structure is also reset to its default state.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>CM0_CA_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x440</addressOffset>
        <description>CM0+ cache status 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Sixteen valid bits of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
            <name>VALID16</name>
          </field>
        </fields>
        <name>CM0_CA_STATUS0</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x444</addressOffset>
        <description>CM0+ cache status 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Cache line address of the cache line specified by CM0_CA_CTL.WAY and CM0_CA_CTL.SET_ADDR.</description>
            <name>TAG</name>
          </field>
        </fields>
        <name>CM0_CA_STATUS1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x448</addressOffset>
        <description>CM0+ cache status 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Six bit LRU representation of the cache set specified by CM0_CA_CTL.SET_ADDR. The encoding of the field is as follows ('X_LRU_Y' indicates that way X is Less Recently Used than way Y):
            Bit 5: 0_LRU_1: way 0 less recently used than way 1.
            Bit 4: 0_LRU_2.
            Bit 3: 0_LRU_3.
            Bit 2: 1_LRU_2.
            Bit 1: 1_LRU_3.
            Bit 0: 2_LRU_3.</description>
            <name>LRU</name>
          </field>
        </fields>
        <name>CM0_CA_STATUS2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x480</addressOffset>
        <description>CM4 cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>See CM0_CA_CTL.</description>
            <name>WAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>See CM0_CA_CTL.</description>
            <name>SET_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CM0_CA_CTL.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CM0_CA_CTL.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CM4_CA_CTL0</name>
        <resetMask>0xC7030000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x484</addressOffset>
        <description>CM4 cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set Power mode for CM4 cache</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>undefined</description>
                <name>RSVD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>RETAINED</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>See CM4_PWR_CTL</description>
                <name>ENABLED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Register key (to prevent accidental writes).
            - Should be written with a 0x05fa key value for the write to take effect.
            - Always reads as 0xfa05.</description>
            <name>VECTKEYSTAT</name>
          </field>
        </fields>
        <name>CM4_CA_CTL1</name>
        <resetMask>0xFFFF0003</resetMask>
        <resetValue>0xFA050003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x488</addressOffset>
        <description>CM4 cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number clock cycles delay needed after power domain power up</description>
            <name>PWRUP_DELAY</name>
          </field>
        </fields>
        <name>CM4_CA_CTL2</name>
        <resetMask>0x3FF</resetMask>
        <resetValue>0x12C</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48C</addressOffset>
        <description>CM4 cache command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CM0_CA_CMD.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>CM4_CA_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C0</addressOffset>
        <description>CM4 cache status 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>See CM0_CA_STATUS0.</description>
            <name>VALID16</name>
          </field>
        </fields>
        <name>CM4_CA_STATUS0</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C4</addressOffset>
        <description>CM4 cache status 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>See CM0_CA_STATUS1.</description>
            <name>TAG</name>
          </field>
        </fields>
        <name>CM4_CA_STATUS1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C8</addressOffset>
        <description>CM4 cache status 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>See CM0_CA_STATUS2.</description>
            <name>LRU</name>
          </field>
        </fields>
        <name>CM4_CA_STATUS2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>Cryptography buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Prefetch enable:
            '0': Disabled.
            '1': Enabled.
            
            Prefetching requires the buffer to be enabled; i.e. ENABLED is '1'.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cache enable:
            '0': Disabled.
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CRYPTO_BUFF_CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>Cryptography buffer command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FLASH buffer invalidation. SW writes a '1' to clear the buffer. HW sets this field to '0' when the operation is completed.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>CRYPTO_BUFF_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x580</addressOffset>
        <description>Datawire 0 buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>DW0_BUFF_CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x588</addressOffset>
        <description>Datawire 0 buffer command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CMD.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>DW0_BUFF_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x600</addressOffset>
        <description>Datawire 1 buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>DW1_BUFF_CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x608</addressOffset>
        <description>Datawire 1 buffer command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CMD.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>DW1_BUFF_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x680</addressOffset>
        <description>Debug access port buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>DAP_BUFF_CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x688</addressOffset>
        <description>Debug access port buffer command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CMD.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>DAP_BUFF_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x700</addressOffset>
        <description>External master 0 buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>EXT_MS0_BUFF_CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x708</addressOffset>
        <description>External master 0 buffer command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CMD.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>EXT_MS0_BUFF_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x780</addressOffset>
        <description>External master 1 buffer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CTL.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>EXT_MS1_BUFF_CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x788</addressOffset>
        <description>External master 1 buffer command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See CRYPTO_BUFF_CMD.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>EXT_MS1_BUFF_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x118</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11C</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x120</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x124</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x128</addressOffset>
        <description>BIST data register(s)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>BIST data register to store the expected value for data comparison.
            For a 128-bit Flash memory, there will be 4 BIST_DATA registers to store 128-bit value.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x12C</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x130</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x134</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x138</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[3]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x13C</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[4]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x140</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[5]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x144</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[6]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x148</addressOffset>
        <description>BIST data actual register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the actual Flash data output that caused the BIST failure.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_ACT[7]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14C</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[0]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x150</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[1]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x154</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[2]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x158</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[3]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x15C</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[4]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x160</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[5]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x164</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[6]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x168</addressOffset>
        <description>BIST data expected register(s)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This field specified the expected Flash data output.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>BIST_DATA_EXP[7]</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40260000</baseAddress>
    <description>SRSS Core Registers</description>
    <interrupts></interrupts>
    <name>SRSS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Power Mode Control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Current power mode of the device.  LPACTIVE/LPSLEEP are implemented as firmware configuration of multiple registers and are reported here as ACTIVE/SLEEP, respectively.   Note that this field cannot be read in all power modes on actual silicon.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>System is resetting.</description>
                <name>RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>At least one CPU is running.</description>
                <name>ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>No CPUs are running.  Peripherals may be running.</description>
                <name>SLEEP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Main high-frequency clock is off; low speed clocks are available.  Communication interface clocks may be present.</description>
                <name>DEEPSLEEP</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POWER_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No debug session active</description>
                <name>NO_SESSION</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Debug session is active.  Power modes behave differently to keep the debug session active.</description>
                <name>SESSION_ACTIVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DEBUG_SESSION</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether certain low power functions are ready.  The low current circuits take longer to startup after POR/XRES/BOD/HIBERNATE wakeup than the normal mode circuits.  HIBERNATE mode may be entered regardless of this bit.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: If a low power circuit operation is requested, it will stay in its normal operating mode until it is ready.  If DEEPSLEEP is requested by all processors WFI/WFE, the device will instead enter SLEEP.  When low power circuits are ready, device will automatically enter the originally requested mode.
            1: Normal operation.  DEEPSLEEP and low power circuits operate as requested in other registers.</description>
            <name>LPM_READY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control the power mode of the reference current generator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: Current reference generator operates in normal mode.  It works for vddd ramp rates of 100mV/us or less.
            1: Current reference generator operates in low power mode.  Response time is reduced to save current, and it works for vddd ramp rates of 10mV/us or less.</description>
            <name>IREF_LPMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates that the voltage reference buffer is ready.  Due to synchronization delays, it may take two IMO clock cycles for hardware to clear this bit after asserting VREFBUF_DIS=1.</description>
            <name>VREFBUF_OK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable the DeepSleep regulator.  For ULP products, this is only legal when the ULP SISO-LC/SIMO-LC Buck supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: DeepSleep Regulator is on.
            1: DeepSleep Regulator is off.</description>
            <name>DPSLP_REG_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable the Retention regulator.  For ULP products, this is only legal when the ULP SISO-LC/SIMO-LC Buck supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: Retention Regulator is on.
            1: Retention Regulator is off.</description>
            <name>RET_REG_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable the Nwell regulator.  For ULP products, this is only legal when the ULP SISO-LC/SIMO-LC Buck supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: Nwell Regulator is on.
            1: Nwell Regulator is off.</description>
            <name>NWELL_REG_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable the linear Core Regulator.  For ULP products, this is only legal when the ULP SISO-LC/SIMO-LC Buck supplies vccd, but there is no hardware protection for this case.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: Linear regulator is on.
            1: Linear regulator is off.</description>
            <name>LINREG_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control the power mode of the ULP Linear Regulator.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: ULP Linear Regulator operates in normal mode.  Internal current consumption is 50uA and load current capability is 50mA to 300mA, depending on the number of regulator modules present in the product.
            1: ULP Linear Regulator operates in low power mode.  Internal current consumption is 5uA and load current capability is 25mA.  Firmware must ensure the current is kept within the limit.</description>
            <name>LINREG_LPMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control the power mode of the ULP POR/BOD circuits.  The value in this register is ignored and normal mode is used until LPM_READY==1.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: ULP POR/BOD circuits operate in normal mode.  They work for vddd ramp rates of 100mV/us or less.
            1: ULP POR/BOD circuits operate in low power mode.  Response time is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
            <name>PORBOD_LPMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control the power mode of the ULP Bandgap Voltage and Current References.  This applies to voltage and current generation and is different than the reference voltage buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.  When lower power mode is used, the Active Reference circuit can be disabled to reduce current.  Firmware is responsible to ensure ACT_REF_OK==1 before changing back to normal mode.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: ULP Active Bandgap Voltage and Current Reference operates in normal mode.  They work for vddd ramp rates of 100mV/us or less.
            1: ULP Active Bandgap Voltage and Current Reference operates in low power mode.  Power supply rejection is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.  The Active Reference may be disabled using ACT_REF_DIS=0.</description>
            <name>BGREF_LPMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bypass level shifter inside the PLL.  
            0: Do not bypass the level shifter.  This setting is ok for all operational modes and vccd target voltage.
            1: Bypass the level shifter.  This may reduce jitter on the PLL output clock, but can only be used when vccd is targeted to 1.1V nominal.  Otherwise, it can result in clock degradation and static current.</description>
            <name>PLL_LS_BYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control the power mode of the 800mV voltage reference buffer.  The value in this register is ignored and normal mode is used until LPM_READY==1.
            0: ULP Voltage Reference Buffer operates in normal mode.  They work for vddd ramp rates of 100mV/us or less.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            1: ULP Voltage Reference Buffer operates in low power mode.  Power supply rejection is reduced to save current, and they work for vddd ramp rates of 10mV/us or less.</description>
            <name>VREFBUF_LPMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable the 800mV voltage reference buffer.  Firmware should only disable the buffer when there is no connected circuit that is using it.  SRSS circuits that require it are the PLL and ECO.  A particular product may have circuits outside the SRSS that use the buffer.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>VREFBUF_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disables the Active Reference.  Firmware must ensure that LPM_READY==1 and BGREF_LPMODE==1 for at least 1us before disabling the Active Reference.  When enabling the Active Reference, use ACT_REF_OK indicator to know when it is ready.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: Active Reference is enabled
            1: Active Reference is disabled</description>
            <name>ACT_REF_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates that the normal mode of the Active Reference is ready.</description>
            <name>ACT_REF_OK</name>
          </field>
        </fields>
        <name>PWR_CTL</name>
        <resetMask>0xFFFC0033</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>HIBERNATE Mode Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Contains a 8-bit token that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware to differentiate WAKEUP from a general RESET event.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>TOKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This byte must be set to 0x3A for FREEZE or HIBERNATE fields to operate.  Any other value in this register will cause FREEZE/HIBERNATE to have no effect, except as noted in the FREEZE description.</description>
            <name>UNLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware sets this bit to freeze the configuration, mode and state of all GPIOs and SIOs in the system.  When entering HIBERNATE mode, the first write instructs DEEPSLEEP peripherals that they cannot ignore the upcoming freeze command.  This occurs even in the illegal condition where UNLOCK is not set.  If UNLOCK and HIBERNATE are properly set, the IOs actually freeze on the second write.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set, HIBERNATE will wakeup for a RTC interrupt</description>
            <name>MASK_HIBALARM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set, HIBERNATE will wakeup if WDT matches</description>
            <name>MASK_HIBWDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Each bit sets the active polarity of the corresponding wakeup pin.
            0: Pin input of 0 will wakeup the part from HIBERNATE
            1: Pin input of 1 will wakeup the part from HIBERNATE</description>
            <name>POLARITY_HIBPIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>When set, HIBERNATE will wakeup if the corresponding pin input matches the POLARITY_HIBPIN setting.  Each bit corresponds to one of the wakeup pins.</description>
            <name>MASK_HIBPIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hibernate disable bit.
            0: Normal operation, HIBERNATE works as described
            1: Further writes to this register are ignored
            Note: This bit is a write-once bit until the next reset.  Avoid changing any other bits in this register while disabling HIBERNATE mode.  Also, it is recommended to clear the UNLOCK code, if it was previously written..</description>
            <name>HIBERNATE_DISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware sets this bit to enter HIBERNATE mode.  The system will enter HIBERNATE mode immediately after writing to this bit and will wakeup only in response to XRES or WAKEUP event.  Both UNLOCK and FREEZE must have been set correctly in a previous write operations.  Otherwise, it will not enter HIBERNATE.  External supplies must have been stable for 250us before entering HIBERNATE mode.</description>
            <name>HIBERNATE</name>
          </field>
        </fields>
        <name>PWR_HIBERNATE</name>
        <resetMask>0xCFFEFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Low Voltage Detector (LVD) Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Threshold selection for HVLVD1.  Disable the LVD (HVLVD1_EN=0) before changing the threshold.
            0: rise=1.225V (nom), fall=1.2V (nom)
            1: rise=1.425V (nom), fall=1.4V (nom)
            2: rise=1.625V (nom), fall=1.6V (nom)
            3: rise=1.825V (nom), fall=1.8V (nom)
            4: rise=2.025V (nom), fall=2V (nom)
            5: rise=2.125V (nom), fall=2.1V (nom)
            6: rise=2.225V (nom), fall=2.2V (nom)
            7: rise=2.325V (nom), fall=2.3V (nom)
            8: rise=2.425V (nom), fall=2.4V (nom)
            9: rise=2.525V (nom), fall=2.5V (nom)
            10: rise=2.625V (nom), fall=2.6V (nom)
            11: rise=2.725V (nom), fall=2.7V (nom)
            12: rise=2.825V (nom), fall=2.8V (nom)
            13: rise=2.925V (nom), fall=2.9V (nom)
            14: rise=3.025V (nom), fall=3.0V (nom)
            15: rise=3.125V (nom), fall=3.1V (nom)</description>
            <name>HVLVD1_TRIPSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Source selection for HVLVD1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select VDDD</description>
                <name>VDDD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select AMUXBUSA (VDDD branch)</description>
                <name>AMUXBUSA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>RSVD</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>VDDIO</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select AMUXBUSB (VDDD branch)</description>
                <name>AMUXBUSB</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HVLVD1_SRCSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable HVLVD1 voltage monitor.  When the LVD is enabled, it takes 20us for it to settle.  There is no hardware stabilization counter, and it may falsely trigger during settling.  It is recommended that firmware keep the interrupt masked for at least 8us, write a 1'b1 to the corresponding SRSS_INTR field to any falsely pended interrupt, and then optionally unmask the interrupt.  After enabling, it further recommended to read the realted PWR_LVD_STATUS field, since the interrupt only triggers on edges.  This bit is cleared (LVD is disabled) when entering DEEPSLEEP to prevent false interrupts during wakeup.</description>
            <name>HVLVD1_EN</name>
          </field>
        </fields>
        <name>PWR_LVD_CTL</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Buck Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Voltage output selection for vccbuck1 output.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
            0: 0.85V
            1: 0.875V
            2: 0.90V
            3: 0.95V
            4: 1.05V
            5: 1.10V
            6: 1.15V
            7: 1.20V</description>
            <name>BUCK_OUT1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for buck converter.    This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>BUCK_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for vccbuck1 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.    This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.  The SAS specifies the required sequence when transitioning vccd from the LDO to SIMO Buck output #1.</description>
            <name>BUCK_OUT1_EN</name>
          </field>
        </fields>
        <name>PWR_BUCK_CTL</name>
        <resetMask>0xC0000007</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Buck Control Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Voltage output selection for vccbuck2 output.  When increasing the voltage, it can take up to 200us for the output voltage to settle.  When decreasing the voltage, the settling time depends on the load current.
            0: 1.15V
            1: 1.20V
            2: 1.25V
            3: 1.30V
            4: 1.35V
            5: 1.40V
            6: 1.45V
            7: 1.50V</description>
            <name>BUCK_OUT2_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware control for vccbuck2 output.  When this bit is set, the value in BUCK_OUT2_EN is ignored and a hardware signal is used instead.  If the product has supporting hardware, it can directly control the enable signal for vccbuck2.  The same charging time in BUCK_OUT2_EN applies.</description>
            <name>BUCK_OUT2_HW_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for vccbuck2 output.  The value in this register is ignored unless PWR_BUCK_CTL.BUCK_EN==1.  The regulator takes up to 600us to charge the external capacitor.  If there is additional load current while charging, this will increase the startup time.</description>
            <name>BUCK_OUT2_EN</name>
          </field>
        </fields>
        <name>PWR_BUCK_CTL2</name>
        <resetMask>0xC0000007</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>Low Voltage Detector (LVD) Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>HVLVD1 output.
            0: below voltage threshold
            1: above voltage threshold</description>
            <name>HVLVD1_OK</name>
          </field>
        </fields>
        <name>PWR_LVD_STATUS</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>Watchdog Counter Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable this watchdog timer.  This field is retained during DEEPSLEEP and HIBERNATE modes.</description>
            <name>WDT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Prohibits writing to WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers when not equal 0.  Requires at least two different writes to unlock.  A change in WDT_LOCK takes effect beginning with the next write cycle.
            Note that this field is 2 bits to force multiple writes only.  It represents only a single write protect signal protecting all those registers at the same time.  WDT will lock on any reset.  This field is not retained during DEEPSLEEP or HIBERNATE mode, so the WDT will be locked after wakeup from these modes.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect</description>
                <name>NO_CHG</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clears bit 0</description>
                <name>CLR0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clears bit 1</description>
                <name>CLR1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sets both bits 0 and 1</description>
                <name>SET01</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDT_LOCK</name>
          </field>
        </fields>
        <name>WDT_CTL</name>
        <resetMask>0xC0000001</resetMask>
        <resetValue>0xC0000001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x184</addressOffset>
        <description>Watchdog Counter Count Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Current value of WDT Counter.  The write feature of this register is for engineering use (DfV), have no synchronization, and can only be applied when the WDT is fully off.  When writing, the value is updated immediately in the WDT counter, but it will read back as the old value until this register resynchronizes just after the negedge of ILO.  Writes will be ignored if they occur when the WDT is enabled.</description>
            <name>COUNTER</name>
          </field>
        </fields>
        <name>WDT_CNT</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x188</addressOffset>
        <description>Watchdog Counter Match Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Match value for Watchdog counter.  Every time WDT_COUNTER reaches MATCH an interrupt is generated.  Two unserviced interrupts will lead to a system reset (i.e. at the third match).</description>
            <name>MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>The number of MSB bits of the watchdog timer that are NOT checked against MATCH.  This value provides control over the time-to-reset of the watchdog (which happens after 3 successive matches).  Up to 12 MSB can be ignored.  Settings &gt;12 behave like a setting of 12.</description>
            <name>IGNORE_BITS</name>
          </field>
        </fields>
        <name>WDT_MATCH</name>
        <resetMask>0xFFFFF</resetMask>
        <resetValue>0x1000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>Clock selection register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select source for LFCLK.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator.  Requires Backup domain to be present and properly configured (including external watch crystal, if used).</description>
                <name>WCO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock.  Capability is product-specific</description>
                <name>ALTLF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision ILO. If present, it works in DEEPSLEEP and higher modes.  Does not work in HIBERNATE mode.</description>
                <name>PILO</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LFCLK_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects clock PATH&lt;k&gt;, where k=PUMP_SEL.  The output of this mux goes to the PUMP_DIV to make PUMPCLK  Each product has a specific number of available clock paths.  Selecting a path that is not implemented on a product will result in undefined behavior.  Note that this is not a glitch free mux.</description>
            <name>PUMP_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Division ratio for PUMPCLK.  Uses selected PUMP_SEL clock as the source.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 16</description>
                <name>DIV_BY_16</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PUMP_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the pump clock.  PUMP_ENABLE and the PUMP_SEL mux are not glitch-free to minimize side-effects, avoid changing the PUMP_SEL and PUMP_DIV while changing PUMP_ENABLE.  To change the settings, do the following: 
            1) If the pump clock is enabled, write PUMP_ENABLE=0 without changing PUMP_SEL and PUMP_DIV.  
            2) Change PUMP_SEL and PUMP_DIV to desired settings with PUMP_ENABLE=0.  
            3) Write PUMP_ENABLE=1 without changing PUMP_SEL and PUMP_DIV.</description>
            <name>PUMP_ENABLE</name>
          </field>
        </fields>
        <name>CLK_SELECT</name>
        <resetMask>0xFF03</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x504</addressOffset>
        <description>Timer Clock Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select source for TIMERCLK.  The output of this mux can be further divided using TIMER_DIV.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal Main Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select the output of the predivider configured by TIMER_HF0_DIV.</description>
                <name>HF0_DIV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TIMER_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Predivider used when HF0_DIV is selected in TIMER_SEL.  If HFCLK0 frequency is less than 100MHz and has approximately 50 percent duty cycle, then no division is required (NO_DIV).  Otherwise, select a divide ratio of 2, 4, or 8 before selected HF0_DIV as the timer clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing or correcting duty cycle.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide HFCLK0 by 2.</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide HFCLK0 by 4.</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide HFCLK0 by 8.</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TIMER_HF0_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Divide selected timer clock source by (1+TIMER_DIV).  The output of this divider is TIMERCLK  Allows for integer divisions in the range [1, 256].  Do not change this setting while the timer is enabled.</description>
            <name>TIMER_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for TIMERCLK.
            0: TIMERCLK is off
            1: TIMERCLK is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_TIMER_CTL</name>
        <resetMask>0x80FF0301</resetMask>
        <resetValue>0x70000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50C</addressOffset>
        <description>ILO Configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If backup domain is present, this register indicates that ILO should stay enabled for use by backup domain during XRES, HIBERNATE mode, and through power-related resets like BOD.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.
            0: ILO turns off at XRES/BOD event or HIBERNATE entry.
            1: ILO remains on if backup domain is present and powered even for XRES/BOD or HIBERNATE entry.</description>
            <name>ILO_BACKUP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for ILO.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ILO_CONFIG</name>
        <resetMask>0x80000001</resetMask>
        <resetValue>0x80000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>IMO Configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for IMO oscillator.  This bit must be high at all times for all functions to work properly.  Hardware will automatically disable the IMO during DEEPSLEEP, HIBERNATE, and XRES.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_IMO_CONFIG</name>
        <resetMask>0x80000000</resetMask>
        <resetValue>0x80000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x514</addressOffset>
        <description>Fast Clock Output Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select signal for fast clock output #0</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL0 and HFCLK_SEL0.</description>
                <name>NC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>External Crystal Oscillator (ECO)</description>
                <name>ECO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>External clock input (EXTCLK)</description>
                <name>EXTCLK</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                <name>TIMERCLK</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the clock path chosen by PATH_SEL0 field</description>
                <name>PATH_SEL0</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the output of the HFCLK_SEL0 mux</description>
                <name>HFCLK_SEL0</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL0</description>
                <name>SLOW_SEL0</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FAST_SEL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path to use in fast clock output #0 logic.  For FLL path, it connects after the bypass mux.  For PLL path(s), it connects after the CLK_PLL_DDFT mux.
            0: FLL output
            1-15: PLL output on path1-path15 (if available)</description>
            <name>PATH_SEL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a HFCLK tree for use in fast clock output #0</description>
            <name>HFCLK_SEL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select signal for fast clock output #1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes, including PATH_SEL1 and HFCLK_SEL1.</description>
                <name>NC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>External Crystal Oscillator (ECO)</description>
                <name>ECO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>External clock input (EXTCLK)</description>
                <name>EXTCLK</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Alternate High-Frequency (ALTHF) clock input to SRSS</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Timer clock.  It is grouped with the fast clocks because it may be a gated version of a fast clock, and therefore may have a short high pulse.</description>
                <name>TIMERCLK</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the clock path chosen by PATH_SEL1 field</description>
                <name>PATH_SEL1</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the output of the HFCLK_SEL1 mux</description>
                <name>HFCLK_SEL1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the output of CLK_OUTPUT_SLOW.SLOW_SEL1</description>
                <name>SLOW_SEL1</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FAST_SEL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path to use in fast clock output #1 logic.  For FLL path, it connects after the bypass mux.  For PLL path(s), it connects after the CLK_PLL_DDFT mux.
            1-15: PLL output on path1-path15 (if available)</description>
            <name>PATH_SEL1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a HFCLK tree for use in fast clock output #1 logic</description>
            <name>HFCLK_SEL1</name>
          </field>
        </fields>
        <name>CLK_OUTPUT_FAST</name>
        <resetMask>0xFFF0FFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>Slow Clock Output Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select signal for slow clock output #0</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                <name>NC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Internal Low Speed Oscillator (ILO)</description>
                <name>ILO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watch-Crystal Oscillator (WCO)</description>
                <name>WCO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Root of the Backup domain clock tree (BAK)</description>
                <name>BAK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                <name>ALTLF</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Root of the low-speed clock tree (LFCLK)</description>
                <name>LFCLK</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                <name>IMO</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                <name>SLPCTRL</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Precision Internal Low Speed Oscillator (PILO)</description>
                <name>PILO</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLOW_SEL0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select signal for slow clock output #1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled - output is 0.  For power savings, clocks are blocked before entering any muxes.</description>
                <name>NC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Internal Low Speed Oscillator (ILO)</description>
                <name>ILO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watch-Crystal Oscillator (WCO)</description>
                <name>WCO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Root of the Backup domain clock tree (BAK)</description>
                <name>BAK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Alternate low-frequency clock input to SRSS (ALTLF)</description>
                <name>ALTLF</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Root of the low-speed clock tree (LFCLK)</description>
                <name>LFCLK</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Internal Main Oscillator (IMO).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                <name>IMO</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Sleep Controller clock (SLPCTRL).  This is grouped with the slow clocks so it can be observed during DEEPSLEEP entry/exit.</description>
                <name>SLPCTRL</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Precision Internal Low Speed Oscillator (PILO)</description>
                <name>PILO</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLOW_SEL1</name>
          </field>
        </fields>
        <name>CLK_OUTPUT_SLOW</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51C</addressOffset>
        <description>Clock Calibration Counter 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Down-counter clocked on fast DDFT output #0 (see TST_DDFT_FAST_CTL). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.</description>
            <name>CAL_COUNTER1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
            <name>CAL_COUNTER_DONE</name>
          </field>
        </fields>
        <name>CLK_CAL_CNT1</name>
        <resetMask>0x80FFFFFF</resetMask>
        <resetValue>0x80000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x520</addressOffset>
        <description>Clock Calibration Counter 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Up-counter clocked on fast DDFT output #1 (see TST_DDFT_FAST_CTL). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.COUNTER=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.COUNTER)</description>
            <name>CAL_COUNTER2</name>
          </field>
        </fields>
        <name>CLK_CAL_CNT2</name>
        <resetMask>0xFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x52C</addressOffset>
        <description>ECO Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Gain Control (AGC) enable.  When set, the oscillation amplitude is controlled to the level selected by ECO_TRIM0.ATRIM.  When low, the amplitude is not explicitly controlled and will grow until it saturates to the supply rail (1.8V nom).  WARNING: use care when disabling AGC because driving a crystal beyond its rated limit can permanently damage the crystal.</description>
            <name>AGC_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for ECO oscillator.</description>
            <name>ECO_EN</name>
          </field>
        </fields>
        <name>CLK_ECO_CONFIG</name>
        <resetMask>0x80000002</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x530</addressOffset>
        <description>ECO Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the ECO internal oscillator circuit has sufficient amplitude.  It may not meet the PPM accuracy or duty cycle spec.</description>
            <name>ECO_OK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the ECO internal oscillator circuit has fully stabilized.</description>
            <name>ECO_READY</name>
          </field>
        </fields>
        <name>CLK_ECO_STATUS</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x53C</addressOffset>
        <description>Precision ILO Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Fine frequency trim allowing +/-250ppm accuracy with periodic calibration.  The nominal step size of the LSB is 8Hz.</description>
            <name>PILO_FFREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the PILO clock output.  See PILO_EN field for required sequencing.</description>
            <name>PILO_CLK_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reset the PILO.  See PILO_EN field for required sequencing.</description>
            <name>PILO_RESET_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable PILO.  When enabling PILO, set PILO_EN=1, wait 1ms, then PILO_RESET_N=1 and PILO_CLK_EN=1.  When disabling PILO, clear PILO_EN=0, PILO_RESET_N=0, and PLO_CLK_EN=0 in the same write cycle.</description>
            <name>PILO_EN</name>
          </field>
        </fields>
        <name>CLK_PILO_CONFIG</name>
        <resetMask>0xE00003FF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x580</addressOffset>
        <description>FLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Multiplier to determine CCO frequency in multiples of the frequency of the selected reference clock (Fref).
            
            Ffll = (FLL_MULT)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV+1)</description>
            <name>FLL_MULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
            0: no division
            1: divide by 2</description>
            <name>FLL_OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for FLL.  Do not enable until the reference clock has stabilized.
            0: Block is powered off
            1: Block is powered on</description>
            <name>FLL_ENABLE</name>
          </field>
        </fields>
        <name>CLK_FLL_CONFIG</name>
        <resetMask>0x8103FFFF</resetMask>
        <resetValue>0x1000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x584</addressOffset>
        <description>FLL Configuration Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the FLL, and do not change it while FLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            8191: divide by 8191</description>
            <name>FLL_REF_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Lock tolerance sets the error threshold for when the FLL output is considered locked to the reference input.  A high tolerance can be used to lock more quickly or to track a less accurate source.  The tolerance should be set so that the FLL does not unlock under normal conditions.  The tolerance is the allowed difference between the count value for the ideal formula and the measured value. 
            0: tolerate error of 1 count value
            1: tolerate error of 2 count values
            ...
            511: tolerate error of 512 count values</description>
            <name>LOCK_TOL</name>
          </field>
        </fields>
        <name>CLK_FLL_CONFIG2</name>
        <resetMask>0x1FF1FFF</resetMask>
        <resetValue>0x20001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x588</addressOffset>
        <description>FLL Configuration Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>FLL Loop Filter Integral Gain Setting
            0: 1/256
            1: 1/128
            2: 1/64
            3: 1/32
            4: 1/16
            5: 1/8
            6: 1/4
            7: 1/2
            8: 1.0
            9: 2.0
            10: 4.0
            11: 8.0
            &gt;=12: illegal</description>
            <name>FLL_LF_IGAIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>FLL Loop Filter Proportional Gain Setting
            0: 1/256
            1: 1/128
            2: 1/64
            3: 1/32
            4: 1/16
            5: 1/8
            6: 1/4
            7: 1/2
            8: 1.0
            9: 2.0
            10: 4.0
            11: 8.0
            &gt;=12: illegal</description>
            <name>FLL_LF_PGAIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>Number of undivided reference clock cycles to wait after changing the CCO trim until the loop measurement restarts.  A delay allows the CCO output to settle and gives a more accurate measurement.  The default is tuned to an 8MHz reference clock since the IMO is expected to be the most common use case.
            0: no settling time
            1: wait one reference clock cycle
            ...
            8191: wait 8191 reference clock cycles</description>
            <name>SETTLING_COUNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after FLL output.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects FLL reference input (bypass mode).  When locked, automatically selects FLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select FLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>FLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select FLL output.  Ignores lock indicator.</description>
                <name>FLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <name>CLK_FLL_CONFIG3</name>
        <resetMask>0x301FFFFF</resetMask>
        <resetValue>0x2800</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58C</addressOffset>
        <description>FLL Configuration Register 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Maximum CCO offset allowed (used to prevent FLL dynamics from selecting an CCO frequency that the logic cannot support)</description>
            <name>CCO_LIMIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Frequency range of CCO</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Target frequency is in range [48, 64) MHz</description>
                <name>RANGE0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Target frequency is in range [64, 85) MHz</description>
                <name>RANGE1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Target frequency is in range [85, 113) MHz</description>
                <name>RANGE2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Target frequency is in range [113, 150) MHz</description>
                <name>RANGE3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Target frequency is in range [150, 200] MHz</description>
                <name>RANGE4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CCO_RANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>CCO frequency code.  This is updated by HW when the FLL is enabled.  It can be manually updated to use the CCO in an open loop configuration.  The meaning of each frequency code depends on the range.</description>
            <name>CCO_FREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable CCO frequency update by FLL hardware
            0: Hardware update of CCO settings is allowed.  Use this setting for normal FLL operation.
            1: Hardware update of CCO settings is disabled.  Use this setting for open-loop FLL operation.</description>
            <name>CCO_HW_UPDATE_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the CCO.  It is required to enable the CCO before using the FLL.  
            0: Block is powered off
            1: Block is powered on</description>
            <name>CCO_ENABLE</name>
          </field>
        </fields>
        <name>CLK_FLL_CONFIG4</name>
        <resetMask>0xC1FF07FF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x590</addressOffset>
        <description>FLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This indicates that the CCO is internally settled and ready to use.</description>
            <name>CCO_READY</name>
          </field>
        </fields>
        <name>CLK_FLL_STATUS</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x700</addressOffset>
        <description>SRSS Interrupt Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WDT Interrupt Request.  This bit is set each time WDT_COUNTR==WDT_MATCH.  W1C also feeds the watch dog.  Missing 2 interrupts in a row will generate a reset.  Due to internal synchronization, it takes 2 SYSCLK cycles to update after a W1C.</description>
            <name>WDT_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt for low voltage detector HVLVD1</description>
            <name>HVLVD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock calibration counter is done</description>
            <name>CLK_CAL</name>
          </field>
        </fields>
        <name>SRSS_INTR</name>
        <resetMask>0x23</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x704</addressOffset>
        <description>SRSS Interrupt Set Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set interrupt for low voltage detector WDT_MATCH</description>
            <name>WDT_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set interrupt for low voltage detector HVLVD1</description>
            <name>HVLVD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set interrupt for clock calibration counter done</description>
            <name>CLK_CAL</name>
          </field>
        </fields>
        <name>SRSS_INTR_SET</name>
        <resetMask>0x23</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x708</addressOffset>
        <description>SRSS Interrupt Mask Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.  It will not, however, disable the WDT reset generation on 2 missed interrupts.</description>
            <name>WDT_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask for low voltage detector HVLVD1</description>
            <name>HVLVD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask for clock calibration done</description>
            <name>CLK_CAL</name>
          </field>
        </fields>
        <name>SRSS_INTR_MASK</name>
        <resetMask>0x23</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70C</addressOffset>
        <description>SRSS Interrupt Masked Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WDT_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>HVLVD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>CLK_CAL</name>
          </field>
        </fields>
        <name>SRSS_INTR_MASKED</name>
        <resetMask>0x23</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x710</addressOffset>
        <description>SRSS Interrupt Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sets which edge(s) will trigger an IRQ for HVLVD1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both rising and falling edges</description>
                <name>BOTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HVLVD1_EDGE_SEL</name>
          </field>
        </fields>
        <name>SRSS_INTR_CFG</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x800</addressOffset>
        <description>Reset Cause Observation Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A basic WatchDog Timer (WDT) reset has occurred since last power cycle.</description>
            <name>RESET_WDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Fault logging system requested a reset from its Active logic.</description>
            <name>RESET_ACT_FAULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Fault logging system requested a reset from its DeepSleep logic.</description>
            <name>RESET_DPSLP_FAULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock supervision logic requested a reset due to loss of a watch-crystal clock.</description>
            <name>RESET_CSV_WCO_LOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A CPU requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
            <name>RESET_SOFT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-Counter Watchdog timer reset #0 has occurred since last power cycle.</description>
            <name>RESET_MCWDT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-Counter Watchdog timer reset #1 has occurred since last power cycle.</description>
            <name>RESET_MCWDT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-Counter Watchdog timer reset #2 has occurred since last power cycle.</description>
            <name>RESET_MCWDT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-Counter Watchdog timer reset #3 has occurred since last power cycle.</description>
            <name>RESET_MCWDT3</name>
          </field>
        </fields>
        <name>RES_CAUSE</name>
        <resetMask>0x1FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x804</addressOffset>
        <description>Reset Cause Observation Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock supervision logic requested a reset due to loss of a high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
            <name>RESET_CSV_HF_LOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock supervision logic requested a reset due to frequency error of high-frequency clock.  Each bit index K corresponds to a HFCLK&lt;K&gt;.  Unimplemented clock bits return zero.</description>
            <name>RESET_CSV_HF_FREQ</name>
          </field>
        </fields>
        <name>RES_CAUSE2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7F00</addressOffset>
        <description>Reference Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Active-Reference temperature trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0 -&gt; default setting at POR; not for trimming use
            others -&gt; normal trim range</description>
            <name>ACT_REF_TCTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Active-Reference current trim.   This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0 -&gt; default setting at POR; not for trimming use
            others -&gt; normal trim range</description>
            <name>ACT_REF_ITRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Active-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0 -&gt; default setting at POR; not for trimming use
            others -&gt; normal trim range</description>
            <name>ACT_REF_ABSTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active-Reference current boost.   This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0: normal operation
            others: risk mitigation</description>
            <name>ACT_REF_IBOOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>DeepSleep-Reference temperature trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.
            0 -&gt; default setting at POR; not for trimming use
            others -&gt; normal trim range</description>
            <name>DPSLP_REF_TCTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>DeepSleep-Reference absolute voltage trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>DPSLP_REF_ABSTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>DeepSleep current reference trim.   This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>DPSLP_REF_ITRIM</name>
          </field>
        </fields>
        <name>PWR_TRIM_REF_CTL</name>
        <resetMask>0xF1FF5FFF</resetMask>
        <resetValue>0x70F00000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7F04</addressOffset>
        <description>BOD/OVP Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HVPORBOD trip point selection.  Monitors vddd.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>HVPORBOD_TRIPSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>HVPORBOD_OFSTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HVPORBOD current trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>HVPORBOD_ITRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>LVPORBOD trip point selection.  Monitors vccd.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>LVPORBOD_TRIPSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>LVPORBOD offset trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>LVPORBOD_OFSTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>LVPORBOD current trim.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>LVPORBOD_ITRIM</name>
          </field>
        </fields>
        <name>PWR_TRIM_BODOVP_CTL</name>
        <resetMask>0xFDFF7</resetMask>
        <resetValue>0x40D04</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7F08</addressOffset>
        <description>CCO Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>CCO reference current source trim.</description>
            <name>CCO_RCSTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Terminal count for the stabilization counter from CCO_ENABLE until stable.</description>
            <name>CCO_STABLE_CNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the automatic stabilization counter.</description>
            <name>ENABLE_CNT</name>
          </field>
        </fields>
        <name>CLK_TRIM_CCO_CTL</name>
        <resetMask>0xBF00003F</resetMask>
        <resetValue>0xA7000020</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7F0C</addressOffset>
        <description>CCO Trim Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>CCO frequency 1st range calibration</description>
            <name>CCO_FCTRIM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>CCO frequency 2nd range calibration</description>
            <name>CCO_FCTRIM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>CCO frequency 3rd range calibration</description>
            <name>CCO_FCTRIM3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>CCO frequency 4th range calibration</description>
            <name>CCO_FCTRIM4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>CCO frequency 5th range calibration</description>
            <name>CCO_FCTRIM5</name>
          </field>
        </fields>
        <name>CLK_TRIM_CCO_CTL2</name>
        <resetMask>0x1FFFFFF</resetMask>
        <resetValue>0x884110</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7F30</addressOffset>
        <description>Wakeup Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Wakeup holdoff.  Spec (fastest) wake time is achieve with a setting of 0.  Additional delay can be added for debugging or workaround.  The delay is counted by the IMO.</description>
            <name>WAKE_DELAY</name>
          </field>
        </fields>
        <name>PWR_TRIM_WAKE_CTL</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF10</addressOffset>
        <description>LVD Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HVLVD1 offset trim</description>
            <name>HVLVD1_OFSTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HVLVD1 current trim</description>
            <name>HVLVD1_ITRIM</name>
          </field>
        </fields>
        <name>PWR_TRIM_LVD_CTL</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x20</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF18</addressOffset>
        <description>ILO Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>ILO frequency trims.  LSB step size is 1.5 percent (typical) of the frequency.</description>
            <name>ILO_FTRIM</name>
          </field>
        </fields>
        <name>CLK_TRIM_ILO_CTL</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x2C</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF1C</addressOffset>
        <description>Power System Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trim for the Active-Regulator.  This sets the output voltage level.  This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.  The nominal output voltage is vccd=812.5mV + ACT_REG_TRIM*12.5mV.  The actual output voltage will vary depending on conditions and load.  The following settings are explicitly shown for convenience, and other values may be calculated using the formula:
            5'h07: 900mV (nominal)
            5'h17: 1100mV (nominal)</description>
            <name>ACT_REG_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Controls the tradeoff between output current and internal operating current for the Active Regulator.  The maximum output current depends on the silicon implementation, but an application may limit its maximum current to less than that.  This may allow a reduction in the internal operating current of the regulator.  The regulator internal operating current depends on the boost setting:
            2'b00: 50uA
            2'b01: 100uA
            2'b10: 150uA
            2'b11: 200uA
            
            The allowed setting is a lookup table based on the chip-specific maximum (set in factory) and an application-specific maximum (set by customer).  The defaults are set assuming the application consumes the maximum allowed by the chip.
            50mA chip: 2'b00 (default);
            100mA chip: 2'b00 (default);
            150mA chip: 50..100mA app =&gt; 2'b00, 150mA app =&gt; 2'b01 (default);
            200mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200mA app =&gt; 2'b10 (default);
            250mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01,  200..250mA app =&gt; 2'b10 (default);
            300mA chip: 50mA app =&gt; 2'b00, 100..150mA app =&gt; 2'b01, 200..250mA app =&gt; 2'b10, 300mA app =&gt; 2'b11 (default);
            
            This register is only reset by XRES/POR/BOD/OVP/HIBERNATE.</description>
            <name>ACT_REG_BOOST</name>
          </field>
        </fields>
        <name>PWR_TRIM_PWRSYS_CTL</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x17</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF20</addressOffset>
        <description>ECO Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Watch Dog Trim -  Delta voltage below stead state level
            0x0 - 50mV
            0x1 - 75mV
            0x2 - 100mV
            0x3 - 125mV
            0x4 - 150mV
            0x5 - 175mV
            0x6 - 200mV
            0x7 - 225mV</description>
            <name>WDTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Amplitude trim to set the crystal drive level when ECO_CONFIG.AGC_EN=1.  WARNING: use care when setting this field because driving a crystal beyond its rated limit can permanently damage the crystal.
            0x0 - 150mV
            0x1 - 175mV
            0x2 - 200mV
            0x3 - 225mV
            0x4 - 250mV
            0x5 - 275mV
            0x6 - 300mV
            0x7 - 325mV
            0x8 - 350mV
            0x9 - 375mV
            0xA - 400mV
            0xB - 425mV
            0xC - 450mV
            0xD - 475mV
            0xE - 500mV
            0xF - 525mV</description>
            <name>ATRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Filter Trim - 3rd harmonic oscillation</description>
            <name>FTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Feedback resistor Trim</description>
            <name>RTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Gain Trim - Startup time</description>
            <name>GTRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Current Trim</description>
            <name>ITRIM</name>
          </field>
        </fields>
        <name>CLK_TRIM_ECO_CTL</name>
        <resetMask>0x3F3FF7</resetMask>
        <resetValue>0x1F0003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF24</addressOffset>
        <description>PILO Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Coarse frequency trim to meet 32.768kHz +/-2 percent across PVT without calibration.  The nominal step size of the LSB is 1kHz.</description>
            <name>PILO_CFREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Trim for current in oscillator block.</description>
            <name>PILO_OSC_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim for comparator bias current.</description>
            <name>PILO_COMP_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim for biasn by trimming sub-Vth NMOS width in beta-multiplier</description>
            <name>PILO_NBIAS_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trim for beta-multiplier branch current</description>
            <name>PILO_RES_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim for beta-multiplier current slope</description>
            <name>PILO_ISLOPE_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Trim for VT-DIFF output (internal power supply)</description>
            <name>PILO_VTDIFF_TRIM</name>
          </field>
        </fields>
        <name>CLK_TRIM_PILO_CTL</name>
        <resetMask>0x7DFF703F</resetMask>
        <resetValue>0x108500F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF28</addressOffset>
        <description>PILO Trim Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trim for voltage reference</description>
            <name>PILO_VREF_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Trim for beta-multiplier current reference</description>
            <name>PILO_IREFBM_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trim for current reference</description>
            <name>PILO_IREF_TRIM</name>
          </field>
        </fields>
        <name>CLK_TRIM_PILO_CTL2</name>
        <resetMask>0xFF1FFF</resetMask>
        <resetValue>0xDA10E0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF2C</addressOffset>
        <description>PILO Trim Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Engineering options for PILO circuits
            0: Short vdda to vpwr
            1: Beta:mult current change
            2: Iref generation Ptat current addition
            3: Disable current path in secondary Beta:mult startup circuit
            4: Double oscillator current
            5: Switch between deep:sub:threshold and sub:threshold stacks in Vref generation block
            6: Spare
            7: Ptat component increase in Iref
            8: vpwr_rc and vpwr_dig_rc shorting testmode
            9: Switch b/w psub connection for cascode nfet for vref generation
            10: Switch between sub:threshold and deep:sub:threshold stacks in comparator.
            15-11: Frequency fine trim.  See AKK-444 for an overview of the trim strategy.</description>
            <name>PILO_ENGOPT</name>
          </field>
        </fields>
        <name>CLK_TRIM_PILO_CTL3</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x4800</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[8]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[9]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA8</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[10]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[11]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB0</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[12]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB4</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[13]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB8</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[14]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC</addressOffset>
        <description>HIBERNATE Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Additional data that is retained through a HIBERNATE/WAKEUP sequence that can be used by firmware for any application-specific purpose.  Note that waking up from HIBERNATE using XRES will reset this register.</description>
            <name>HIB_DATA</name>
          </field>
        </fields>
        <name>PWR_HIB_DATA[15]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[0]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[1]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[2]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[3]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[4]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[5]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[6]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[7]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[8]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x324</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[9]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x328</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[10]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32C</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[11]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x330</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[12]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x334</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[13]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x338</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[14]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x33C</addressOffset>
        <description>Clock DSI Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Selects a DSI source or low frequency clock for use in a clock path.  The output of this mux can be selected for clock PATH&lt;i&gt; using CLK_SELECT_PATH register.  Using the output of this mux as HFCLK source will result in undefined behavior.  It can be used to clocks to DSI or to the reference inputs of FLL/PLL, subject to the frequency limits of those circuits.  This mux is not glitch free, so do not change the selection while it is an actively selected clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI0 - dsi_out[0]</description>
                <name>DSI_OUT0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI1 - dsi_out[1]</description>
                <name>DSI_OUT1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI2 - dsi_out[2]</description>
                <name>DSI_OUT2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI3 - dsi_out[3]</description>
                <name>DSI_OUT3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI4 - dsi_out[4]</description>
                <name>DSI_OUT4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI5 - dsi_out[5]</description>
                <name>DSI_OUT5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI6 - dsi_out[6]</description>
                <name>DSI_OUT6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI7 - dsi_out[7]</description>
                <name>DSI_OUT7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI8 - dsi_out[8]</description>
                <name>DSI_OUT8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI9 - dsi_out[9]</description>
                <name>DSI_OUT9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI10 - dsi_out[10]</description>
                <name>DSI_OUT10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI11 - dsi_out[11]</description>
                <name>DSI_OUT11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI12 - dsi_out[12]</description>
                <name>DSI_OUT12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI13 - dsi_out[13]</description>
                <name>DSI_OUT13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI14 - dsi_out[14]</description>
                <name>DSI_OUT14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI15 - dsi_out[15]</description>
                <name>DSI_OUT15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ILO - Internal Low-speed Oscillator</description>
                <name>ILO</name>
                <value>0x10</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WCO - Watch-Crystal Oscillator</description>
                <name>WCO</name>
                <value>0x11</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTLF - Alternate Low-Frequency Clock</description>
                <name>ALTLF</name>
                <value>0x12</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PILO - Precision Internal Low-speed Oscillator</description>
                <name>PILO</name>
                <value>0x13</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_MUX</name>
          </field>
        </fields>
        <name>CLK_DSI_SELECT[15]</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x340</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[0]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x344</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[1]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x348</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[2]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34C</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[3]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x350</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[4]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x354</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[5]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x358</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[6]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x35C</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[7]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x360</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[8]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x364</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[9]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x368</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[10]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x36C</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[11]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x370</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[12]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x374</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[13]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x378</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[14]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x37C</addressOffset>
        <description>Clock Path Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects a source for clock PATH&lt;i&gt;.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IMO - Internal R/C Oscillator</description>
                <name>IMO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>EXTCLK - External Clock Pin</description>
                <name>EXTCLK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ECO - External-Crystal Oscillator</description>
                <name>ECO</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ALTHF - Alternate High-Frequency clock input (product-specific clock)</description>
                <name>ALTHF</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>DSI_MUX - Output of DSI mux for this path.  Using a DSI source directly as root of HFCLK will result in undefined behavior.</description>
                <name>DSI_MUX</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PATH_MUX</name>
          </field>
        </fields>
        <name>CLK_PATH_SELECT[15]</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x380</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[0]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x384</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[1]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x388</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[2]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38C</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[3]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x390</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[4]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x394</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[5]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x398</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[6]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x39C</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[7]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3A0</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[8]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3A4</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[9]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3A8</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[10]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3AC</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[11]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3B0</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[12]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3B4</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[13]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3B8</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[14]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3BC</addressOffset>
        <description>Clock Root Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects a clock path as the root of HFCLK&lt;k&gt; and for SRSS DSI input &lt;k&gt;.  Use CLK_SELECT_PATH[i] to configure the desired path.  Some paths may have FLL or PLL available (product-specific), and the control and bypass mux selections of these are in other registers.  Configure the FLL using CLK_FLL_CONFIG register.  Configure a PLL using the related CLK_PLL_CONFIG[k] register.  Note that not all products support all clock sources.  Selecting a clock source that is not supported will result in undefined behavior.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH0 (can be configured for FLL)</description>
                <name>PATH0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH1 (can be configured for PLL0, if available in the product)</description>
                <name>PATH1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH2 (can be configured for PLL1, if available in the product)</description>
                <name>PATH2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH3 (can be configured for PLL2, if available in the product)</description>
                <name>PATH3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH4 (can be configured for PLL3, if available in the product)</description>
                <name>PATH4</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH5 (can be configured for PLL4, if available in the product)</description>
                <name>PATH5</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH6 (can be configured for PLL5, if available in the product)</description>
                <name>PATH6</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH7 (can be configured for PLL6, if available in the product)</description>
                <name>PATH7</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH8 (can be configured for PLL7, if available in the product)</description>
                <name>PATH8</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH9 (can be configured for PLL8, if available in the product)</description>
                <name>PATH9</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH10 (can be configured for PLL9, if available in the product)</description>
                <name>PATH10</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH11 (can be configured for PLL10, if available in the product)</description>
                <name>PATH11</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH12 (can be configured for PLL11, if available in the product)</description>
                <name>PATH12</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH13 (can be configured for PLL12, if available in the product)</description>
                <name>PATH13</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH14 (can be configured for PLL13, if available in the product)</description>
                <name>PATH14</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PATH15 (can be configured for PLL14, if available in the product)</description>
                <name>PATH15</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_MUX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects predivider value for this clock root and DSI input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                <name>NO_DIV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 2</description>
                <name>DIV_BY_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 4</description>
                <name>DIV_BY_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide selected clock source by 8</description>
                <name>DIV_BY_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROOT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for this clock root.  All clock roots default to disabled (ENABLE==0) except HFCLK0, which cannot be disabled.</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_ROOT_SELECT[15]</name>
        <resetMask>0x8000003F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x600</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[0]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x604</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[1]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x608</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[2]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60C</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[3]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x610</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[4]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x614</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[5]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x618</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[6]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x61C</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[7]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x620</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[8]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x624</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[9]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x628</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[10]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x62C</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[11]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x630</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[12]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x634</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[13]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x638</addressOffset>
        <description>PLL Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Control bits for feedback divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0-21: illegal (undefined behavior)
            22: divide by 22
            ...
            112: divide by 112
            &gt;112: illegal (undefined behavior)</description>
            <name>FEEDBACK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for reference divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: divide by 1
            ...
            20: divide by 20
            others: illegal (undefined behavior)</description>
            <name>REFERENCE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Control bits for Output divider.  Set the divide value before enabling the PLL, and do not change it while PLL is enabled.
            0: illegal (undefined behavior)
            1: illegal (undefined behavior) 
            2: divide by 2.  Suitable for direct usage as HFCLK source.
            ...
            16: divide by 16.  Suitable for direct usage as HFCLK source.
            &gt;16: illegal (undefined behavior)</description>
            <name>OUTPUT_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VCO frequency range selection.  Configure this bit according to the targeted VCO frequency.  Do not change this setting while the PLL is enabled.
            0: VCO frequency is [200MHz, 400MHz]
            1: VCO frequency is [170MHz, 200MHz)</description>
            <name>PLL_LF_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Bypass mux located just after PLL output.  This selection is glitch-free and can be changed while the PLL is running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Automatic using lock indicator.  When unlocked, automatically selects PLL reference input (bypass mode).  When locked, automatically selects PLL output.</description>
                <name>AUTO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Same as AUTO</description>
                <name>AUTO1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL reference input (bypass mode).  Ignores lock indicator</description>
                <name>PLL_REF</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select PLL output.  Ignores lock indicator.</description>
                <name>PLL_OUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for PLL.  Setup FEEDBACK_DIV, REFERENCE_DIV, and OUTPUT_DIV at least one cycle before setting ENABLE=1.  
            
            Fpll = (FEEDBACK_DIV)  * (Fref / REFERENCE_DIV) / (OUTPUT_DIV)
            
            0: Block is disabled
            1: Block is enabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CLK_PLL_CONFIG[14]</name>
        <resetMask>0xB81F1F7F</resetMask>
        <resetValue>0x20116</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x640</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[0]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x644</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[1]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x648</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[2]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64C</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[3]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x650</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[4]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x654</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[5]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x658</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[6]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x65C</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[7]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x660</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[8]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x664</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[9]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x668</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[10]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x66C</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[11]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x670</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[12]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x674</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[13]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x678</addressOffset>
        <description>PLL Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Lock Indicator</description>
            <name>LOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit sets whenever the PLL Lock bit goes low, and stays set until cleared by firmware.</description>
            <name>UNLOCK_OCCURRED</name>
          </field>
        </fields>
        <name>CLK_PLL_STATUS[14]</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40270000</baseAddress>
    <description>SRSS Backup Domain</description>
    <interrupts></interrupts>
    <name>BACKUP</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watch-crystal oscillator (WCO) enable.  If there is a write in progress when this bit is cleared, the WCO will be internally kept on until the write completes.
            After enabling the WCO software must wait until STATUS.WCO_OK=1 before configuring any component that depends on clk_lf/clk_bak, like for example RTC or WDTs.</description>
            <name>WCO_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock select for BAK clock</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watch-crystal oscillator input.</description>
                <name>WCO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>This allows to use the LFCLK selection as an alternate backup domain clock.  Note that LFCLK is not available in all power modes, and clock glitches can propagate into the backup logic when the clock is stopped.  For this reason, if the WCO is intended as the clock source then choose it directly instead of routing through LFCLK.</description>
                <name>ALTBAK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <name>PRESCALER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configures the WCO for different board-level connections to the WCO pins.  For example, this can be used to connect an external watch crystal oscillator instead of a watch crystal.   In all cases, the two related GPIO pins (WCO input and output pins) must be configured as analog connections using GPIO registers, and they must be hooked at the board level as described below.  Configure this field before enabling the WCO, and do not change this setting when WCO_EN=1.
            0: Watch crystal.  Connect a 32.768 kHz watch crystal between WCO input and output pins.
            1: Clock signal, either a square wave or sine wave.  See PRESCALER field for connection information.</description>
            <name>WCO_BYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Controls the behavior of the switch that generates vddbak from vbackup or vddd.
            0: automatically select vddd if its brownout detector says it is valid.  If the brownout says its not valid, then use vmax which is the highest of vddd or vbackup.
            1,2,3: force vddbak and vmax to select vbackup, regardless of its voltage.</description>
            <name>VDDBAK_CTL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Connect vbackup supply to the vbackup_meas output for measurement by an ADC attached to amuxbusa_adft_vddd.  The vbackup_meas signal is scaled by 40 percent so it is within the supply range of the ADC.</description>
            <name>VBACKUP_MEAS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>When set to 3C, the supercap charger circuit is enabled.  Any other code disables the supercap charger.  THIS CHARGING CIRCUIT IS FOR A SUPERCAP ONLY AND CANNOT SAFELY CHARGE A BATTERY.  DO NOT WRITE THIS KEY WHEN VBACKUP IS CONNECTED TO A BATTERY.</description>
            <name>EN_CHARGE_KEY</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xFF0F3308</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>RTC Read Write register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read bit
            When this bit is set the RTC registers will be copied to user registers and frozen so that a coherent RTC value can safely be read. The RTC will keep on running.
            Do not set the read bit if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Write bit is set. Do not set the Read bit at the same time that the Write bit is cleared.</description>
            <name>READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write bit
            Only when this bit is set can the RTC registers be written to (otherwise writes are ignored). This bit cannot be set if the RTC is still busy with a previous update (see RTC_BUSY bit) or if the Read bit is set or getting set. 
            The user writes to the RTC user registers, when the Write bit is cleared by the user then the user registers content is copied to the actual RTC registers. 
            Only user RTC registers that were written to will get copied, others will not be affected. 
            When the SECONDS field is updated then TICKS will also be reset (WDT is not affected).
            When the Write bit is cleared by a reset (brown out/DeepSleep) then the RTC update will be ignored/lost.
            Do not set the Write bit if the RTC if the RTC is still busy with a previous update (see RTC_BUSY).  Do not set the Write bit at the same time that the Read bit is cleared.</description>
            <name>WRITE</name>
          </field>
        </fields>
        <name>RTC_RW</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Oscillator calibration for absolute frequency</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Calibration value for absolute frequency (at a fixed temperature).  Each step causes 128 ticks to be added or removed each hour.  Effectively that means that each step is 1.085ppm (= 128/(60*60*32,768)).
            Positive values 0x01-0x3c (1..60) add pulses, negative values remove pulses, thus giving a range of +/-65.1 ppm (limited by 60 minutes per hour, not the range of this field)
            
            Calibration is performed hourly, starting at 59 minutes and 59 seconds, and applied as 64 ticks every 30 seconds until there have been 2*CALIB_VAL adjustments.</description>
            <name>CALIB_VAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Calibration sign:
            0= Negative sign: remove pulses (it takes more clock ticks to count one second)
            1= Positive sign: add pulses (it takes less clock ticks to count one second)</description>
            <name>CALIB_SIGN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output enable for 512Hz signal for calibration and allow CALIB_VAL to be written. Note that calibration does not affect the 512Hz output signal.</description>
            <name>CAL_OUT</name>
          </field>
        </fields>
        <name>CAL_CTL</name>
        <resetMask>0x8000007F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>pending RTC write</description>
            <name>RTC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates that output has transitioned.</description>
            <name>WCO_OK</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x5</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Calendar Seconds, Minutes, Hours, Day of Week</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Calendar seconds in BCD, 0-59</description>
            <name>RTC_SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Calendar minutes in BCD, 0-59</description>
            <name>RTC_MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Calendar hours in BCD, value depending on 12/24HR mode
            0=24HR: [21:16]=0-23
            1=12HR: [21]:0=AM, 1=PM, [20:16]=1-12</description>
            <name>RTC_HOUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select 12/24HR mode: 1=12HR, 0=24HR</description>
            <name>CTRL_12HR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Calendar Day of the week in BCD, 1-7
            It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
            <name>RTC_DAY</name>
          </field>
        </fields>
        <name>RTC_TIME</name>
        <resetMask>0x77F7F7F</resetMask>
        <resetValue>0x1000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Calendar Day of Month, Month,  Year</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Calendar Day of the Month in BCD, 1-31
            Automatic Leap Year Correction</description>
            <name>RTC_DATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Calendar Month in BCD, 1-12</description>
            <name>RTC_MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Calendar year in BCD, 0-99</description>
            <name>RTC_YEAR</name>
          </field>
        </fields>
        <name>RTC_DATE</name>
        <resetMask>0xFF1F3F</resetMask>
        <resetValue>0x101</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Alarm 1 Seconds, Minute, Hours, Day of Week</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Alarm seconds in BCD, 0-59</description>
            <name>ALM_SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm second enable: 0=ignore, 1=match</description>
            <name>ALM_SEC_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Alarm minutes in BCD, 0-59</description>
            <name>ALM_MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm minutes enable: 0=ignore, 1=match</description>
            <name>ALM_MIN_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Alarm hours in BCD, value depending on 12/24HR mode
            12HR: [5]:0=AM, 1=PM, [4:0]=1-12
            24HR: [5:0]=0-23</description>
            <name>ALM_HOUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm hour enable: 0=ignore, 1=match</description>
            <name>ALM_HOUR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Alarm Day of the week in BCD, 1-7
            It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
            <name>ALM_DAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
            <name>ALM_DAY_EN</name>
          </field>
        </fields>
        <name>ALM1_TIME</name>
        <resetMask>0x87BFFFFF</resetMask>
        <resetValue>0x1000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Alarm 1 Day of Month, Month</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Alarm Day of the Month in BCD, 1-31
            Leap Year corrected</description>
            <name>ALM_DATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
            <name>ALM_DATE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Alarm Month in BCD, 1-12</description>
            <name>ALM_MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Month enable: 0=ignore, 1=match</description>
            <name>ALM_MON_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for alarm 1.
            0: Alarm 1 is disabled.  Fields for date and time are ignored.
            1: Alarm 1 is enabled.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
            <name>ALM_EN</name>
          </field>
        </fields>
        <name>ALM1_DATE</name>
        <resetMask>0x80009FBF</resetMask>
        <resetValue>0x101</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Alarm 2 Seconds, Minute, Hours, Day of Week</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Alarm seconds in BCD, 0-59</description>
            <name>ALM_SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm second enable: 0=ignore, 1=match</description>
            <name>ALM_SEC_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Alarm minutes in BCD, 0-59</description>
            <name>ALM_MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm minutes enable: 0=ignore, 1=match</description>
            <name>ALM_MIN_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Alarm hours in BCD, value depending on 12/24HR mode
            12HR: [5]:0=AM, 1=PM, [4:0]=1-12
            24HR: [5:0]=0-23</description>
            <name>ALM_HOUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm hour enable: 0=ignore, 1=match</description>
            <name>ALM_HOUR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Alarm Day of the week in BCD, 1-7
            It is up to the user to define the meaning of the values, but 1=Monday is recommended</description>
            <name>ALM_DAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Day of the Week enable: 0=ignore, 1=match</description>
            <name>ALM_DAY_EN</name>
          </field>
        </fields>
        <name>ALM2_TIME</name>
        <resetMask>0x87BFFFFF</resetMask>
        <resetValue>0x1000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Alarm 2 Day of Month, Month</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Alarm Day of the Month in BCD, 1-31
            Leap Year corrected</description>
            <name>ALM_DATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Day of the Month enable: 0=ignore, 1=match</description>
            <name>ALM_DATE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Alarm Month in BCD, 1-12</description>
            <name>ALM_MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Month enable: 0=ignore, 1=match</description>
            <name>ALM_MON_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master enable for alarm 2.
            0: Alarm 2 is disabled.  Fields for date and time are ignored.
            1: Alarm 2 is enabled.  If none of the date and time fields are enabled, then this alarm triggers once every second.</description>
            <name>ALM_EN</name>
          </field>
        </fields>
        <name>ALM2_DATE</name>
        <resetMask>0x80009FBF</resetMask>
        <resetValue>0x101</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>Interrupt request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm 1 Interrupt</description>
            <name>ALARM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm 2 Interrupt</description>
            <name>ALARM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Century overflow interrupt</description>
            <name>CENTURY</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Interrupt set request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>ALARM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>ALARM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>CENTURY</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Interrupt mask register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>ALARM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>ALARM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>CENTURY</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Interrupt masked request register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>ALARM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>ALARM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>CENTURY</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3C</addressOffset>
        <description>32kHz oscillator counter</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>32kHz oscillator count (msb=128Hz), calibration can cause bit 6 to skip.  Reset when RTC_TIME.RTC_SEC fields is written.</description>
            <name>CNT32KHZ</name>
          </field>
        </fields>
        <name>OSCCNT</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>128Hz tick counter</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>128Hz counter (msb=2Hz)
            When SECONDS is written this field will be reset.</description>
            <name>CNT128HZ</name>
          </field>
        </fields>
        <name>TICKS</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>PMIC control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This byte must be set to 0x3A for PMIC to be disabled.  When the UNLOCK code is not present: writes to PMIC_EN field are ignored and the hardware ignores the value in PMIC_EN.  Do not change PMIC_EN in the same write cycle as setting/clearing the UNLOCK code; do these in separate write cycles.</description>
            <name>UNLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>0: Pin input of 0 will set PMIC_EN.
            1: Pin input of 1 will set PMIC_EN.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output enable for the output driver in the PMIC_EN pad.
            0: Output pad is tristate for PMIC_EN pin.  This can allow this pin to be used for another purpose. Tristate condition is kept only if the UNLOCK key (0x3A) is present
            1: Output pad is enabled for PMIC_EN pin.</description>
            <name>PMIC_EN_OUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Override normal PMIC controls to prevent accidentally turning off the PMIC by errant firmware.
            0: Normal operation, PMIC_EN and PMIC_OUTEN work as described
            1: PMIC_EN and PMIC_OUTEN are ignored and the output pad is forced enabled.
            Note: This bit is a write-once bit until the next backup reset.</description>
            <name>PMIC_ALWAYSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for external PMIC that supplies vddd (if present).  This bit will only clear if UNLOCK was written correctly in a previous write operation and PMIC_ALWAYSEN=0.  When PMIC_EN=0, the system functions normally until vddd is no longer present (OFF w/Backup mode).  Firmware can set this bit, if it does so before vddd is actually removed.  This bit is also set by any RTC alarm or PMIC pin wakeup event regardless of UNLOCK setting.</description>
            <name>PMIC_EN</name>
          </field>
        </fields>
        <name>PMIC_CTL</name>
        <resetMask>0xE001FF00</resetMask>
        <resetValue>0xA0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Backup reset register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 to this register resets the backup logic.  Hardware clears it when the reset is complete.  After setting this register, firmware should confirm it reads as 0 before attempting to write other backup registers.</description>
            <name>RESET</name>
          </field>
        </fields>
        <name>RESET</name>
        <resetMask>0x80000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFF00</addressOffset>
        <description>Trim Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>WCO trim</description>
            <name>TRIM</name>
          </field>
        </fields>
        <name>TRIM</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1000</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1004</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1008</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1010</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1014</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1018</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x101C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1020</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[8]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1024</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[9]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1028</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[10]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x102C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[11]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1030</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[12]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1034</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[13]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1038</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[14]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x103C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[15]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1040</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[16]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1044</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[17]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1048</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[18]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[19]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1050</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[20]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1054</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[21]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1058</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[22]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x105C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[23]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1060</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[24]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1064</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[25]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1068</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[26]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x106C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[27]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1070</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[28]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1074</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[29]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1078</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[30]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x107C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[31]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1080</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[32]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1084</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[33]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1088</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[34]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[35]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1090</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[36]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1094</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[37]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1098</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[38]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x109C</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[39]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A0</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[40]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A4</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[41]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10A8</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[42]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10AC</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[43]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B0</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[44]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B4</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[45]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10B8</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[46]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10BC</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[47]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C0</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[48]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C4</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[49]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C8</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[50]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10CC</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[51]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10D0</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[52]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10D4</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[53]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10D8</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[54]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10DC</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[55]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10E0</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[56]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10E4</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[57]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10E8</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[58]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10EC</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[59]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10F0</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[60]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10F4</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[61]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10F8</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[62]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10FC</addressOffset>
        <description>Backup register region</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Backup memory that contains application-specific data.  Memory is retained on vbackup supply.</description>
            <name>BREG</name>
          </field>
        </fields>
        <name>BREG[63]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40280000</baseAddress>
    <description>Datawire Controller</description>
    <interrupts></interrupts>
    <name>DW0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IP enable:
            '0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0x80000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel, user/privileged access control:
            '0': user mode.
            '1': privileged mode.</description>
            <name>P</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel, secure/non-secure access control:
            '0': secure.
            '1': non-secure.</description>
            <name>NS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel, non-bufferable/bufferable access control:
            '0': non-bufferable
            '1': bufferable.</description>
            <name>B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Active channel protection context.</description>
            <name>PC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Active channel index.</description>
            <name>CH_IDX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Active channel priority.</description>
            <name>PRIO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel preemptable.</description>
            <name>PREEMPTABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>State of the DW controller. 
            '0': Default/inactive state.
            '1': Loading descriptor.
            '2': Loading data element from source location.
            '3': Storing data element to destination location.
            '4': Update of active control information (e.g. source and destination addresses).
            '5': Wait for trigger de-activation.</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel present: 
            '0': No.
            '1': Yes.</description>
            <name>ACTIVE</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x80700000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Pending channels</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
            <name>CH_PENDING</name>
          </field>
        </fields>
        <name>PENDING</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>System interrupt control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Reflects the INTR.CH bit fields of all channels.</description>
            <name>CH</name>
          </field>
        </fields>
        <name>STATUS_INTR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Status of interrupts masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Reflects the INTR_MASKED.CH bit fields of all channels.</description>
            <name>CH</name>
          </field>
        </fields>
        <name>STATUS_INTR_MASKED</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Active descriptor control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_CTL of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_CTL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Active descriptor source</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_SRC of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>Active descriptor destination</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_DST of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_DST</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Active descriptor X loop control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_X_CTL of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_X_CTL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Active descriptor Y loop control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_Y_CTL of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_Y_CTL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Active descriptor next pointer</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1E</bitWidth>
            <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.</description>
            <name>ADDR</name>
          </field>
        </fields>
        <name>ACT_DESCR_NEXT_PTR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>Active source</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Current address of source location.</description>
            <name>SRC_ADDR</name>
          </field>
        </fields>
        <name>ACT_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x44</addressOffset>
        <description>Active destination</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Current address of destination location.</description>
            <name>DST_ADDR</name>
          </field>
        </fields>
        <name>ACT_DST</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40281000</baseAddress>
    <derivedFrom>DW0</derivedFrom>
    <description>Datawire Controller</description>
    <interrupts></interrupts>
    <name>DW1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IP enable:
            '0': Disabled. Disabling the IP activates the IP's Active logic reset: Active logic and non-retention MMIO registers are reset (retention MMIO registers are not affected).
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0x80000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel, user/privileged access control:
            '0': user mode.
            '1': privileged mode.</description>
            <name>P</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel, secure/non-secure access control:
            '0': secure.
            '1': non-secure.</description>
            <name>NS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel, non-bufferable/bufferable access control:
            '0': non-bufferable
            '1': bufferable.</description>
            <name>B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Active channel protection context.</description>
            <name>PC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Active channel index.</description>
            <name>CH_IDX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Active channel priority.</description>
            <name>PRIO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel preemptable.</description>
            <name>PREEMPTABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>State of the DW controller. 
            '0': Default/inactive state.
            '1': Loading descriptor.
            '2': Loading data element from source location.
            '3': Storing data element to destination location.
            '4': Update of active control information (e.g. source and destination addresses).
            '5': Wait for trigger de-activation.</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Active channel present: 
            '0': No.
            '1': Yes.</description>
            <name>ACTIVE</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x80700000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Pending channels</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Specifies pending DW channels; i.e. enabled channels whose trigger got activated. This field includes all channels that are in the pending state (not scheduled) or active state (scheduled and performing data transfer(s)).</description>
            <name>CH_PENDING</name>
          </field>
        </fields>
        <name>PENDING</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>System interrupt control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Reflects the INTR.CH bit fields of all channels.</description>
            <name>CH</name>
          </field>
        </fields>
        <name>STATUS_INTR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Status of interrupts masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Reflects the INTR_MASKED.CH bit fields of all channels.</description>
            <name>CH</name>
          </field>
        </fields>
        <name>STATUS_INTR_MASKED</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Active descriptor control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_CTL of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_CTL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Active descriptor source</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_SRC of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>Active descriptor destination</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_DST of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_DST</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>Active descriptor X loop control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_X_CTL of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_X_CTL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>Active descriptor Y loop control</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Copy of DESCR_Y_CTL of the currently active descriptor.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>ACT_DESCR_Y_CTL</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>Active descriptor next pointer</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1E</bitWidth>
            <description>Copy of DESCR_NEXT_PTR of the currently active descriptor.</description>
            <name>ADDR</name>
          </field>
        </fields>
        <name>ACT_DESCR_NEXT_PTR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>Active source</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Current address of source location.</description>
            <name>SRC_ADDR</name>
          </field>
        </fields>
        <name>ACT_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x44</addressOffset>
        <description>Active destination</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Current address of destination location.</description>
            <name>DST_ADDR</name>
          </field>
        </fields>
        <name>ACT_DST</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x80</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x402C0000</baseAddress>
    <description>EFUSE MXS40 registers</description>
    <interrupts></interrupts>
    <name>EFUSE</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IP enable:
            '0': Disabled. All non-retention registers (command and status registers) are reset to their default value when the IP is disabled. All retention registers retain their value when the IP is disabled.
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0x80000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bit data. This field specifies the bit value that is to be programmed into the eFUSE macro array. The address of the bit is specified by the BIT_ADDR, BYTE_ADDR, and MACRO_ADDR fields. This bit is a don't care for the MXS40 Macro.</description>
            <name>BIT_DATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit address. This field specifies a bit within a Byte.</description>
            <name>BIT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Byte address. This field specifies a Byte within a eFUSE macro (each macro has 32 B).</description>
            <name>BYTE_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Macro address. This field specifies an eFUSE macro.</description>
            <name>MACRO_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>FW sets this field to '1' to start a program operation. HW sets this field to '0' to indicate that the operation has completed.
            
            Note: it is good practice to verify the result of a program operation by reading back a programmed eFUSE memory location. Programming can only change an eFUSE memory bit from '0' to '1'; i.e. a programming operation is a 'one-off' operation for each eFUSE memory bit: once a bit is changed to '1', it can NEVER be changed back to '0' as a hardware fuse is blown.
            
            Programming a memory bit to '1' requires blowing a fuse and requires an eFUSE macro operation. Therefore, this programmiong operation takes time (as specified by the SEQ_PROGRAM_CTL reguisters). Programming amemory bit to '0' does not require an eFUSE macro operation (it is the default eFUSE macro state). Therefore, this programming operation is almost instantaneous.
            
            Note: during a program operation, a read operation can not be performed. An AHB-Lite read transfer to the eFUSE memory during a program operation results in an AHB-Lite bus error.</description>
            <name>START</name>
          </field>
        </fields>
        <name>CMD</name>
        <resetMask>0x800F1F71</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Sequencer Default value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <name>SEQ_DEFAULT</name>
        <resetMask>0x7F0000</resetMask>
        <resetValue>0x1D0000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Sequencer read control 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_READ_CTL_0</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x80560001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Sequencer read control 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_READ_CTL_1</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x540004</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Sequencer read control 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_READ_CTL_2</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x560001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Sequencer read control 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_READ_CTL_3</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x540003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Sequencer read control 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_READ_CTL_4</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x80150001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Sequencer read control 5</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_READ_CTL_5</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x310004</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>Sequencer program control 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_a</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_PROGRAM_CTL_0</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x200001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64</addressOffset>
        <description>Sequencer program control 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_a</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_PROGRAM_CTL_1</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x220020</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>Sequencer program control 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_a</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_PROGRAM_CTL_2</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x200001</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>Sequencer program control 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_a</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_PROGRAM_CTL_3</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x310005</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Sequencer program control 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_a</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_PROGRAM_CTL_4</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x80350006</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>Sequencer program control 5</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Number of IP clock cycles (minus 1). This field is in the range of [0, 1023], allowing for a time of [1, 1024] IP clock cycles.</description>
            <name>CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_a</description>
            <name>STROBE_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSEcontrol signal strobe_b</description>
            <name>STROBE_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_c</description>
            <name>STROBE_C</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_d</description>
            <name>STROBE_D</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_e</description>
            <name>STROBE_E</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_f</description>
            <name>STROBE_F</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies value of eFUSE control signal strobe_g</description>
            <name>STROBE_G</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1 indicates that the Read cycle ends when the current cycle count reaches 0.</description>
            <name>DONE</name>
          </field>
        </fields>
        <name>SEQ_PROGRAM_CTL_5</name>
        <resetMask>0x807F03FF</resetMask>
        <resetValue>0x803D0019</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x402D0000</baseAddress>
    <description>Energy Profiler IP</description>
    <interrupts></interrupts>
    <name>PROFILE</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Profile control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies the profiling time window mode:
            '0': Start / stop mode. The profiling time window is started when a rising edge of the start trigger signal occurs and stopped when a rising edge of the stop trigger signal occurs.
            In case both rising edges (of start and stop trigger signals) occur in the same cycle, the profiling time window is stopped.
            '1': Enable mode. The profiling time window is active as long as the start 'trigger' signal is active. The stop trigger signal has no effect.</description>
            <name>WIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the profiling block:
            '0': Disabled.
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0x80000001</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Profile status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates if the profiling time window is active.
            '0': Not active.
            '1': Active.</description>
            <name>WIN_ACTIVE</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Profile command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software start trigger for the profiling time window. When written with '1', the profiling time window is started.
            Can only be used in start / stop mode (PROFILE_WIN_MODE=0).
            Has no effect in enable mode (PROFILE_WIN_MODE=1).</description>
            <name>START_TR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software stop trigger for the profiling time window. When written with '1', the profiling time window is stopped.
            Can only be used in start / stop mode (PROFILE_WIN_MODE=0).
            Has no effect in enable mode (PROFILE_WIN_MODE=1).</description>
            <name>STOP_TR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter clear. When written with '1', all profiling counter registers are cleared to 0x00.</description>
            <name>CLR_ALL_CNT</name>
          </field>
        </fields>
        <name>CMD</name>
        <resetMask>0x103</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C0</addressOffset>
        <description>Profile interrupt</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This interrupt cause field is activated (HW sets the field to '1') when an profiling counter overflow (from 0xFFFFFFFF to 0x00000000) is captured. There is one bit per profling counter.
            
            SW writes a '1' to a bit of this field to clear this bit to '0' (writing 0xFFFFFFFF clears all interrupt causes to '0').</description>
            <name>CNT_OVFLW</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C4</addressOffset>
        <description>Profile interrupt set</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>SW writes a '1' to a bit of this field to set the corresponding bit in the INTR register.</description>
            <name>CNT_OVFLW</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C8</addressOffset>
        <description>Profile interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Mask bit for corresponding field in the INTR register.</description>
            <name>CNT_OVFLW</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x7CC</addressOffset>
        <description>Profile interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
            <name>CNT_OVFLW</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x4000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40310000</baseAddress>
    <description>High Speed IO Matrix (HSIOM)</description>
    <interrupts></interrupts>
    <name>HSIOM</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2000</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[0]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2004</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[1]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2008</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[2]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[3]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2010</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[4]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2014</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[5]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2018</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[6]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x201C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[7]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2020</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[8]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2024</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[9]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2028</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[10]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x202C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[11]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2030</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[12]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2034</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[13]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2038</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[14]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x203C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[15]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2040</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[16]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2044</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[17]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2048</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[18]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[19]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2050</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[20]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2054</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[21]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2058</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[22]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x205C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[23]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2060</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[24]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2064</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[25]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2068</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[26]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x206C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[27]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2070</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[28]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2074</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[29]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2078</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[30]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x207C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[31]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2080</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[32]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2084</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[33]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2088</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[34]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[35]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2090</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[36]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2094</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[37]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2098</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[38]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x209C</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[39]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20A0</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[40]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20A4</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[41]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20A8</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[42]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20AC</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[43]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20B0</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[44]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20B4</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[45]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20B8</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[46]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20BC</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[47]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C0</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[48]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C4</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[49]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C8</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[50]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20CC</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[51]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20D0</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[52]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20D4</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[53]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20D8</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[54]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20DC</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[55]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20E0</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[56]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20E4</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[57]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20E8</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[58]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20EC</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[59]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20F0</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[60]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20F4</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[61]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20F8</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[62]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20FC</addressOffset>
        <description>AMUX splitter cell control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSA switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSA vssa/ground switch:
            '0': switch open.
            '1': switch closed.</description>
            <name>SWITCH_AA_S0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Left AMUXBUSB switch.</description>
            <name>SWITCH_BB_SL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for Right AMUXBUSB switch.</description>
            <name>SWITCH_BB_SR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
            <name>SWITCH_BB_S0</name>
          </field>
        </fields>
        <name>AMUX_SPLIT_CTL[63]</name>
        <resetMask>0x77</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40320000</baseAddress>
    <description>GPIO port control/configuration</description>
    <interrupts></interrupts>
    <name>GPIO</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4000</addressOffset>
        <description>Interrupt port cause register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to determine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PRT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
            '0': Port has no pending interrupt
            '1': Port has pending interrupt</description>
            <name>PORT_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4004</addressOffset>
        <description>Interrupt port cause register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to deternine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
            '0': Port has no pending interrupt
            '1': Port has pending interrupt</description>
            <name>PORT_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4008</addressOffset>
        <description>Interrupt port cause register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to deternine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
            '0': Port has no pending interrupt
            '1': Port has pending interrupt</description>
            <name>PORT_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x400C</addressOffset>
        <description>Interrupt port cause register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'gpio_interrupts[i]' for IO port i). The register is used when the system uses a combined interrupt line 'gpio_interrupt'. The software ISR reads the register to deternine which IO port(s) is responsible for the combined interrupt line. Once, the IO port(s) is determined, the IO port's GPIO_PORT_INTR register is read to determine the IO pin(s) in the IO port that caused the interrupt.
            '0': Port has no pending interrupt
            '1': Port has pending interrupt</description>
            <name>PORT_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4010</addressOffset>
        <description>Extern power supply detection register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Indicates presence or absence of VDDIO supplies (i.e. other than VDDD, VDDA) on the device (supplies are numbered 0..n-1).  Note that VDDIO supplies have basic (crude) supply detectors only.  If separate, robust, brown-out detection is desired on IO supplies, on-chip or off-chip analog resources need to provide it.  For these bits to work reliable, the supply must be within valid spec range (per datasheet) or held at ground.  Any in-between voltage has an undefined result.
            '0': Supply is not present
            '1': Supply is present
            
            When multiple VDDIO supplies are present, they will be assigned in alphanumeric ascending order to these bits during implementation.
            For example 'vddusb, vddio_0, vddio_a, vbackup, vddio_r, vddio_1' are present then they will be assigned to these bits as below:
            0: vbackup, 
            1: vddio_0, 
            2: vddio_1,
            3: vddio_a,
            4: vddio_r,
            5: vddusb'</description>
            <name>VDDIO_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
            <name>VDDA_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit indicates presence of the VDDD supply.  This bit will always read-back 1.  The VDDD supply has robust brown-out protection monitoring and it is not possible to read back this register without a valid supply. (This bit is used in certain test-modes to observe the brown-out detector status.)</description>
            <name>VDDD_ACTIVE</name>
          </field>
        </fields>
        <name>VDD_ACTIVE</name>
        <resetMask>0xC000FFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4014</addressOffset>
        <description>Supply detection interrupt register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Supply state change detected.
            '0': No change to supply detected
            '1': Change to supply detected</description>
            <name>VDDIO_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
            <name>VDDA_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The VDDD supply is always present during operation so a supply transition can not occur. This bit will always read back '1'.</description>
            <name>VDDD_ACTIVE</name>
          </field>
        </fields>
        <name>VDD_INTR</name>
        <resetMask>0xC000FFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4018</addressOffset>
        <description>Supply detection interrupt mask register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Masks supply interrupt on VDDIO.
            '0': VDDIO interrupt forwarding disabled
            '1': VDDIO interrupt forwarding enabled</description>
            <name>VDDIO_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
            <name>VDDA_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
            <name>VDDD_ACTIVE</name>
          </field>
        </fields>
        <name>VDD_INTR_MASK</name>
        <resetMask>0xC000FFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x401C</addressOffset>
        <description>Supply detection interrupt masked register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Supply transistion detected AND masked
            '0': Interrupt was not forwarded to CPU
            '1': Interrupt occurred and was forwarded to CPU</description>
            <name>VDDIO_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
            <name>VDDA_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
            <name>VDDD_ACTIVE</name>
          </field>
        </fields>
        <name>VDD_INTR_MASKED</name>
        <resetMask>0xC000FFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4020</addressOffset>
        <description>Supply detection interrupt set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Sets supply interrupt.
            '0': Interrupt state not affected
            '1': Interrupt set</description>
            <name>VDDIO_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the analog supply VDDA.</description>
            <name>VDDA_ACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as VDDIO_ACTIVE for the digital supply VDDD.</description>
            <name>VDDD_ACTIVE</name>
          </field>
        </fields>
        <name>VDD_INTR_SET</name>
        <resetMask>0xC000FFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40330000</baseAddress>
    <description>Programmable IO configuration</description>
    <interrupts></interrupts>
    <name>SMARTIO</name>
    <registers></registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40350000</baseAddress>
    <description>Low Power Comparators</description>
    <interrupts></interrupts>
    <name>LPCOMP</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>LPCOMP Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the local reference generator circuit to generate the local Vref and ibias. This bit must be set for DeepSleep or Hibernate operation.</description>
            <name>LPREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: IP disabled (put analog in power down, open all switches, all clocks off, leakage power only)
            - 1: IP enabled</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CONFIG</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>LPCOMP Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Current output value of the comparator 0.</description>
            <name>OUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Current output value of the comparator 1.</description>
            <name>OUT1</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x10001</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>LPCOMP Interrupt request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
            <name>COMP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
            <name>COMP1</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>LPCOMP Interrupt set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>COMP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>COMP1</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>LPCOMP Interrupt request mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>COMP0_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>COMP1_MASK</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>LPCOMP Interrupt request masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>COMP0_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>COMP1_MASKED</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Comparator 0 control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Operating mode for the comparator</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Off</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                <name>ULP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                <name>LP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                <name>NORMAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Add 30mV hysteresis to the comparator
            0= Disable Hysteresis
            1= Enable Hysteresis</description>
            <name>HYST0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sets which edge will trigger an IRQ</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled, no interrupts will be detected</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both rising and falling edges</description>
                <name>BOTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTTYPE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Asynchronous: bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async).
            Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
            <name>DSI_BYPASS0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous comparator DSI (trigger) output  : 0=pulse, 1=level</description>
            <name>DSI_LEVEL0</name>
          </field>
        </fields>
        <name>CMP0_CTRL</name>
        <resetMask>0xCE3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Comparator 0 switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 positive terminal isolation switch to GPIO</description>
            <name>CMP0_IP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 positive terminal  switch to amuxbusA</description>
            <name>CMP0_AP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 positive terminal  switch to amuxbusB</description>
            <name>CMP0_BP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 negative terminal isolation switch to GPIO</description>
            <name>CMP0_IN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 negative terminal  switch to amuxbusA</description>
            <name>CMP0_AN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 negative terminal  switch to amuxbusB</description>
            <name>CMP0_BN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
            <name>CMP0_VN0</name>
          </field>
        </fields>
        <name>CMP0_SW</name>
        <resetMask>0xF7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Comparator 0 switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_IP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_AP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_BP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_IN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_AN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_BN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP0_SW</description>
            <name>CMP0_VN0</name>
          </field>
        </fields>
        <name>CMP0_SW_CLEAR</name>
        <resetMask>0xF7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Comparator 1 control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Operating mode for the comparator</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Off</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ultra lowpower operating mode (uses less power, &lt; 300nA), must be used for DeepSleep or Hibernate. Only in this mode a local iref will be used.</description>
                <name>ULP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low Power operating mode (uses more power, &lt;10uA @@@ TBD). In this mode the iref from SRSS will be used.</description>
                <name>LP</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal, full speed power operating mode (uses &lt;150uA). In this mode the iref from SRSS will be used.</description>
                <name>NORMAL</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Add 30mV hysteresis to the comparator
            0= Disable Hysteresis
            1= Enable Hysteresis</description>
            <name>HYST1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sets which edge will trigger an IRQ</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled, no interrupts will be detected</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both rising and falling edges</description>
                <name>BOTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTTYPE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Asynchronous: bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async).
            Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
            <name>DSI_BYPASS1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous comparator DSI (trigger) output  : 0=pulse, 1=level</description>
            <name>DSI_LEVEL1</name>
          </field>
        </fields>
        <name>CMP1_CTRL</name>
        <resetMask>0xCE3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>Comparator 1 switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 positive terminal isolation switch to GPIO</description>
            <name>CMP1_IP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 positive terminal  switch to amuxbusA</description>
            <name>CMP1_AP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 positive terminal  switch to amuxbusB</description>
            <name>CMP1_BP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 negative terminal isolation switch to GPIO</description>
            <name>CMP1_IN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 negative terminal  switch to amuxbusA</description>
            <name>CMP1_AN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 negative terminal  switch to amuxbusB</description>
            <name>CMP1_BN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 negative terminal  switch to local Vref  (LPREF_EN must be set)</description>
            <name>CMP1_VN1</name>
          </field>
        </fields>
        <name>CMP1_SW</name>
        <resetMask>0xF7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>Comparator 1 switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_IP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_AP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_BP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_IN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_AN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_BN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CMP1_SW</description>
            <name>CMP1_VN1</name>
          </field>
        </fields>
        <name>CMP1_SW_CLEAR</name>
        <resetMask>0xF7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40360000</baseAddress>
    <description>Capsense Controller</description>
    <interrupts></interrupts>
    <name>CSD0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Configuration and Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IREF_SRSS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IREF_PASS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IREF_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Enables the digital filtering on the CSD comparator</description>
            <name>FILTER_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Configures the delay between shield clock and sensor clock</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Delay line is off; sensor clock = shield clock</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>shield clock is delayed by 5ns delay  w.r.t sensor clock</description>
                <name>D5NS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>shield clock is delayed by 10ns delay  w.r.t sensor clock</description>
                <name>D10NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>shield clock is delayed by 20ns delay  w.r.t sensor clock</description>
                <name>D20NS</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SHIELD_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the sensor and shield clocks, CSD modulator output and turns on the IDAC compensation current as selected by CSD_IDAC.</description>
            <name>SENSE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Half Wave mode</description>
                <name>HALFWAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Full Wave mode</description>
                <name>FULLWAVE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FULL_WAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Self-cap mode</description>
                <name>SELFCAP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mutual-cap mode</description>
                <name>MUTUALCAP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MUTUAL_CAP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>ONE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>TWO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CSX_DUAL_CNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD_RESULT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>ADC_RESULT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DSI_COUNT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI_SAMPLE_EN = 1 -&gt; COUNTER will count the samples generated by DSI
            DSI_SAMPLE_EN = 0 -&gt; COUNTER will count the samples generated by CSD modulator</description>
            <name>DSI_SAMPLE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SAMPLE_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI_SENSE_EN = 1-&gt; sensor clock is driven directly by DSI
            DSI_SENSE_EN = 0-&gt; sensor clock  is driven by PRS/divide-by-2/DIRECT_CLOCK</description>
            <name>DSI_SENSE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>LP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <name>CONFIG</name>
        <resetMask>0xCF0E1DF1</resetMask>
        <resetValue>0x4000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Spare MMIO</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Spare MMIO</description>
            <name>SPARE</name>
          </field>
        </fields>
        <name>SPARE</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only for Debug/test purpose this internal signal (sensor clock) status can be read by CPU</description>
            <name>CSD_SENSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only for Debug/test purpose the output status of CSD comparator can be read by CPU</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>C_LT_VREF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>C_GT_VREF</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HSCMP_OUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only for Debug/test purpose the output status of CSD modulator can be read by  CPU</description>
            <name>CSDCMP_OUT</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0xE</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x84</addressOffset>
        <description>Current Sequencer status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>CSD sequencer state</description>
            <name>SEQ_STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>ADC sequencer state (only relevant after SEQ_STATE has reached SAMPLE_NORM and ADC sequencer has started)</description>
            <name>ADC_STATE</name>
          </field>
        </fields>
        <name>STAT_SEQ</name>
        <resetMask>0x70007</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x88</addressOffset>
        <description>Current status counts</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Current number of conversions remaining when in Sample_* states (note that in AutoZero* states the same down counter is reused to count the cycles)</description>
            <name>NUM_CONV</name>
          </field>
        </fields>
        <name>STAT_CNTS</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8C</addressOffset>
        <description>Current count of the HSCMP counter</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Current value of HSCMP counter</description>
            <name>CNT</name>
          </field>
        </fields>
        <name>STAT_HCNT</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD0</addressOffset>
        <description>Result CSD/CSX accumulation counter value 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Accumulated counter value for this result. In case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt) this counter counts when csd_sense is high.</description>
            <name>VALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Number of 'bad' conversion for which the CSD comparator did not trigger within the normal time window, either because Vref was not crossed at all, or if the Vref was already crossed before the window started. This counter is reset when the sequencer is started and will saturate at 255 when more than 255 conversions are bad.</description>
            <name>BAD_CONVS</name>
          </field>
        </fields>
        <name>RESULT_VAL1</name>
        <resetMask>0xFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD4</addressOffset>
        <description>Result CSX accumulation counter value 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Only used in case of Mutual cap with two counters (CSX = config.mutual_cap &amp; config.csx_dual_cnt), this counter counts when csd_sense is low.</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>RESULT_VAL2</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE0</addressOffset>
        <description>ADC measurement</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Count to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
            <name>VIN_CNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity used for IDACB for this last ADC result, 0= source, 1= sink</description>
            <name>HSCMP_POL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This flag is set when the ADC counter overflows. This is an indication to the firmware that the IDACB current level is too low.</description>
            <name>ADC_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This flag is set when the ADC sequencer was aborted before tripping HSCMP.</description>
            <name>ADC_ABORT</name>
          </field>
        </fields>
        <name>ADC_RES</name>
        <resetMask>0xC001FFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>CSD Interrupt Request Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A normal sample is complete</description>
            <name>SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Coarse initialization complete or Sample initialization complete (the latter is typically ignored)</description>
            <name>INIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC Result ready</description>
            <name>ADC_RES</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x106</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>CSD Interrupt set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>INIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>ADC_RES</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x106</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>CSD Interrupt mask register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>INIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>ADC_RES</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x106</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFC</addressOffset>
        <description>CSD Interrupt masked register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>INIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>ADC_RES</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x106</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>High Speed Comparator configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>High Speed Comparator enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable comparator, output is zero</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                <name>ON</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HSCMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert the HSCMP output before it is used to control switches and the CSD sequencer. This bit does not affect the ADC sequencer or the STATUS.HSCMP_OUT</description>
            <name>HSCMP_INVERT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
            <name>AZ_EN</name>
          </field>
        </fields>
        <name>HSCMP</name>
        <resetMask>0x80000011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x184</addressOffset>
        <description>Reference Generator configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Amux buffer power level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable buffer</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>On, normal or low power level depending on CONFIG.LP_MODE.</description>
                <name>NORM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>On, high or low power level depending on CONFIG.LP_MODE.</description>
                <name>HI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_MODE</name>
          </field>
        </fields>
        <name>AMBUF</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x188</addressOffset>
        <description>Reference Generator configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reference Generator Enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable Reference Generator</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                <name>ON</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>REFGEN_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bypass selected input reference unbuffered to Vrefhi</description>
            <name>BYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Close Vdda switch to top of resistor string (or Vrefhi?)</description>
            <name>VDDA_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Resistor string enable; 0= open switch on top of the resistor string (Vreflo=Vssa)</description>
            <name>RES_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Select resistor string tap for feedback, 0= minimum vout, 31= maximum vout = vrefhi -&gt; gain=1  (only works if the resistor string is enabled; RES_EN=1)</description>
            <name>GAIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Select resistor string tap for Vreflo/Vreflo_int, 0= minimum vout, 31= maximum vout = vrefhi (only works if the resistor string is enabled; RES_EN=1)</description>
            <name>VREFLO_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ouput the resistor string tap either to Vreflo (0) or Vreflo_int (1).</description>
            <name>VREFLO_INT</name>
          </field>
        </fields>
        <name>REFGEN</name>
        <resetMask>0x9F1F71</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18C</addressOffset>
        <description>CSD Comparator configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CSD Comparator Enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable comparator, output is zero</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>On, regular operation. Note that CONFIG.LP_MODE determines the power mode level</description>
                <name>ON</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CSDCMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select which IDAC polarity to use to detect CSDCMP triggering</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Use idaca_pol (firmware setting with CSX and optionally DSI mixed in) to determine the direction, this is the most common use-case, used for normal CSD and normal CSX</description>
                <name>IDACA_POL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Use idacb_pol (firmware setting with optional DSI mixed in) to determine the direction, this is only used for normal CSD if IDACB is used i.s.o. IDACA (not common)</description>
                <name>IDACB_POL</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Use the expression (csd_sense ? idaca_pol : idacb_pol)  to determine the direction, this is only useful for the CSX with DUAL_IDAC use-case</description>
                <name>DUAL_POL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POLARITY_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select in what phase(s) the comparator is active, typically set to match the BAL_MODE of the used IDAC. Note, this also determines when a bad conversion is detected, namely at the beginning and end of the comparator active phase (also taking into account FILTER_DELAY and non-overlap).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Comparator is active from start of Phi2 and kept active into Phi1. Intended usage: legacy CSD for balancing over a full csd_sense period (non-overlap should be turned off)</description>
                <name>FULL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Comparator is active during Phi1 only. Currently no known use-case.</description>
                <name>PHI1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Comparator is active during Phi2 only. Intended usage: CSD Low EMI.</description>
                <name>PHI2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Comparator is activated at the start of both Phi1 and Phi2 (non-overlap should be enabled). Intended usage: CSX, or Full-Wave.</description>
                <name>PHI1_2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CMP_PHASE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select which signal to output on dsi_sample_out.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CSD mode: output the filtered sample signal on dsi_sample_out</description>
                <name>CSD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>General Purpose mode: output the unfiltered sample unfiltered comparator output, either asynchronous or flopped.</description>
                <name>GP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CMP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls whether the output directly from the comparator (csdcmp_out) or the flopped version (csdcmp_out_ff) is used. For CSD operation, the selected signal controls the IDAC(s), in GP mode the signal goes out on dsi_sample_out.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Use feedback from sampling flip-flop (used in most modes).</description>
                <name>FLOP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Use feedback from comparator directly (used in single Cmod mutual cap sensing only)</description>
                <name>COMP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FEEDBACK_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Auto-Zero enable, allow the Sequencer to Auto-Zero this component</description>
            <name>AZ_EN</name>
          </field>
        </fields>
        <name>CSDCMP</name>
        <resetMask>0xB0000331</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1F0</addressOffset>
        <description>Switch Resistance configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select resistance or low EMI (slow ramp) for the HCAV switch</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Medium</description>
                <name>MED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High</description>
                <name>HIGH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low EMI (slow ramp: 3 switches closed by fixed delay line)</description>
                <name>LOWEMI</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RES_HCAV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select resistance or low EMI for the corresponding switch</description>
            <name>RES_HCAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select resistance or low EMI for the corresponding switch</description>
            <name>RES_HCBV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select resistance or low EMI for the corresponding switch</description>
            <name>RES_HCBG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select resistance for the corresponding  switch</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Medium</description>
                <name>MED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High</description>
                <name>HIGH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>RSVD</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RES_F1PM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select resistance for the corresponding  switch</description>
            <name>RES_F2PT</name>
          </field>
        </fields>
        <name>SW_RES</name>
        <resetMask>0xF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Sense clock period</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>The length-1 of the Sense modulation 'clock' period in clk_csd cycles. For regular CSD one sense clock cycle = one conversion (=phi1+phi2) .
            Note this is the base divider, clock dithering may change the actual period length.
            Note that SENSE_DIV must be at least 1 and additionally also allow for one clk_hf of non overlap (if OVERLAP_HI1/2 is set) on both phases, i.e. if clk_csd=clk_hf then SENSE_DIV must be &gt;=3.
            In addition the FILTER_DELAY needs to be added to the minimum allowed SENSE_DIV value.</description>
            <name>SENSE_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the length of the LFSR which determines the LFSR repeat period. LFSR_BITS LSB of the LFSR are used  for the clock dithering variation on the base period (was PRS in CSDv1). Whenever the LFSR is used (non zero value in this field) the LFSR_CLEAR bit should also be set.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Don't use clock dithering (=spreadspectrum) (LFSR output value is zero)</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6-bit LFSR (G(x)=X^6  +X^4+X^3+    X+1, period= 63)</description>
                <name>6B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7-bit LFSR (G(x)=X^7  +X^4+X^3+X^2+1, period= 127)</description>
                <name>7B</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9-bit LFSR (G(x)=X^9  +X^4+X^3+    X+1, period= 511)</description>
                <name>9B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10-bit LFSR (G(x)=X^10+X^4+X^3+    X+1, period= 1023)</description>
                <name>10B</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit LFSR (G(x)=X^8+X^4+X^3+X^2+1, period= 255)</description>
                <name>8B</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>12-bit LFSR (G(x)=X^12+X^7+X^4+X^3+1, period= 4095)</description>
                <name>12B</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LFSR_SIZE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This dithering is disabled when SEL_LSFR_MSB is set.
            The clock divider to be used = (SENSE_DIV+1) + (SEL_LSFR_MSB ? 0 : (LFSR_OUT&lt;&lt;LFSR_SCALE)).
            Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined.</description>
            <name>LFSR_SCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set, forces the LFSR to it's initial state (all ones).  This bit is automatically cleared by hardware after the LFSR is cleared, which is at the next clk_csd positive edge. This bit should be set whenever this register is written and the LFSR is used.
            Note that the LFSR will also get reset to all ones during the AutoZero_1/2 states.</description>
            <name>LFSR_CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Use the MSB of configured LSFR size as csd_sense signal. Intended to be used only with bit 8 or 12-bit LFSR size for CSDv1 backward compatibility (PRS). When this bit is set then clock divider dithering is disabled and SENSE_WIDTH is disabled.</description>
            <name>SEL_LFSR_MSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the number of LSB bits to use from the LSFR to provide the clock dithering variation on the base period.
            Caveat make sure that SENSE_DIV &gt; the maximum absolute range (e.g. for 4B  SENSE_DIV &gt; 8), otherwise results are undefined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>use 2 bits: range = [-2,1]</description>
                <name>2B</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>use 3 bits: range = [-4,3]</description>
                <name>3B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>use 4 bits: range = [-8,7]</description>
                <name>4B</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>use 5 bits: range = [-16,15] (default)</description>
                <name>5B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LFSR_BITS</name>
          </field>
        </fields>
        <name>SENSE_PERIOD</name>
        <resetMask>0xFF70FFF</resetMask>
        <resetValue>0xC000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Sense clock duty cycle</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Defines the length of the first phase of the sense clock in clk_csd cycles. 
            A value of 0 disables this feature and the duty cycle of csd_sense will be 50 percent, which is equal to SENSE_WIDTH = (SENSE_DIV+1)/2, or when clock dithering is used that becomes [(SENSE_DIV+1) + (LFSR_OUT &lt;&lt; LSFR_SCALE)]/2.  At all times it must be assured that the phases are at least 2 clk_csd cycles (1 for non overlap, if used), if this rule is violated the result is undefined.
            Note that this feature is not available when SEL_LFSR_MSB (PRS) is selected.</description>
            <name>SENSE_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the sense clock
            0 = start with low phase (typical for regular negative transfer CSD)
            1 = start with high phase</description>
            <name>SENSE_POL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>NonOverlap or not for Phi1 (csd_sense=0).
            0 = Non-overlap for Phi1, the Phi1 signal is  csd_sense inverted except that the signal goes low 1 clk_sample before csd_sense goes high. Intended usage: new low EMI CSD/CSX with static GPIO.
            1 = 'Overlap' (= not non-overlap) for Phi1, the Phi1 signal is  csd_sense inverted. Intended usage: legacy CSD with GPIO switching, the GPIO internal circuit ensures that the switches are non-overlapping.</description>
            <name>OVERLAP_PHI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Same as OVERLAP_PHI1 but for Phi2 (csd_sense=1).</description>
            <name>OVERLAP_PHI2</name>
          </field>
        </fields>
        <name>SENSE_DUTY</name>
        <resetMask>0xD0FFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x280</addressOffset>
        <description>HSCMP Pos input switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set HMPM switch
            0: static open
            1: static closed</description>
            <name>SW_HMPM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMPS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMCA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMCB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HMRH</name>
          </field>
        </fields>
        <name>SW_HS_P_SEL</name>
        <resetMask>0x11111111</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x284</addressOffset>
        <description>HSCMP Neg input switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HCCC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HCCD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_HCRH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_HCRL</name>
          </field>
        </fields>
        <name>SW_HS_N_SEL</name>
        <resetMask>0x77110000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x288</addressOffset>
        <description>Shielding switches Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>SW_HCAV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_HCAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>SW_HCBV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch, using csd_shield as base</description>
            <name>SW_HCBG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_HCCV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch
            If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
            <name>SW_HCCG</name>
          </field>
        </fields>
        <name>SW_SHIELD_SEL</name>
        <resetMask>0x117777</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x290</addressOffset>
        <description>Amuxbuffer switches Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IRBY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IRLB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_ICA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_ICB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IRLI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IRH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IRL</name>
          </field>
        </fields>
        <name>SW_AMUXBUF_SEL</name>
        <resetMask>0x11171110</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x294</addressOffset>
        <description>AMUXBUS bypass switches Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_BYA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_BYB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch
            If the ADC is enabled then this switch is directly controlled by the ADC sequencer.</description>
            <name>SW_CBCC</name>
          </field>
        </fields>
        <name>SW_BYP_SEL</name>
        <resetMask>0x111000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2A0</addressOffset>
        <description>CSDCMP Pos Switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_SFPM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_SFPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_SFPS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SFMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SFMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SFCA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SFCB</name>
          </field>
        </fields>
        <name>SW_CMP_P_SEL</name>
        <resetMask>0x1111777</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2A4</addressOffset>
        <description>CSDCMP Neg Switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_SCRH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_SCRL</name>
          </field>
        </fields>
        <name>SW_CMP_N_SEL</name>
        <resetMask>0x77000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2A8</addressOffset>
        <description>Reference Generator Switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IAIB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_IBCB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SGMB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SGRP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SGRE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_SGR</name>
          </field>
        </fields>
        <name>SW_REFGEN_SEL</name>
        <resetMask>0x11110011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2B0</addressOffset>
        <description>Full Wave Cmod Switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_F1PM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_F1MA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_F1CA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_C1CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_C1CD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_C1F1</name>
          </field>
        </fields>
        <name>SW_FW_MOD_SEL</name>
        <resetMask>0x11170701</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2B4</addressOffset>
        <description>Full Wave Csh_tank Switch Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_F2PT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_F2MA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_F2CA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select waveform for corresponding switch</description>
            <name>SW_F2CB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_C2CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_C2CD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set corresponding switch</description>
            <name>SW_C2F2</name>
          </field>
        </fields>
        <name>SW_FW_TANK_SEL</name>
        <resetMask>0x11177710</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C0</addressOffset>
        <description>DSI output switch control Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for dsi_csh_tank output signal
            0: static open
            1: static closed
            2: phi1
            3: phi2
            4: phi1 &amp; HSCMP
            5: phi2 &amp; HSCMP
            6: HSCMP                       // ignores phi1/2
            7: !sense                        // = phi1 but ignores OVERLAP_PHI1
            
            8: phi1_delay              // phi1 delayed with shield delay
            9: phi2_delay              // phi2 delayed with shield delay
            
            10: !phi1
            11: !phi2
            12: !(phi1 &amp; HSCMP)
            13: !(phi2 &amp; HSCMP)
            14: !HSCMP                   // ignores phi1/2
            15: sense                       // = phi2 but ignores OVERLAP_PHI2</description>
            <name>DSI_CSH_TANK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for dsi_cmod output signal</description>
            <name>DSI_CMOD</name>
          </field>
        </fields>
        <name>SW_DSI_SEL</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2D0</addressOffset>
        <description>IO output control Waveform selection</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for csd_tx_out output signal</description>
            <name>CSD_TX_OUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for csd_tx_out_en output signal</description>
            <name>CSD_TX_OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for csd_tx_amuxb_en output signal</description>
            <name>CSD_TX_AMUXB_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for csd_tx_n_out output signal</description>
            <name>CSD_TX_N_OUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for csd_tx_n_out_en output signal</description>
            <name>CSD_TX_N_OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select waveform for csd_tx_n_amuxa_en output signal</description>
            <name>CSD_TX_N_AMUXA_EN</name>
          </field>
        </fields>
        <name>IO_SEL</name>
        <resetMask>0xFFFF0FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Sequencer Timing</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Define Auto-Zero time in csd_sense cycles -1.</description>
            <name>AZ_TIME</name>
          </field>
        </fields>
        <name>SEQ_TIME</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Sequencer Initial conversion and sample counts</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Number of conversion per Initialization sample, if set to 0 the Sample_init state will be skipped.</description>
            <name>CONV_CNT</name>
          </field>
        </fields>
        <name>SEQ_INIT_CNT</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>Sequencer Normal conversion and sample counts</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Number of conversion per sample, if set to 0 the Sample_norm state will be skipped.
            Sample window size = SEQ_NORM_CNT.CONV_CNT * (SENSE_PERIOD.SENSE_DIV+1).
            Note for CSDv1 Sample window size = PERIOD</description>
            <name>CONV_CNT</name>
          </field>
        </fields>
        <name>SEQ_NORM_CNT</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>ADC Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>ADC timing -1 in csd_sense clock cycles (actual time is ADC_TIME+1 cycles), either used to discharge Cref1&amp;2, or as the aperture to capture the input voltage on Cref1&amp;2</description>
            <name>ADC_TIME</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Enable ADC measurement. When enabled the ADC sequencer will be started when the main sequencer goes to the SAMPLE_NORM state</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No ADC measurement</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Count time A to bring Cref1 + Cref2 up from Vssa to Vrefhi with IDACB</description>
                <name>VREF_CNT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Count time B to bring Cref1 + Cref2 back up to Vrefhi with IDACB (after bringing them down for time A/2 cycles with IDACB sinking)</description>
                <name>VREF_BY2_CNT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Determine HSCMP polarity and count time C to source/sink Cref1 + Cref2 from Vin to Vrefhi.</description>
                <name>VIN_CNT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADC_MODE</name>
          </field>
        </fields>
        <name>ADC_CTL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x340</addressOffset>
        <description>Sequencer start</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start the CSD sequencer. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when a sample has been accumulated, when the high speed comparator trips or if the sequencer is aborted. When the ADC is enabled the ADC sequencer will start when the CSD sequencer reaches the Sample_norm state (only with the regular CSD scan mode).</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>0 = regular CSD scan + optional ADC 
            1 = coarse initialization, the Sequencer will go to the INIT_COARSE state.</description>
            <name>SEQ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When a 1 is written the CSD and ADC sequencers will be aborted (if they are running) and the START bit will be cleared. This bit always read as 0.</description>
            <name>ABORT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is set a positive edge on dsi_start will start the CSD sequencer and if enabled also the ADC sequencer.</description>
            <name>DSI_START_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set the AutoZero_0 state will be skipped</description>
            <name>AZ0_SKIP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set the AutoZero_1 state will be skipped</description>
            <name>AZ1_SKIP</name>
          </field>
        </fields>
        <name>SEQ_START</name>
        <resetMask>0x31B</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>IDACA Configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>N/A</description>
            <name>VAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>STATIC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>DYNAMIC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POL_DYN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal: sensor switching between Vssio and Cmod.   For non-CSD application, IDAC1 will source current.</description>
                <name>VSSA_SRC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted: sensor switch between Vddio and Cmod.  For non-CSD application, IDAC1 will sink current.</description>
                <name>VDDA_SNK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SENSE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SENSE_INV</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>FULL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>PHI1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>PHI2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>PHI1_2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BAL_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP_STATIC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD_STATIC</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LEG1_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP_STATIC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD_STATIC</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LEG2_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>DSI_CTRL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IDAC_LO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IDAC_MED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IDAC_HI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>LEG1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>LEG2_EN</name>
          </field>
        </fields>
        <name>IDACA</name>
        <resetMask>0x3EF0FFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>IDACB Configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>N/A</description>
            <name>VAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>STATIC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>DYNAMIC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POL_DYN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal: sensor switching between Vssio and Cmod.   For non-CSD application, IDAC1 will source current.</description>
                <name>VSSA_SRC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inverted: sensor switch between Vddio and Cmod.  For non-CSD application, IDAC1 will sink current.</description>
                <name>VDDA_SNK</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SENSE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SENSE_INV</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>FULL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>PHI1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>PHI2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>PHI1_2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BAL_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP_STATIC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD_STATIC</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LEG1_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP_STATIC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>GP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD_STATIC</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>CSD</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LEG2_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>DSI_CTRL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IDAC_LO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IDAC_MED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>IDAC_HI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>LEG1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>LEG2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>LEG3_EN</name>
          </field>
        </fields>
        <name>IDACB</name>
        <resetMask>0x7EF0FFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40380000</baseAddress>
    <description>Timer/Counter/PWM</description>
    <interrupts></interrupts>
    <name>TCPWM0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>TCPWM control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counter enables for counters 0 up to CNT_NR-1.
            '0': counter disabled.
            '1': counter enabled.
            Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
            - the associated counter triggers in the CMD register are set to '0'.
            - the counter's interrupt cause fields in counter's INTR register.
            - the counter's status fields in counter's STATUS register..
            - the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
            - the counter's line outputs ('line_out' and 'line_compl_out').
            In multi-core environments, use the CTRL_SET/CTRL_CLR registers to avoid race-conditions on read-modify-write attempts to this register.</description>
            <name>COUNTER_ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>TCPWM control clear register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Alias of CTRL that only allows disabling of counters. A write access:
            '0': Does nothing.
            '1': Clears respective COUNTER_ENABLED field.
            
            A read access returns CTRL.COUNTER_ENABLED.</description>
            <name>COUNTER_ENABLED</name>
          </field>
        </fields>
        <name>CTRL_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>TCPWM control set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Alias of CTRL that only allows enabling of counters. A write access:
            '0': Does nothing.
            '1': Sets respective COUNTER_ENABLED field.
            
            A read access returns CTRL.COUNTER_ENABLED.</description>
            <name>COUNTER_ENABLED</name>
          </field>
        </fields>
        <name>CTRL_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>TCPWM capture command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
            <name>COUNTER_CAPTURE</name>
          </field>
        </fields>
        <name>CMD_CAPTURE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>TCPWM reload command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
            <name>COUNTER_RELOAD</name>
          </field>
        </fields>
        <name>CMD_RELOAD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>TCPWM stop command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
            <name>COUNTER_STOP</name>
          </field>
        </fields>
        <name>CMD_STOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>TCPWM start command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
            <name>COUNTER_START</name>
          </field>
        </fields>
        <name>CMD_START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>TCPWM Counter interrupt cause register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
            <name>COUNTER_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40390000</baseAddress>
    <derivedFrom>TCPWM0</derivedFrom>
    <description>Timer/Counter/PWM</description>
    <interrupts></interrupts>
    <name>TCPWM1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>TCPWM control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counter enables for counters 0 up to CNT_NR-1.
            '0': counter disabled.
            '1': counter enabled.
            Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
            - the associated counter triggers in the CMD register are set to '0'.
            - the counter's interrupt cause fields in counter's INTR register.
            - the counter's status fields in counter's STATUS register..
            - the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
            - the counter's line outputs ('line_out' and 'line_compl_out').
            In multi-core environments, use the CTRL_SET/CTRL_CLR registers to avoid race-conditions on read-modify-write attempts to this register.</description>
            <name>COUNTER_ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>TCPWM control clear register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Alias of CTRL that only allows disabling of counters. A write access:
            '0': Does nothing.
            '1': Clears respective COUNTER_ENABLED field.
            
            A read access returns CTRL.COUNTER_ENABLED.</description>
            <name>COUNTER_ENABLED</name>
          </field>
        </fields>
        <name>CTRL_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>TCPWM control set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Alias of CTRL that only allows enabling of counters. A write access:
            '0': Does nothing.
            '1': Sets respective COUNTER_ENABLED field.
            
            A read access returns CTRL.COUNTER_ENABLED.</description>
            <name>COUNTER_ENABLED</name>
          </field>
        </fields>
        <name>CTRL_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>TCPWM capture command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
            <name>COUNTER_CAPTURE</name>
          </field>
        </fields>
        <name>CMD_CAPTURE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>TCPWM reload command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
            <name>COUNTER_RELOAD</name>
          </field>
        </fields>
        <name>CMD_RELOAD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>TCPWM stop command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
            <name>COUNTER_STOP</name>
          </field>
        </fields>
        <name>CMD_STOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>TCPWM start command register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
            <name>COUNTER_START</name>
          </field>
        </fields>
        <name>CMD_START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>TCPWM Counter interrupt cause register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
            <name>COUNTER_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x403B0000</baseAddress>
    <description>LCD Controller Block</description>
    <interrupts></interrupts>
    <name>LCD0</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>ID &amp; Revision</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>the ID of LCD controller peripheral is 0xF0F0</description>
            <name>ID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>the version number is 0x0001</description>
            <name>REVISION</name>
          </field>
        </fields>
        <name>ID</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F0F0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>LCD Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Input clock frequency divide value, to generate the 1/4 sub-frame period. The sub-frame period is  4*(SUBFR_DIV+1) cycles long.</description>
            <name>SUBFR_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Length of the dead time period in cycles.  When set to  zero, no dead time period exists.</description>
            <name>DEAD_DIV</name>
          </field>
        </fields>
        <name>DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>LCD Configuration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Low speed (LS) generator enable
            1: enable
            0: disable</description>
            <name>LS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>High speed (HS) generator enable
            1: enable
            0: disable</description>
            <name>HS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>HS/LS Mode selection</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select Low Speed (32kHz) Generator (Works in Active, Sleep and DeepSleep power modes).</description>
                <name>LS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Select High Speed (system clock) Generator (Works in Active and Sleep power modes only).</description>
                <name>HS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LCD_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LCD driving waveform type configuration.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Type A - Each frame addresses each COM pin only once with a balanced (DC=0) waveform.</description>
                <name>TYPE_A</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Type B - Each frame addresses each COM pin twice in sequence with a positive and negative waveform that together are balanced (DC=0).</description>
                <name>TYPE_B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TYPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Driving mode configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>PWM Mode</description>
                <name>PWM</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Digital Correlation Mode</description>
                <name>CORRELATION</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM bias selection</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1/2 Bias</description>
                <name>HALF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1/3 Bias</description>
                <name>THIRD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1/4 Bias (not supported by LS generator)</description>
                <name>FOURTH</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1/5 Bias (not supported by LS generator)</description>
                <name>FIFTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIAS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>The number of COM connections minus 2. So:
            0: 2 COM's
            1: 3 COM's
            ...
            13: 15 COM's
            14: 16 COM's
            15: undefined</description>
            <name>COM_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LS enable status bit.  This bit is a copy of LS_EN that is synchronized to the low speed clock domain and back to the system clock domain. Firmware can use this bit to observe whether LS_EN has taken effect in the low speed clock domain.  Firmware should never change the configuration for the LS generator without ensuring this bit is 0.
            The following procedure should be followed to disable the LS generator:
            1. If LS_EN=0 we are done.  Exit the procedure.
            2. Check that LS_EN_STAT=1.  If not, wait until it is. This will catch the case of a recent enable (LS_EN=1) that has not taken effect yet.
            3. Set LS_EN=0.
            4. Wait until LS_EN_STAT=0.</description>
            <name>LS_EN_STAT</name>
          </field>
        </fields>
        <name>CONTROL</name>
        <resetMask>0x80000F7F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x114</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x118</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 1-4 (COM1 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA0[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 5-8 (COM5 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA1[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 9-12 (COM9 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA2[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[0]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x404</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[1]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x408</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[2]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[3]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x410</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[4]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x414</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[5]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x418</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[6]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x41C</addressOffset>
        <description>LCD Pin Data Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Bits [4i+3:4i] represent the pin data for pin [i] for COMS 13-16 (COM13 is lsb).</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>DATA3[7]</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x20000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x403C0000</baseAddress>
    <description>Bluetooth Low Energy Subsystem</description>
    <interrupts></interrupts>
    <name>BLE</name>
    <registers></registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x403F0000</baseAddress>
    <description>USB Host and Device Controller</description>
    <interrupts></interrupts>
    <name>USBFS0</name>
    <registers></registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40420000</baseAddress>
    <description>Serial Memory Interface</description>
    <interrupts></interrupts>
    <name>SMIF0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mode of operation.
            
            Note: this field should only be changed when the IP is disabled or when STATUS.BUSY is '0' and SW should not be executing from the XIP interface or MMIO interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>'0': MMIO mode. Individual MMIO accesses to TX and RX FIFOs are used to generate a sequence of SPI transfers. This mode of operation allows for large flexibility in terms of the SPI transfers that can be generated.</description>
                <name>MMIO_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1': XIP mode. eXecute-In-Place mode: incoming read and write transfers over the AHB-Lite bus infrastructure are automatically translated in SPI transfers to read data from and write data to a device. This mode of operation allow for efficient device read and write operations. This mode is only supported in SPI_MODE.</description>
                <name>XIP_MODE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>XIP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies device interface receiver clock 'clk_if_rx' source. MISO data is captured on the rising edge of 'clk_if_rx'.
            '0': 'spi_clk_out' (internal clock)
            '1': !'spi_clk_out' (internal clock)
            '2': 'spi_clk_in' (feedback clock)
            '3': !'spi_clk_in' (feedback clock)
            
            Note: the device interface transmitter clock 'clk_if_tx' is fixed and is 'spi_clk_out' MOSI data is driven on the falling edge of 'clk_if_tx'.</description>
            <name>CLOCK_IF_RX_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the minimum duration of SPI deselection ('spi_select_out[]' is high/'1') in between SPI transfers:
            '0': 1 interface clock cycle.
            '1': 2 interface clock cycles.
            '2': 3 interface clock cycles.
            '3': 4 interface clock cycles.
            '4': 5 interface clock cycles.
            '5': 6 interface clock cycles.
            '6': 7 interface clock cycles.
            '7': 8 interface clock cycles.
            
            During SPI deselection, 'spi_select_out[]' are '1'/inactive, 'spi_data_out[]' are '1' and 'spi_clk_out' is '0'/inactive.</description>
            <name>DESELECT_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies what happens for MMIO interface read accesses to an empty RX data FIFO or to a full TX format/data FIFO. Note: the FIFOs can only be accessed in MMIO_MODE.
            
            This field is not used for test controller accesses.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>0': Generate an AHB-Lite bus error. This option is useful when SW decides to use polling on STATUS.TR_BUSY to determine if a interface transfer is no longer busy (transfer is completed). This option adds SW complexity, but limits the number of AHB-Lite wait states (and limits ISR latency).</description>
                <name>BUS_ERROR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1': Introduce wait states. This setting potentially locks up the AHB-Lite infrastructure and may increase the CPU interrupt latency.This option is useful when SW performs TX/RX data FIFO accesses immediately after a command is setup using the TX format FIFO. This option has low SW complexity, but may result in a significant number of AHB-Lite wait states (and may increase ISR latency).</description>
                <name>WAIT_STATES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IP enable:
            '0': Disabled. All non-retention registers are reset to their default value when the IP is disabled. When the IP is disabled, the XIP accesses produce AHB-Lite bus errors.
            '1': Enabled.
            
            Note: Before disabling the IP, SW should ensure that the IP is NOT busy (STATUS.BUSY is '0'), otherwise illegal interface transfers may occur.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0x81073001</resetMask>
        <resetValue>0x3000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cache, cryptography, XIP, device interface or any other logic busy in the IP:
            '0': not busy
            '1': busy
            When BUSY is '0', the IP can be safely disabled without:
            - the potential loss of transient write data.
            - the potential risk of aborting an inflight SPI device interface transfer.
            When BUSY is '0', the mode of operation (XIP_MODE or MMIO_MODE) can be safely changed.</description>
            <name>BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x80000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x44</addressOffset>
        <description>Transmitter command FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Number of entries that are used in the TX command FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 4].</description>
            <name>USED3</name>
          </field>
        </fields>
        <name>TX_CMD_FIFO_STATUS</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x50</addressOffset>
        <description>Transmitter command FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x14</bitWidth>
            <description>Command data. The higher two bits DATA[19:18] specify the specific command
            '0'/TX: A SPI transfer always start with a TX command FIFO entry of the 'TX' format.
            - DATA[17:16] specifies the width of the data transfer:
               - '0': 1 bit/cycle (single data transfer).
               - '1': 2 bits/cycle (dual data transfer).
               - '2': 4 bits/cycle (quad data transfer).
               - '3': 8 bits/cycle (octal data transfer).
            - DATA[15]: specifies whether this is the last TX Byte; i.e. whether the 'spi_select_out[3:0]' IO output signals are de-activated after the transfer.
            - DATA[11:8] specifies which of the four devices are selected. DATA[11:8] are directly mapped to 'spi_select_out[3:0]'. Two devices can be selected at the same time in dual-quad mode.
              - '0': device deselected
              - '1': device selected 
            - DATA[7:0] specifies the transmitted Byte.
            
            '1'/TX_COUNT: The 'TX_COUNT' command relies on the TX data FIFO to provide the transmitted bytes. The 'TX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
            - DATA[17:16] specifies the width of the transfer.
            - DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) from the TX data FIFO.
            
            '2'/RX_COUNT: The 'RX_COUNT' command relies on the RX data FIFO to accept the received bytes. The 'RX_COUNT' command is ALWAYS considered to be the last command of a SPI data transfers.
            - DATA[17:16] specifies the width of the transfer.
            - DATA[15:0] specifies the number of to be transmitted Bytes (minus 1) to the RX data FIFO.
            
            '3'/DUMMY_COUNT: The 'DUMMY_COUNT' command conveys dummy cycles. Dummy cycles are used to implement a Turn-Around time in which the SPI master changes from a transmitter driving the data lines to a receiver receiving on the same data lines. The 'DUMMY_COUNT' command is ALWAYS considered to be NOT the last command of a SPI data transfers; i.e. it needs to be followed by another command.
            - DATA[15:0] specifies the number of dummy cycles (minus 1). In dummy cycles, the data lines are not driven.</description>
            <name>DATA20</name>
          </field>
        </fields>
        <name>TX_CMD_FIFO_WR</name>
        <resetMask>0xFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Transmitter data FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Determines when the TX data FIFO 'tr_tx_req' trigger is activated  (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
            - Trigger is active when TX_DATA_FIFO_STATUS.USED &lt;= TRIGGER_LEVEL.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <name>TX_DATA_FIFO_CTL</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x84</addressOffset>
        <description>Transmitter data FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Number of entries that are used in the TX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
            <name>USED4</name>
          </field>
        </fields>
        <name>TX_DATA_FIFO_STATUS</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x90</addressOffset>
        <description>Transmitter data FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <name>TX_DATA_FIFO_WR1</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x94</addressOffset>
        <description>Transmitter data FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO, first byte).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO, second byte).</description>
            <name>DATA1</name>
          </field>
        </fields>
        <name>TX_DATA_FIFO_WR2</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x98</addressOffset>
        <description>Transmitter data FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO, first byte).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO, second byte).</description>
            <name>DATA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO, third byte).</description>
            <name>DATA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX data (written to TX data FIFO, fourth byte).</description>
            <name>DATA3</name>
          </field>
        </fields>
        <name>TX_DATA_FIFO_WR4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0</addressOffset>
        <description>Receiver data FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Determines when RX data FIFI 'tr_rx_req' trigger is activated (trigger activation requires MMIO_MODE, the trigger is NOT activated in XIP_MODE):
            - Trigger is active when RX_DATA_FIFO_STATUS.USED &gt; TRIGGER_LEVEL.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <name>RX_DATA_FIFO_CTL</name>
        <resetMask>0x7</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC4</addressOffset>
        <description>Receiver data FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Number of entries that are used in the RX data FIFO (available in both XIP_MODE and MMIO_MODE). Legal range: [0, 8].</description>
            <name>USED4</name>
          </field>
        </fields>
        <name>RX_DATA_FIFO_STATUS</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD0</addressOffset>
        <description>Receiver data FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <name>RX_DATA_FIFO_RD1</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD4</addressOffset>
        <description>Receiver data FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO, first byte).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO, second byte).</description>
            <name>DATA1</name>
          </field>
        </fields>
        <name>RX_DATA_FIFO_RD2</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD8</addressOffset>
        <description>Receiver data FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO, first byte).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO, second byte).</description>
            <name>DATA1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO, third byte).</description>
            <name>DATA2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO, fourth byte).</description>
            <name>DATA3</name>
          </field>
        </fields>
        <name>RX_DATA_FIFO_RD4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE0</addressOffset>
        <description>Receiver data FIFO silent read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX data (read from RX data FIFO).</description>
            <name>DATA0</name>
          </field>
        </fields>
        <name>RX_DATA_FIFO_RD1_SILENT</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Slow cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
            <name>WAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
            <name>SET_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>SLOW_CA_CTL</name>
        <resetMask>0xC3030000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>Slow cache command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Cache invalidation. SW writes a '1' to clear the cache. The cache's LRU structure is also reset to its default state.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>SLOW_CA_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>Fast cache control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
            <name>WAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>this is for debug purpose only, and should be hidden to customers in technical document</description>
            <name>SET_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PREF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>FAST_CA_CTL</name>
        <resetMask>0xC3030000</resetMask>
        <resetValue>0xC0000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x188</addressOffset>
        <description>Fast cache command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>See SLOW_CA_CMD.INV.</description>
            <name>INV</name>
          </field>
        </fields>
        <name>FAST_CA_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Cryptography Command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW sets this field to '1' to start a AES-128 forward block cipher operation (on the address in CRYPTO_ADDR). HW sets this field to '0' to indicate that the operation has completed. Once completed, the result of the operation can be read from CRYPTO_RESULT0, ..., CRYPTO_RESULT3.
            
            The operation takes roughly 13 clk_hf clock cycles.
            
            Note: An operation can only be started in MMIO_MODE.</description>
            <name>START</name>
          </field>
        </fields>
        <name>CRYPTO_CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x220</addressOffset>
        <description>Cryptography input 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the plaintext PT[31:0] = CRYPTO_INPUT0.INPUT[31:0].</description>
            <name>INPUT</name>
          </field>
        </fields>
        <name>CRYPTO_INPUT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x224</addressOffset>
        <description>Cryptography input 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the plaintext PT[63:32] = CRYPTO_INPUT1.INPUT[31:0].</description>
            <name>INPUT</name>
          </field>
        </fields>
        <name>CRYPTO_INPUT1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x228</addressOffset>
        <description>Cryptography input 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the plaintext PT[95:64] = CRYPTO_INPUT2.INPUT[31:0].</description>
            <name>INPUT</name>
          </field>
        </fields>
        <name>CRYPTO_INPUT2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x22C</addressOffset>
        <description>Cryptography input 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the plaintext PT[127:96] = CRYPTO_INPUT3.INPUT[31:0].</description>
            <name>INPUT</name>
          </field>
        </fields>
        <name>CRYPTO_INPUT3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Cryptography key 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the key KEY[31:0] = CRYPTO_KEY0.KEY[31:0].</description>
            <name>KEY</name>
          </field>
        </fields>
        <name>CRYPTO_KEY0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x244</addressOffset>
        <description>Cryptography key 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the key KEY[63:32] = CRYPTO_KEY1.KEY[31:0].</description>
            <name>KEY</name>
          </field>
        </fields>
        <name>CRYPTO_KEY1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x248</addressOffset>
        <description>Cryptography key 2</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the key KEY[95:64] = CRYPTO_KEY2.KEY[31:0].</description>
            <name>KEY</name>
          </field>
        </fields>
        <name>CRYPTO_KEY2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24C</addressOffset>
        <description>Cryptography key 3</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the key KEY[127:96] = CRYPTO_KEY3.KEY[31:0].</description>
            <name>KEY</name>
          </field>
        </fields>
        <name>CRYPTO_KEY3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x260</addressOffset>
        <description>Cryptography output 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the ciphertext CT[31:0] = CRYPTO_OUTPUT0.OUTPUT[31:0].</description>
            <name>OUTPUT</name>
          </field>
        </fields>
        <name>CRYPTO_OUTPUT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x264</addressOffset>
        <description>Cryptography output 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the ciphertext CT[63:32] = CRYPTO_OUTPUT1.OUTPUT[31:0].</description>
            <name>OUTPUT</name>
          </field>
        </fields>
        <name>CRYPTO_OUTPUT1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x268</addressOffset>
        <description>Cryptography output 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the ciphertext CT[95:64] = CRYPTO_OUTPUT2.OUTPUT[31:0].</description>
            <name>OUTPUT</name>
          </field>
        </fields>
        <name>CRYPTO_OUTPUT2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x26C</addressOffset>
        <description>Cryptography output 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Four Bytes of the ciphertext CT[127:96] = CRYPTO_OUTPUT3.OUTPUT[31:0].</description>
            <name>OUTPUT</name>
          </field>
        </fields>
        <name>CRYPTO_OUTPUT3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C0</addressOffset>
        <description>Interrupt register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Activated in MMIO mode, when a TX data FIFO trigger 'tr_tx_req' is activated.</description>
            <name>TR_TX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Activated in MMIO mode, when a RX data FIFO trigger 'tr_rx_req' is activated.</description>
            <name>TR_RX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Activated in XIP mode, if:
            - The selected device's ADDR_CTL.DIV2 is '1' and the AHB-Lite bus transfer address is not a multiple of 2.
            - The selected device's ADDR_CTL.DIV2 is '1' and the XIP transfer request is NOT for a multiple of 2 Bytes. 
            
            Note: In dual-quad SPI mode (ADDR_CTL.DIV is '1'), each memory device contributes a 4-bit nibble for read data or write data. This is only possible if the request address is a multiple of 2 and the number of requested Bytes is a multiple of 2.</description>
            <name>XIP_ALIGNMENT_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX command FIFO (TX_CMD_FIFO_WR) with not enough free entries available.</description>
            <name>TX_CMD_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Activated in MMIO mode, on an AHB-Lite write transfer to the TX data FIFO (TX_DATA_FIFO_WR1, TX_DATA_FIFO_WR2, TX_DATA_FIFO_WR4) with not enough free entries available.</description>
            <name>TX_DATA_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Activated in MMIO mode, on an AHB-Lite read transfer from the RX data FIFO (RX_DATA_FIFO_RD1, RX_DATA_FIFO_RD2, RX_DATA_FIFO_RD4) with not enough entries available. Only activated for NON test bus controller transfers.</description>
            <name>RX_DATA_FIFO_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C4</addressOffset>
        <description>Interrupt set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TR_TX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TR_RX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>XIP_ALIGNMENT_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_CMD_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_DATA_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_DATA_FIFO_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C8</addressOffset>
        <description>Interrupt mask register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TR_TX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TR_RX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>XIP_ALIGNMENT_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_CMD_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_DATA_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_DATA_FIFO_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x7CC</addressOffset>
        <description>Interrupt masked register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TR_TX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TR_RX_REQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>XIP_ALIGNMENT_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_CMD_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_DATA_FIFO_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_DATA_FIFO_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40610000</baseAddress>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40620000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40630000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40640000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40650000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB4</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40660000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB5</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40670000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB6</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40680000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB7</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40690000</baseAddress>
    <derivedFrom>SCB0</derivedFrom>
    <description>Serial Communications Block (SPI/UART/I2C)</description>
    <interrupts></interrupts>
    <name>SCB8</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Generic control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
            '0': Internally clocked mode 
            '1': Externally clocked mode 
            
            In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.
            
            The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.
            
            Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.
            
            In UART mode this field should be '0'.</description>
            <name>EC_AM_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field specifies the clocking for the SCB block
            '0': Internally clocked mode 
            '1': externally clocked mode
             In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 
            
            Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).
            
            In UART mode this field should be '0'.</description>
            <name>EC_OP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Non EZ mode ('0') or EZ mode ('1').
            In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not seperated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.
            
            In UART mode this field should be '0'.</description>
            <name>EZ_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BYTE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').
            
            In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.
            
            In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
            <name>ADDR_ACCEPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
            <name>BLOCK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>I2C</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
            - Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
            - Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
            - Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
            - Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
            When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0x83031F0F</resetMask>
        <resetValue>0x300000F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>Generic status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
            <name>EC_BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Command/response control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
            <name>BASE_WR_ADDR</name>
          </field>
        </fields>
        <name>CMD_RESP_CTRL</name>
        <resetMask>0x1FF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Command/response status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address). 
            
            The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_RD_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximim memory buffer address).
            
            The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).
            
            This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
            <name>CURR_WR_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether there is an ongoing bus transfer to the IP.
            '0': no ongoing bus transfer.
            '1': ongoing bus transfer.
            
            For SPI, the field is '1' when slave mode is selected.
            
            For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
            <name>CMD_RESP_EC_BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CMD_RESP_EC_BUSY</name>
          </field>
        </fields>
        <name>CMD_RESP_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.
            
            When continuous transfers are enabled individual data frame transfers are not necessarily seperated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.
            
            When continuous transfers are not enabled individual data frame transfers are always seperated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
            <name>SSEL_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used in SPI Texas Instruments' submode.
            
            When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.
            
            When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
            <name>SELECT_PRECEDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.
            
            When '0', the default applies (
            for Motorola as determined by CPOL and CPHA, 
            for Texas Instruments on the falling edge of SCLK and 
            for National Semiconductors on the rising edge of SCLK). 
            
            When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
            <name>LATE_MISO_SAMPLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SCLK_CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SSEL_POLARITY3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
            '0': No local loopback
            '1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Motorola submode. In master mode, when not transmitting data (Slave SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_MOTOROLA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive; i.e. no pulse is generated.</description>
                <name>SPI_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SPI National Semiconducturs submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), Slave SELECT is inactive.</description>
                <name>SPI_NS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects one of the four incoming/outgoing SPI slave select signals:
            - 0: Slave 0, SSEL[0].
            - 1: Slave 1, SSEL[1].
            - 2: Slave 2, SSEL[2].
            - 3: Slave 3, SSEL[3].
            SCB block should be disabled when changes are made to this field.</description>
            <name>SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>SPI_CTRL</name>
        <resetMask>0x8F010F3F</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inidicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
            <name>SPI_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>SPI_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>UART control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). 
            0: Loopback is not enabled
            1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
            This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>N/A</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_STD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>UART_SMARTCARD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS should be set to 15.</description>
                <name>UART_IRDA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>UART_CTRL</name>
        <resetMask>0x3010000</resetMask>
        <resetValue>0x3000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>UART transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
            <name>RETRY_ON_NACK</name>
          </field>
        </fields>
        <name>UART_TX_CTRL</name>
        <resetMask>0x137</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>UART receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>N/A</description>
            <name>STOP_BITS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
            <name>POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when a parity check fails. 
            When '0', received data is sent to the RX FIFO. 
            When '1', received data is dropped and lost. 
            Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
            <name>DROP_ON_PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Behaviour when an error is detected in a start or stop period. 
            When '0', received data is sent to the RX FIFO.
             When '1', received data is dropped and lost.</description>
            <name>DROP_ON_FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MP_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
            <name>LIN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SKIP_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>N/A</description>
            <name>BREAK_WIDTH</name>
          </field>
        </fields>
        <name>UART_RX_CTRL</name>
        <resetMask>0xF3777</resetMask>
        <resetValue>0xA0002</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>UART receiver status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least signficant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
            <name>BR_COUNTER</name>
          </field>
        </fields>
        <name>UART_RX_STATUS</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>UART flow control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the RTS output signal:
            '0': RTS is active low; 
            '1': RTS is active high; 
            
            During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
            <name>RTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Polarity of the CTS input signal
            '0': CTS is active low ; 
            '1': CTS is active high;</description>
            <name>CTS_POLARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable use of CTS input signal by the UART transmitter:
            '0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
            '1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.
            
            If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes are indicated by RTS_POLARITY and CTS_POLARITY).</description>
            <name>CTS_ENABLED</name>
          </field>
        </fields>
        <name>UART_FLOW_CTRL</name>
        <resetMask>0x30100FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>I2C control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>HIGH_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 
            
            The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
            <name>LOW_PHASE_OVS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_GENERAL_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_ADDR_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READY_DATA_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This field is used during an address match or general call address in internally clocked mode 
            Only used when:
             - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full). 
            
            For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
            - EC_AM is '1' and EC_OP is '0'.
            - EC_AM is '1' and general call address match.
            - EC_AM is '1' and non EZ mode.
            Functionality is as follows:
            - 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
                   1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
                   2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
            - 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
            <name>S_NOT_READY_ADDR_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Only used when:
            - non EZ mode
            Functionality is as follows:
            - 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
            - 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
            <name>S_NOT_READY_DATA_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
            When '0', no loopback
            When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
            <name>LOOPBACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SLAVE_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>MASTER_MODE</name>
          </field>
        </fields>
        <name>I2C_CTRL</name>
        <resetMask>0xC001FBFF</resetMask>
        <resetValue>0xFB88</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>I2C status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).
            
            For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).
            
            For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
            <name>BUS_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_EC_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>S_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>M_READ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>CURR_EZ_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>BASE_EZ_ADDR</name>
          </field>
        </fields>
        <name>I2C_STATUS</name>
        <resetMask>0x31</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>I2C master command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_START_ON_IDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
            <name>M_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
             I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
            <name>M_STOP</name>
          </field>
        </fields>
        <name>I2C_M_CMD</name>
        <resetMask>0x1F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>I2C slave command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
            <name>S_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
            <name>S_NACK</name>
          </field>
        </fields>
        <name>I2C_S_CMD</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>I2C configuration</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SDA_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SDA input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SDA_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
            <name>SCL_IN_FILT_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable for 50ns glitch filter on SCL input
            '0': 0 ns.
            '1: 50 ns (filter enabled).</description>
            <name>SCL_IN_FILT_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT0_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT1_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Trim settings for the 50ns delay filter on SDA output used to gurantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
            <name>SDA_OUT_FILT2_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
            '0': 0 ns.
            '1': 50 ns (filter 0 enabled).
            '2': 100 ns (filters 0 and 1 enabled).
            '3': 150 ns (filters 0, 1 and 2 enabled).</description>
            <name>SDA_OUT_FILT_SEL</name>
          </field>
        </fields>
        <name>I2C_CFG</name>
        <resetMask>0x303F1313</resetMask>
        <resetValue>0x2A1013</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Digital DfT control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[0]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_scl_in' in I2C mode, as 'spi_clk_in' in SPI mode</description>
            <name>DDFT_IN0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies signal that is connected to 'ddft_in[1]' (digital DfT input signal 0):
            '0': not used
            '1': used as 'i2c_sda_in' in I2C mode, as 'spi_mosi_in' in SPI mode</description>
            <name>DDFT_IN1_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[0]' (digital DfT output signal 0):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'ec_busy_pp'.
            '2': 'rst_i2c_start_stop_n'.
            '3': 'rst_i2c_start_stop_n'.
            '4': 'i2c_scl_in_qual'.
            '5': 'i2c_sda_out_prel'.
            '6'-'7': Undefined.
            in SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'rst_spi_n'
            '2': 'rst_spi_stop_n'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT0_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies signal that is connected to 'ddft_out[1]' (digital DfT output signal 1):
            In I2C mode (CTRL.MODE=0),
            '0': Constant '0'. 
            '1': 'clk_ff_sram'.
            '2': 'rst_i2c_n'.
            '3': 'rst_i2c_stop_n'.
            '4': 'i2c_sda_in_qual'.
            '5': 'i2c_sda_out'.
            '6': 'event_i2c_ec_wake_up_ddft' from I2CS_IC
            '7': Undefined.
            In SPI mode (CTRL.MODE=1),
            '0': Constant '0'. 
            '1': 'spi_start_detect'
            '2': 'spi_stop_detect'
            '3'-'7': Undefined.</description>
            <name>DDFT_OUT1_SEL</name>
          </field>
        </fields>
        <name>DDFT_CTRL</name>
        <resetMask>0x770011</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Each IO cell 'xxx' has two associated IP output signals 'xxx_out_en' and 'xxx_out'.
            '0': Normal operation mode. Typically, this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by a single IO cell. In this operation mode, for an IO cell 'xxx' that is used as an output, the 'xxx_out_en' output enable signal is typically constant '1' the 'xxx_out' output is the outputted value. In other words, in normal operation mode, the 'xxx_out' output is used to control the IO cell output value: 'xxx_out' is '0' to drive an IO cell output value of '0' and 'xxx_out' is '1' to drive an IO cell output value of '1'.
            '1': Open drain operation mode. Typically this operation mode is used for IO cells that are connected to (board) wires/lines that are driven by multiple IO cells (possibly on multiple chips). In this operation mode, for and IO cell 'xxx' that is used as an output, the 'xxx_out_en' output controls the outputted value. Typically, open drain operation mode drives low/'0' and the 'xxx_out' output is constant '1'. In other words, in open drain operation mode, the 'xxx_out_en' output is used to control the IO cell output value: in drive low/'0' mode: 'xxx_out_en' is '1' (drive enabled) to drive an IO cell output value of '0' and 'xxx_out_en' is '1' (drive disabled) to not drive an IO cell output value (another IO cell can drive the wire/line or a pull up results in a wire/line value '1').
            
            The open drain mode is supported for:
            - I2C mode, 'i2c_scl' and 'i2c_sda' IO cells.
            - UART mode, 'uart_tx' IO cell (SPI slave).
            - SPI mode, 'spi_miso' IO cell.</description>
            <name>OPEN_DRAIN</name>
          </field>
        </fields>
        <name>TX_CTRL</name>
        <resetMask>0x1010F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Transmitter FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Transmitter FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is tranmitted next (when the protocol state machine is not transmitting a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Transmitter FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
            <name>DATA_WIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
            <name>MSB_FIRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptability to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
            <name>MEDIAN</name>
          </field>
        </fields>
        <name>RX_CTRL</name>
        <resetMask>0x30F</resetMask>
        <resetValue>0x107</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>Receiver FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTRL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>Receiver FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Amount of enties in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
            <name>SR_VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF81FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>Slave address and mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
            <name>MASK</name>
          </field>
        </fields>
        <name>RX_MATCH</name>
        <resetMask>0xFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x340</addressOffset>
        <description>Receiver FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.
            
            When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x344</addressOffset>
        <description>Receiver FIFO read silent</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.
            
            A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE00</addressOffset>
        <description>Active clocked interrupt signal</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
            <name>M</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
            <name>S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
            <name>TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
            <name>RX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
            <name>I2C_EC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
            <name>SPI_EC</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE80</addressOffset>
        <description>Externally clocked I2C interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request (with address match).
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (I2C STOP).
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.
            
            Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE88</addressOffset>
        <description>Externally clocked I2C interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xE8C</addressOffset>
        <description>Externally clocked I2C interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_I2C_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC0</addressOffset>
        <description>Externally clocked SPI interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.
            
            Only used when CTRL.EC_AM_MODE is '1'.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection. Activated on the end of a every transfer (SPI deselection).
            
            Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.
            
            Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xEC8</addressOffset>
        <description>Externally clocked SPI interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASK</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xECC</addressOffset>
        <description>Externally clocked SPI interrupt masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>WAKE_UP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EZ_READ_STOP</name>
          </field>
        </fields>
        <name>INTR_SPI_EC_MASKED</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Master interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI master transfer done event: all data frames in the transmit FIFO are sent, the transmit FIFO is empty (both TX FIFO and transmit shifter register are empty), and SPI select output pin is deselected.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Master interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_SET</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Master interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASK</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Master interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_DONE</name>
          </field>
        </fields>
        <name>INTR_M_MASKED</name>
        <resetMask>0x317</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF40</addressOffset>
        <description>Slave interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.
            
            In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF44</addressOffset>
        <description>Slave interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_SET</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF48</addressOffset>
        <description>Slave interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASK</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4C</addressOffset>
        <description>Slave interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ARB_LOST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_ADDR_MATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_GENERAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>I2C_BUS_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_WRITE_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_EZ_STOP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SPI_BUS_ERROR</name>
          </field>
        </fields>
        <name>INTR_S_MASKED</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF80</addressOffset>
        <description>Transmitter interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.
            
            Only used in FIFO mode.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF84</addressOffset>
        <description>Transmitter interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_SET</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF88</addressOffset>
        <description>Transmitter interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASK</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF8C</addressOffset>
        <description>Transmitter interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_NACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_DONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UART_ARB_LOST</name>
          </field>
        </fields>
        <name>INTR_TX_MASKED</name>
        <resetMask>0x7F3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC0</addressOffset>
        <description>Receiver interrupt request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>N/A</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC4</addressOffset>
        <description>Receiver interrupt set request</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt status register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_SET</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC8</addressOffset>
        <description>Receiver interrupt mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASK</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xFCC</addressOffset>
        <description>Receiver interrupt masked request</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BLOCKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FRAME_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>PARITY_ERROR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BAUD_DETECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>BREAK_DETECT</name>
          </field>
        </fields>
        <name>INTR_RX_MASKED</name>
        <resetMask>0xFED</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x41100000</baseAddress>
    <description>Continuous Time Block Mini</description>
    <interrupts></interrupts>
    <name>CTBM0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>global CTB and power control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: CTB IP disabled off during DeepSleep power mode
            - 1: CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
            <name>DEEPSLEEP_ON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: CTB IP disabled (put analog in power down, open all switches)
            - 1: CTB IP enabled</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTB_CTRL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Opamp0 and resistor0 control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Opamp0 power level, assumes Cload=15pF for the (internal only) 1x driver or 50pF for the (external) 10x driver</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Off</description>
                <name>OFF</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low power mode (IDD: 350uA, GBW: 1MHz for both 1x/10x)</description>
                <name>LOW</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Medium power mode (IDD: 600uA, GBW: 3MHz for 1x &amp; 2.5MHz for 10x)</description>
                <name>MEDIUM</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High power mode for highest GBW (IDD: 1500uA, GBW: 8MHz for 1x &amp; 6MHz for 10x)</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>RSVD</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power Saver Low power mode (IDD: ~20uA with 1uA bias from AREF, GBW: ~100kHz for 1x/10x, offset correcting IDAC is disabled)</description>
                <name>PS_LOW</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power Saver Medium power mode (IDD: ~40uA with 1uA bias from AREF, GBW: ~100kHz for 1x/10x, offset correcting IDAC is enabled)</description>
                <name>PS_MEDIUM</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power Saver Medium power mode (IDD: ~60uA with 1uA bias from AREF, GBW: ~200kHz for 1x/10x, offset correcting IDAC is enabled)</description>
                <name>PS_HIGH</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OA0_PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 output strength select 0=1x, 1=10x
            This setting sets specific requirements for OA0_BOOST_EN and OA0_COMP_TRIM</description>
            <name>OA0_DRIVE_STR_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 comparator enable</description>
            <name>OA0_COMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 hysteresis enable (10mV)</description>
            <name>OA0_HYST_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 bypass comparator output synchronization for DSI (trigger) output: 0=synchronize (level or pulse), 1=bypass (output async)</description>
            <name>OA0_BYPASS_DSI_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 comparator DSI (trigger) out level : 
            0=pulse, each time an edge is detected (see OA0_COMPINT) a pulse is sent out on DSI
            1=level,  DSI output is a synchronized version of the comparator output</description>
            <name>OA0_DSI_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Opamp0 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled, no interrupts will be detected</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both rising and falling edges</description>
                <name>BOTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OA0_COMPINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 pump enable</description>
            <name>OA0_PUMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 gain booster enable for class A output, for risk mitigation only, not user selectable. Value depends on the drive strength setting - 1x mode: set to 1; 10x mode: set to 0</description>
            <name>OA0_BOOST_EN</name>
          </field>
        </fields>
        <name>OA_RES0_CTRL</name>
        <resetMask>0x1BFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Opamp1 and resistor1 control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Opamp1 power level: see description of OA0_PWR_MODE</description>
            <name>OA1_PWR_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 output strength select 0=1x, 1=10x
            This setting sets specific requirements for OA1_BOOST_EN and OA1_COMP_TRIM</description>
            <name>OA1_DRIVE_STR_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 comparator enable</description>
            <name>OA1_COMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 hysteresis enable (10mV)</description>
            <name>OA1_HYST_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize, 1=bypass</description>
            <name>OA1_BYPASS_DSI_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 comparator DSI (trigger) out level : 
            0=pulse, each time an edge is detected (see OA1_COMPINT) a pulse is sent out on DSI
            1=level,  DSI output is a synchronized version of the comparator output</description>
            <name>OA1_DSI_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Opamp1 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled, no interrupts will be detected</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge</description>
                <name>RISING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge</description>
                <name>FALLING</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both rising and falling edges</description>
                <name>BOTH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OA1_COMPINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 pump enable</description>
            <name>OA1_PUMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 gain booster enable for class A output, for risk mitigation only, not user selectable. Value depends on the drive strength setting - 1x mode: set to 1; 10x mode: set to 0</description>
            <name>OA1_BOOST_EN</name>
          </field>
        </fields>
        <name>OA_RES1_CTRL</name>
        <resetMask>0x1BFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Comparator status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 current comparator status</description>
            <name>OA0_COMP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 current comparator status</description>
            <name>OA1_COMP</name>
          </field>
        </fields>
        <name>COMP_STAT</name>
        <resetMask>0x10001</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
            <name>COMP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
            <name>COMP1</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt request set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>COMP0_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>COMP1_SET</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Interrupt request mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>COMP0_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>COMP1_MASK</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Interrupt request masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>COMP0_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>COMP1_MASKED</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Opamp0 switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 positive terminal amuxbusa</description>
            <name>OA0P_A00</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 positive terminal P0</description>
            <name>OA0P_A20</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 positive terminal ctbbus0</description>
            <name>OA0P_A30</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 negative terminal P1</description>
            <name>OA0M_A11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 negative terminal Opamp0 output</description>
            <name>OA0M_A81</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 output sarbus0 (ctbbus2 in CTB)</description>
            <name>OA0O_D51</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp0 output switch to short 1x with 10x drive</description>
            <name>OA0O_D81</name>
          </field>
        </fields>
        <name>OA0_SW</name>
        <resetMask>0x24410D</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>Opamp0 switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0P_A00</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0P_A20</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0P_A30</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0M_A11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0M_A81</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0O_D51</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA0_SW</description>
            <name>OA0O_D81</name>
          </field>
        </fields>
        <name>OA0_SW_CLEAR</name>
        <resetMask>0x24410D</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88</addressOffset>
        <description>Opamp1 switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 positive terminal amuxbusb</description>
            <name>OA1P_A03</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 positive terminal P5</description>
            <name>OA1P_A13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 positive terminal ctbbus1</description>
            <name>OA1P_A43</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 positive terminal to vref1</description>
            <name>OA1P_A73</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 negative terminal P4</description>
            <name>OA1M_A22</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 negative terminal Opamp1 output</description>
            <name>OA1M_A82</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 output sarbus0 (ctbbus2 in CTB)</description>
            <name>OA1O_D52</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 output sarbus1 (ctbbus3 in CTB)</description>
            <name>OA1O_D62</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Opamp1 output switch to short 1x with 10x drive</description>
            <name>OA1O_D82</name>
          </field>
        </fields>
        <name>OA1_SW</name>
        <resetMask>0x2C4193</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>Opamp1 switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1P_A03</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1P_A13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1P_A43</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1P_A73</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1M_A22</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1M_A82</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1O_D52</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1O_D62</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in OA1_SW</description>
            <name>OA1O_D82</name>
          </field>
        </fields>
        <name>OA1_SW_CLEAR</name>
        <resetMask>0x2C4193</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>CTDAC connection switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTDAC Reference opamp output to ctdrefdrive</description>
            <name>CTDD_CRD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ctdrefsense to opamp input</description>
            <name>CTDS_CRS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ctdvout to opamp input</description>
            <name>CTDS_COR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P6 pin to Hold capacitor</description>
            <name>CTDO_C6H</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ctdvout to Hold capacitor (Sample switch). Note this switch will temporarily be opened for deglitching if CTDAC.DEGLITCH_COS is set</description>
            <name>CTDO_COS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Drive the CTDAC output with CTBM 1x output during hold mode in Sample and Hold operation</description>
            <name>CTDH_COB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hold capacitor connect</description>
            <name>CTDH_CHD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hold capacitor to opamp input</description>
            <name>CTDH_CA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hold capacitor isolation (from all the other switches)</description>
            <name>CTDH_CIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hold capacitor leakage reduction (drive other side of CIS to capacitor voltage)</description>
            <name>CTDH_ILR</name>
          </field>
        </fields>
        <name>CTD_SW</name>
        <resetMask>0xF732</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>CTDAC connection switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDD_CRD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDS_CRS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDS_COR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDO_C6H</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDO_COS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDH_COB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDH_CHD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDH_CA0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDH_CIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDH_ILR</name>
          </field>
        </fields>
        <name>CTD_SW_CLEAR</name>
        <resetMask>0xF732</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC0</addressOffset>
        <description>CTB bus switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P22, D51 (dsi_out[2])</description>
            <name>P2_DS_CTRL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P33, D52, D62 (dsi_out[3])</description>
            <name>P3_DS_CTRL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hold capacitor Sample switch (COS)</description>
            <name>CTD_COS_DS_CTRL</name>
          </field>
        </fields>
        <name>CTB_SW_DS_CTRL</name>
        <resetMask>0x80000C00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC4</addressOffset>
        <description>CTB bus switch Sar Sequencer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for D51</description>
            <name>P2_SQ_CTRL23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for D52, D62</description>
            <name>P3_SQ_CTRL23</name>
          </field>
        </fields>
        <name>CTB_SW_SQ_CTRL</name>
        <resetMask>0xC00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC8</addressOffset>
        <description>CTB bus switch control status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see OA0O_D51 bit in OA0_SW</description>
            <name>OA0O_D51_STAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see OA1O_D52 bit in OA1_SW</description>
            <name>OA1O_D52_STAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see OA1O_D62 bit in OA1_SW</description>
            <name>OA1O_D62_STAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see COS bit in CTD_SW</description>
            <name>CTD_COS_STAT</name>
          </field>
        </fields>
        <name>CTB_SW_STATUS</name>
        <resetMask>0xF0000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Opamp0 trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Opamp0 offset trim</description>
            <name>OA0_OFFSET_TRIM</name>
          </field>
        </fields>
        <name>OA0_OFFSET_TRIM</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Opamp0 trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Opamp0 slope offset drift trim</description>
            <name>OA0_SLOPE_OFFSET_TRIM</name>
          </field>
        </fields>
        <name>OA0_SLOPE_OFFSET_TRIM</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Opamp0 trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Opamp0 Compensation Capacitor Trim. 
            Value depends on the drive strength setting - 1x mode: set to 01; 10x mode: set to 11</description>
            <name>OA0_COMP_TRIM</name>
          </field>
        </fields>
        <name>OA0_COMP_TRIM</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Opamp1 trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Opamp1 offset trim</description>
            <name>OA1_OFFSET_TRIM</name>
          </field>
        </fields>
        <name>OA1_OFFSET_TRIM</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF10</addressOffset>
        <description>Opamp1 trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Opamp1 slope offset drift trim</description>
            <name>OA1_SLOPE_OFFSET_TRIM</name>
          </field>
        </fields>
        <name>OA1_SLOPE_OFFSET_TRIM</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF14</addressOffset>
        <description>Opamp1 trim control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Opamp1 Compensation Capacitor Trim. 
            Value depends on the drive strength setting - 1x mode: set to 01; 10x mode: set to 11</description>
            <name>OA1_COMP_TRIM</name>
          </field>
        </fields>
        <name>OA1_COMP_TRIM</name>
        <resetMask>0x3</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x41140000</baseAddress>
    <description>Continuous Time DAC</description>
    <interrupts></interrupts>
    <name>CTDAC0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Global CTDAC control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>To prevent glitches after VALUE changes from propagating the output switch can be opened for DEGLITCH_CNT+1 clk_peri clock cycles.</description>
            <name>DEGLITCH_CNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Force CTDAC.CO6 switch open after each VALUE change for the set number of clock cycles.</description>
            <name>DEGLITCH_CO6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Force CTB.COS switch open after each VALUE change for the set number of clock cycles.</description>
            <name>DEGLITCH_COS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output enable, intended to be used during the Hold phase of the Sample and Hold when power cycling :
            0: output disabled, the output is either: 
                   - Tri-state (DISABLED_MODE=0) 
                   - or Vssa (DISABLED_MODE=1 &amp;&amp; CTDAC_RANGE=0)  
                   - or Vref (DISABLED_MODE=1 &amp;&amp; CTDAC_RANGE=1) 
            1: output enabled, CTDAC output drives the programmed VALUE</description>
            <name>OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>By closing the bottom switch in the R2R network the output is lifted by one LSB, effectively adding 1
            0: Range is [0, 4095] * Vref / 4096 
            1: Range is [1, 4096] * Vref / 4096</description>
            <name>CTDAC_RANGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>DAC mode, this determines the Value decoding</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Unsigned 12-bit VDAC, i.e. no value decoding.</description>
                <name>UNSIGNED12</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Virtual signed 12-bits' VDAC. Value decoding: 
                add 0x800 to the 12-bit Value (=invert MSB), to convert the lowest signed number 0x800 to the lowest unsigned number 0x000. This is the same as the SAR handles 12-bit 'virtual' signed numbers.</description>
                <name>VIRT_SIGNED12</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>RSVD2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>N/A</description>
                <name>RSVD3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTDAC_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select the output value when the output is disabled (OUT_EN=0) (for risk mitigation)
            0: Tri-state CTDAC output when disabled
            1: output Vssa or Vref when disabled (see OUT_EN description)</description>
            <name>DISABLED_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI strobe input Enable. This enables CTDAC updates to be further throttled by DSI.
            0: Ignore DSI strobe input
            1: Only do a CTDAC update if alllowed by the DSI stobe (throttle), see below for level or edge</description>
            <name>DSI_STROBE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select level or edge detect for DSI strobe
            - 0: DSI strobe signal is a pulse input, after a positive edge is detected on the DSI strobe signal the next DAC value update is done on the next CTDAC clock
            - 1: DSI strobe signal is a level input, as long as the DSI strobe signal remains high the CTDAC will do a next DAC value update on each CTDAC clock.</description>
            <name>DSI_STROBE_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: CTDAC IP disabled off during DeepSleep power mode
            - 1: CTDAC IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
            <name>DEEPSLEEP_ON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>0: CTDAC IP disabled (put analog in power down, open all switches)
            1: CTDAC IP enabled</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTDAC_CTRL</name>
        <resetMask>0xFBC0033F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VDAC Interrupt: hardware sets this interrupt when VDAC next value field is empty, i.e. was copied to the current VALUE. Write with '1' to clear bit.</description>
            <name>VDAC_EMPTY</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt request set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>VDAC_EMPTY_SET</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Interrupt request mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>VDAC_EMPTY_MASK</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Interrupt request masked</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>VDAC_EMPTY_MASKED</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB0</addressOffset>
        <description>CTDAC switch control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VDDA supply to ctdrefdrive</description>
            <name>CTDD_CVD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ctdvout to P6 pin. Note this switch will temporarily be opened for deglitching if DEGLITCH_CO6 is set</description>
            <name>CTDO_CO6</name>
          </field>
        </fields>
        <name>CTDAC_SW</name>
        <resetMask>0x101</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB4</addressOffset>
        <description>CTDAC switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDD_CVD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>see corresponding bit in CTD_SW</description>
            <name>CTDO_CO6</name>
          </field>
        </fields>
        <name>CTDAC_SW_CLEAR</name>
        <resetMask>0x101</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>DAC Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Value, in CTDAC_MODE 1 this value is decoded</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>CTDAC_VAL</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>Next DAC value (double buffering)</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Next value fpr CTDAC_VAL.VALUE</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>CTDAC_VAL_NXT</name>
        <resetMask>0xFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x411D0000</baseAddress>
    <description>SAR ADC with Sequencer</description>
    <interrupts></interrupts>
    <name>SAR</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Analog control register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>VREF buffer low power mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>full power  (100 percent) (default), bypass cap, max clk_sar is 18MHz.</description>
                <name>PWR_100</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>80 percent power</description>
                <name>PWR_80</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>60 percent power</description>
                <name>PWR_60</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>50 percent power</description>
                <name>PWR_50</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>40 percent power</description>
                <name>PWR_40</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>30 percent power</description>
                <name>PWR_30</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20 percent power</description>
                <name>PWR_20</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10 percent power</description>
                <name>PWR_10</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PWR_CTRL_VREF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>SARADC internal VREF selection.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>VREF0 from PRB (VREF buffer on)</description>
                <name>VREF0</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>VREF1 from PRB (VREF buffer on)</description>
                <name>VREF1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>VREF2 from PRB (VREF buffer on)</description>
                <name>VREF2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>VREF from AROUTE (VREF buffer on)</description>
                <name>VREF_AROUTE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.024V from BandGap (VREF buffer on)</description>
                <name>VBGR</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>External precision Vref direct from a pin (low impedance path).</description>
                <name>VREF_EXT</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Vdda/2  (VREF buffer on)</description>
                <name>VDDA_DIV_2</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Vdda.</description>
                <name>VDDA</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VREF_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>VREF bypass cap enable for when VREF buffer is on</description>
            <name>VREF_BYP_CAP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>SARADC internal NEG selection for Single ended conversion</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                <name>VSSA_KELVIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                <name>ART_VSSA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                <name>P1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                <name>P3</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                <name>P5</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                <name>P7</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                <name>ACORE</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                <name>VREF</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
            <name>SAR_HW_CTRL_NEGVREF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set the comparator latch delay in accordance with SAR conversion rate</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.5ns delay, use this for 2.5Msps</description>
                <name>D2P5</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.0ns delay, use this for 2.0Msps</description>
                <name>D4</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10ns delay, use this for 1.5Msps</description>
                <name>D10</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>12ns delay, use this for 1.0Msps or less</description>
                <name>D12</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMP_DLY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Spare controls, not yet designated, for late changes done with an ECO</description>
            <name>SPARE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>deprecated</description>
            <name>BOOSTPUMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>For normal ADC operation this bit must be set, for all reference choices - internal, external or vdda based reference. 
            Setting this bit is critical to proper function of switches inside SARREF block.</description>
            <name>REFBUF_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Comparator power mode. (Sample rate TBD)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 100 percent, use this for &gt;2000Ksps</description>
                <name>P100</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 80 percent, use this for 1500-2000Ksps</description>
                <name>P80</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 60 percent, use this for 1000-1500Ksps</description>
                <name>P60</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 50 percent, use this for 500-1000Ksps</description>
                <name>P50</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 40 percent, use this for 250-500Ksps</description>
                <name>P40</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 30 percent, use this for 100-250Ksps</description>
                <name>P30</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 20 percent, use this for 100-250Ksps (TBD!)</description>
                <name>P20</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Power = 10 percent, use this for &lt;100Ksps</description>
                <name>P10</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMP_PWR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: SARMUX IP disabled off during DeepSleep power mode
            - 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
            <name>DEEPSLEEP_ON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: bypass clock domain synchronisation of the DSI config signals.
            - 1: synchronize the DSI config signals to peripheral clock domain.</description>
            <name>DSI_SYNC_CONFIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SAR sequencer takes configuration from DSI signals (note this also has the same effect as SWITCH_DISABLE==1)
            - 0: Normal mode, SAR sequencer operates according to CHAN_EN enables and CHAN_CONFIG channel configurations
            - 1: CHAN_EN, INJ_START_EN and channel configurations in CHAN_CONFIG and INJ_CHAN_CONFIG are ignored</description>
            <name>DSI_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)
            - 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations
            - 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
            <name>SWITCH_DISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgaiting) on write.
            - 1: SAR IP enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFF3FEEF7</resetMask>
        <resetValue>0x10000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Sample control register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
            <name>LEFT_ALIGN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output data from a single ended conversion as a signed value</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Default: result data is unsigned (zero extended if needed)</description>
                <name>UNSIGNED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>result data is signed (sign extended if needed)</description>
                <name>SIGNED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SINGLE_ENDED_SIGNED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Output data from a differential conversion as a signed value when DIFFERENTIAL_EN or NEG_ADDR_EN is set to 1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>result data is unsigned (zero extended if needed)</description>
                <name>UNSIGNED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Default: result data is signed (sign extended if needed)</description>
                <name>SIGNED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIFFERENTIAL_SIGNED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Averaging Count for channels that have averaging enabled (AVG_EN). A channel will be sampled (1&lt;&lt;(AVG_CNT+1)) = [2..256] times.
            - In ACCUNDUMP mode  (1st order accumulate and dump filter) a channel will be sampled back to back, the average result is calculated and stored and then the next enabled channel is sampled. If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).
            - In INTERLEAVED mode one sample is taken per triggered scan, only in the scan where the final averaging count is reached a valid average is calculated and stored in the RESULT register (by definition the same scan for all the channels that have averaging enabled). In all other scans the RESULT register for averaged channels will have an invalid result and the intermediate accumulated value is stored in the 16-bit WORK register. In this mode make sure that the averaging count is low enough to ensure that the intermediate value does not exceed 16-bits otherwise the MSBs will be lost. So for a 12-bit resolution the averaging count should be set to 16 or less (AVG_CNT=&lt;3).</description>
            <name>AVG_CNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging shifting: after averaging the result is shifted right to fit in 12 bits.</description>
            <name>AVG_SHIFT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging mode,  in DSI mode this bit is ignored and only AccuNDump mode is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Accumulate and Dump (1st order accumulate and dump filter): a channel will be sampled back to back and averaged</description>
                <name>ACCUNDUMP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Interleaved: Each scan (trigger) one sample is taken per channel and averaged over several scans.</description>
                <name>INTERLEAVED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>AVG_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.
            - 1: Continuously scan enabled channels, ignore triggers.</description>
            <name>CONTINUOUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: firmware trigger only: disable hardware trigger tr_sar_in.
            - 1: enable hardware trigger tr_sar_in (e.g. from TCPWM, GPIO or UDB).</description>
            <name>DSI_TRIGGER_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: trigger signal is a pulse input, a positive edge detected on the trigger signal triggers a new scan.
            - 1: trigger signal is a level input, as long as the trigger signal remains high the SAR will do continuous scans.</description>
            <name>DSI_TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>- 0: bypass clock domain synchronisation of the trigger signal.
            - 1: synchronize the trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
            <name>DSI_SYNC_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select whether UABs are scheduled or unscheduled. When no UAB is scanned this selection is ignored.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Unscheduled UABs: one or more of the UABs scanned by the SAR is not scheduled, for each channel that scans a UAB the SAR will wait for a positive edge on the trigger output of that UAB. Caveat: in this mode the length of SAR scan can be variable.</description>
                <name>UNSCHEDULED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Scheduled UABs: All UABs scanned by the SAR are assumed to be properly scheduled, i.e. their output is assumed to be valid when sampled by the SAR and the SAR does not wait. In this mode the length of the SAR scan is constant. 
                This mode requires that the SAR scans strictly periodically, i.e. the SAR has to either run continuously or has to be triggered by a periodic hardware trigger (TCPWM or UDB timer). It also requires that the end of the UAB valid phase is precisely aligned with the end of the SAR sample period (using UAB.STARTUP_DELAY). Normally this scheduling is done by Creator.</description>
                <name>SCHEDULED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UAB_SCAN_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>For unscheduled UAB_SCAN_MODE only, do the following if an invalid sample is received:
            - 0: use the last known valid sample for that channel and clear the NEWVALUE flag
            - 1: repeat the conversions until a valid sample is received (caveat: could be never if the UAB valid window is incorrectly schedule w.r.t. SAR sampling)</description>
            <name>REPEAT_INVALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Static UAB Valid select
            0=UAB0 half 0 Valid output
            1=UAB0 half 1 Valid output
            2=UAB1 half 0 Valid output
            3=UAB1 half 1 Valid output
            4=UAB2 half 0 Valid output
            5=UAB2 half 1 Valid output
            6=UAB3 half 0 Valid output
            7=UAB3 half 1 Valid output</description>
            <name>VALID_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable static UAB Valid selection (override Hardware)</description>
            <name>VALID_SEL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Ignore UAB valid signal, including the dynamic/Hardware from AROUTE and the static Valid selection from the VALID_SEL fields above</description>
            <name>VALID_IGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SAR output trigger enable (used for UAB synchronization). To ensure multiple UABs starting at the same trigger it is recommended to use this bit to temporarily disable the trigger output until all those UABs are set to run (UAB.SRAM_CTRL.RUN=1).</description>
            <name>TRIGGER_OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a trigger pulse is send on the tr_sar_out signal.</description>
            <name>EOS_DSI_OUT_EN</name>
          </field>
        </fields>
        <name>SAMPLE_CTRL</name>
        <resetMask>0xDFCF01FE</resetMask>
        <resetValue>0x80008</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Sample time specification ST0 and ST1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is one clock less than specified here. The minimum sample time is 167ns, which is 3.0 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
            <name>SAMPLE_TIME0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Sample time1</description>
            <name>SAMPLE_TIME1</name>
          </field>
        </fields>
        <name>SAMPLE_TIME01</name>
        <resetMask>0x3FF03FF</resetMask>
        <resetValue>0x30003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Sample time specification ST2 and ST3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Sample time2</description>
            <name>SAMPLE_TIME2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Sample time3</description>
            <name>SAMPLE_TIME3</name>
          </field>
        </fields>
        <name>SAMPLE_TIME23</name>
        <resetMask>0x3FF03FF</resetMask>
        <resetValue>0x30003</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Global range detect threshold register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Low threshold for range detect.</description>
            <name>RANGE_LOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>High threshold for range detect.</description>
            <name>RANGE_HIGH</name>
          </field>
        </fields>
        <name>RANGE_THRES</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Global range detect mode register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Range condition select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>result &lt; RANGE_LOW</description>
                <name>BELOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                <name>INSIDE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>RANGE_HIGH &lt;= result</description>
                <name>ABOVE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                <name>OUTSIDE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RANGE_COND</name>
          </field>
        </fields>
        <name>RANGE_COND</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Enable bits for the channels</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Channel enable. 
            - 0: the corresponding channel is disabled.
            - 1: the corresponding channel is enabled, it will be included in the next scan.</description>
            <name>CHAN_EN</name>
          </field>
        </fields>
        <name>CHAN_EN</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Start control register (firmware trigger).</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.</description>
            <name>FW_TRIGGER</name>
          </field>
        </fields>
        <name>START_CTRL</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x200</addressOffset>
        <description>Channel working data register 'updated' bits</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If set the corresponding WORK register was updated, i.e. was already sampled during the current scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
            <name>CHAN_WORK_UPDATED</name>
          </field>
        </fields>
        <name>CHAN_WORK_UPDATED</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x204</addressOffset>
        <description>Channel result data register 'updated' bits</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If set the corresponding RESULT register was updated, i.e. was sampled during the previous scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
            <name>CHAN_RESULT_UPDATED</name>
          </field>
        </fields>
        <name>CHAN_RESULT_UPDATED</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x208</addressOffset>
        <description>Channel working data register 'new value' bits</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If set the corresponding WORK data received a new value, i.e. was already sampled during the current scan and data was valid.
            In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.
            In case of averaging this New Value bit is an OR of all the valid bits received by each conversion.</description>
            <name>CHAN_WORK_NEWVALUE</name>
          </field>
        </fields>
        <name>CHAN_WORK_NEWVALUE</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20C</addressOffset>
        <description>Channel result data register 'new value' bits</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>If set the corresponding RESULT data received a new value, i.e. was sampled during the last scan and data was valid.
            In case of  a UAB this New Value bit reflects the value of UAB.valid output, for anything else the data is always valid.
            In case of averaging this New Value bit is an OR of all the valid bits received by each conversion.</description>
            <name>CHAN_RESULT_NEWVALUE</name>
          </field>
        </fields>
        <name>CHAN_RESULT_NEWVALUE</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Interrupt request register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
            <name>EOS_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.</description>
            <name>OVERFLOW_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
            <name>FW_COLLISION_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
            <name>DSI_COLLISION_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit.</description>
            <name>INJ_EOC_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF, this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
            <name>INJ_SATURATE_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
            <name>INJ_RANGE_INTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit.</description>
            <name>INJ_COLLISION_INTR</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Interrupt set request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>EOS_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>OVERFLOW_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>FW_COLLISION_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>DSI_COLLISION_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>INJ_EOC_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>INJ_SATURATE_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>INJ_RANGE_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>INJ_COLLISION_SET</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>Interrupt mask register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>EOS_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>OVERFLOW_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>FW_COLLISION_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>DSI_COLLISION_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>INJ_EOC_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>INJ_SATURATE_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>INJ_RANGE_MASK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>INJ_COLLISION_MASK</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x21C</addressOffset>
        <description>Interrupt masked request register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>EOS_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>OVERFLOW_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>FW_COLLISION_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>DSI_COLLISION_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>INJ_EOC_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>INJ_SATURATE_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>INJ_RANGE_MASKED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>INJ_COLLISION_MASKED</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x220</addressOffset>
        <description>Saturate interrupt request register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF, this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
            <name>SATURATE_INTR</name>
          </field>
        </fields>
        <name>SATURATE_INTR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x224</addressOffset>
        <description>Saturate interrupt set request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>SATURATE_SET</name>
          </field>
        </fields>
        <name>SATURATE_INTR_SET</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x228</addressOffset>
        <description>Saturate interrupt mask register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>SATURATE_MASK</name>
          </field>
        </fields>
        <name>SATURATE_INTR_MASK</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x22C</addressOffset>
        <description>Saturate interrupt masked request register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>SATURATE_MASKED</name>
          </field>
        </fields>
        <name>SATURATE_INTR_MASKED</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x230</addressOffset>
        <description>Range detect interrupt request register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
            <name>RANGE_INTR</name>
          </field>
        </fields>
        <name>RANGE_INTR</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x234</addressOffset>
        <description>Range detect interrupt set request register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RANGE_SET</name>
          </field>
        </fields>
        <name>RANGE_INTR_SET</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x238</addressOffset>
        <description>Range detect interrupt mask register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RANGE_MASK</name>
          </field>
        </fields>
        <name>RANGE_INTR_MASK</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x23C</addressOffset>
        <description>Range interrupt masked request register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RANGE_MASKED</name>
          </field>
        </fields>
        <name>RANGE_INTR_MASKED</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x240</addressOffset>
        <description>Interrupt cause register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>EOS_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>OVERFLOW_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>FW_COLLISION_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>DSI_COLLISION_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>INJ_EOC_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>INJ_SATURATE_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>INJ_RANGE_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
            <name>INJ_COLLISION_MASKED_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
            <name>SATURATE_MASKED_RED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
            <name>RANGE_MASKED_RED</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0xC00000FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x280</addressOffset>
        <description>Injection channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this injection channel. If differential is enabled then INJ_PIN_ADDR[0] is ignored and considered to be 0, i.e. INJ_PIN_ADDR points to the even pin of a pin pair.</description>
            <name>INJ_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port</description>
                <name>AROUTE_VIRT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INJ_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (INJ_PIN_ADDR[0] is ignored).</description>
            <name>INJ_DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>INJ_AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>INJ_SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Injection channel tailgating.
            - 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set.
            - 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
            <name>INJ_TAILGATING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.</description>
            <name>INJ_START_EN</name>
          </field>
        </fields>
        <name>INJ_CHAN_CONFIG</name>
        <resetMask>0xC0003577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x290</addressOffset>
        <description>Injection channel result register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel.</description>
            <name>INJ_RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The data in this register received a new value (only relevant for UAB, this bit shows the value of the UAB valid bit)</description>
            <name>INJ_NEWVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_INTR register</description>
            <name>INJ_COLLISION_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_INTR register</description>
            <name>INJ_SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_INTR register</description>
            <name>INJ_RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_INTR register</description>
            <name>INJ_EOC_INTR_MIR</name>
          </field>
        </fields>
        <name>INJ_RESULT</name>
        <resetMask>0xF8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2A0</addressOffset>
        <description>Current status of internal SAR registers (mostly for debug)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY.</description>
            <name>CUR_CHAN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL).</description>
            <name>SW_VREF_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
            <name>BUSY</name>
          </field>
        </fields>
        <name>STATUS</name>
        <resetMask>0xC000001F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2A4</addressOffset>
        <description>Current averaging status (for debug)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x14</bitWidth>
            <description>the current value of the averaging accumulator</description>
            <name>CUR_AVG_ACCU</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If high then the SAR is in the middle of Interleaved averaging spanning several scans. While this bit is high the Firmware should not make any changes to the configuration registers otherwise some results may be incorrect. Note that the CUR_AVG_CNT status register below gives an indication how many more scans need to be done to complete the Interleaved averaging.
            This bit can be cleared by changing the averaging mode to ACCUNDUMP or by disabling the SAR.</description>
            <name>INTRLV_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update.</description>
            <name>CUR_AVG_CNT</name>
          </field>
        </fields>
        <name>AVG_STAT</name>
        <resetMask>0xFF8FFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>SARMUX Firmware switch controls</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P0_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P1_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P2_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P3_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P4_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P5_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P6_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P7_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P0_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P1_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P2_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P3_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P4_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P5_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P6_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P7_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_VSSA_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit.</description>
            <name>MUX_FW_TEMP_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_AMUXBUSA_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_AMUXBUSB_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_AMUXBUSA_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_AMUXBUSB_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_SARBUS0_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_SARBUS1_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_SARBUS0_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
            <name>MUX_FW_SARBUS1_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P4_COREIO0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P5_COREIO1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P6_COREIO2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
            <name>MUX_FW_P7_COREIO3</name>
          </field>
        </fields>
        <name>MUX_SWITCH0</name>
        <resetMask>0x3FFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>SARMUX Firmware switch control clear</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P0_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P1_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P2_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P3_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P4_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P5_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P6_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P7_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P0_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P1_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P2_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P3_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P4_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P5_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P6_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P7_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_VSSA_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_TEMP_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSA_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSB_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSA_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSB_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS0_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS1_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS0_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS1_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P4_COREIO0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P5_COREIO1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P6_COREIO2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P7_COREIO3</name>
          </field>
        </fields>
        <name>MUX_SWITCH_CLEAR0</name>
        <resetMask>0x3FFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x340</addressOffset>
        <description>SARMUX switch DSI control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P0 switches</description>
            <name>MUX_DS_CTRL_P0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P1 switches</description>
            <name>MUX_DS_CTRL_P1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P2 switches</description>
            <name>MUX_DS_CTRL_P2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P3 switches</description>
            <name>MUX_DS_CTRL_P3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P4 switches</description>
            <name>MUX_DS_CTRL_P4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P5 switches</description>
            <name>MUX_DS_CTRL_P5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P6 switches</description>
            <name>MUX_DS_CTRL_P6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P7 switches</description>
            <name>MUX_DS_CTRL_P7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for vssa switch</description>
            <name>MUX_DS_CTRL_VSSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for temp switch</description>
            <name>MUX_DS_CTRL_TEMP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for amuxbusa switch</description>
            <name>MUX_DS_CTRL_AMUXBUSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for amuxbusb switches</description>
            <name>MUX_DS_CTRL_AMUXBUSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for sarbus0 switch</description>
            <name>MUX_DS_CTRL_SARBUS0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for sarbus1 switch</description>
            <name>MUX_DS_CTRL_SARBUS1</name>
          </field>
        </fields>
        <name>MUX_SWITCH_DS_CTRL</name>
        <resetMask>0xCF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x344</addressOffset>
        <description>SARMUX switch Sar Sequencer control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P0 switches</description>
            <name>MUX_SQ_CTRL_P0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P1 switches</description>
            <name>MUX_SQ_CTRL_P1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P2 switches</description>
            <name>MUX_SQ_CTRL_P2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P3 switches</description>
            <name>MUX_SQ_CTRL_P3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P4 switches</description>
            <name>MUX_SQ_CTRL_P4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P5 switches</description>
            <name>MUX_SQ_CTRL_P5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P6 switches</description>
            <name>MUX_SQ_CTRL_P6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for P7 switches</description>
            <name>MUX_SQ_CTRL_P7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for vssa switch</description>
            <name>MUX_SQ_CTRL_VSSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for temp switch</description>
            <name>MUX_SQ_CTRL_TEMP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for amuxbusa switch</description>
            <name>MUX_SQ_CTRL_AMUXBUSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for amuxbusb switches</description>
            <name>MUX_SQ_CTRL_AMUXBUSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for sarbus0 switch</description>
            <name>MUX_SQ_CTRL_SARBUS0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>for sarbus1 switch</description>
            <name>MUX_SQ_CTRL_SARBUS1</name>
          </field>
        </fields>
        <name>MUX_SWITCH_SQ_CTRL</name>
        <resetMask>0xCF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x348</addressOffset>
        <description>SARMUX switch status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P0_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P1_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P2_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P3_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P4_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P5_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P6_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P7_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P0_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P1_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P2_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P3_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P4_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P5_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P6_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_P7_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_VSSA_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_TEMP_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSA_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSB_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSA_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_AMUXBUSB_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS0_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS1_VPLUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS0_VMINUS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>switch status of corresponding bit in MUX_SWITCH0</description>
            <name>MUX_FW_SARBUS1_VMINUS</name>
          </field>
        </fields>
        <name>MUX_SWITCH_STATUS</name>
        <resetMask>0x3FFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Analog trim register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Attenuation cap trimming</description>
            <name>CAP_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attenuation cap trimming</description>
            <name>TRIMUNIT</name>
          </field>
        </fields>
        <name>ANA_TRIM0</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Analog trim register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>SAR Reference buffer trim</description>
            <name>SAR_REF_BUF_TRIM</name>
          </field>
        </fields>
        <name>ANA_TRIM1</name>
        <resetMask>0x3F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[0]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[1]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[2]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[3]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[4]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[5]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[6]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[7]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[8]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[9]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA8</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[10]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xAC</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[11]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB0</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[12]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB4</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[13]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB8</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[14]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xBC</addressOffset>
        <description>Channel configuration register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
            <name>POS_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB0</description>
                <name>CTB0</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB1</description>
                <name>CTB1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB2</description>
                <name>CTB2</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CTB3</description>
                <name>CTB3</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POS_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Differential enable for this channel.  
            If NEG_ADDR_EN=0 and this bit is 1 then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. In that case the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
            - 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
            - 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (if NEG_ADDR_EN=0 then POS_PIN_ADDR[0] is ignored).</description>
            <name>DIFFERENTIAL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
            <name>AVG_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
            <name>SAMPLE_TIME_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg pin to be sampled by this channel.</description>
            <name>NEG_PIN_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX pins.</description>
                <name>SARMUX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port2 (VPORT2)</description>
                <name>AROUTE_VIRT2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AROUTE virtual port1 (VPORT1)</description>
                <name>AROUTE_VIRT1</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SARMUX virtual port (VPORT0)</description>
                <name>SARMUX_VIRT</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>NEG_PORT_ADDR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
            <name>NEG_ADDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DSI data output enable for this channel.
            - 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
            - 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
            <name>DSI_OUT_EN</name>
          </field>
        </fields>
        <name>CHAN_CONFIG[15]</name>
        <resetMask>0x81773577</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x100</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[0]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x104</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[1]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x108</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[2]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10C</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[3]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x110</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[4]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x114</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[5]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x118</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[6]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x11C</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[7]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x120</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[8]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x124</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[9]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x128</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[10]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x12C</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[11]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x130</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[12]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x134</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[13]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x138</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[14]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x13C</addressOffset>
        <description>Channel working data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
            <name>WORK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_NEWVALUE register</description>
            <name>CHAN_WORK_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
            <name>CHAN_WORK_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_WORK[15]</name>
        <resetMask>0x88000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x180</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[0]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x184</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[1]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x188</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[2]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18C</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[3]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x190</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[4]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x194</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[5]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x198</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[6]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x19C</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[7]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1A0</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[8]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1A4</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[9]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1A8</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[10]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1AC</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[11]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1B0</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[12]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1B4</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[13]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1B8</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[14]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1BC</addressOffset>
        <description>Channel result data register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
            <name>RESULT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_NEWVALUE register</description>
            <name>CHAN_RESULT_NEWVALUE_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
            <name>SATURATE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
            <name>RANGE_INTR_MIR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
            <name>CHAN_RESULT_UPDATED_MIR</name>
          </field>
        </fields>
        <name>CHAN_RESULT[15]</name>
        <resetMask>0xE8000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x411F0000</baseAddress>
    <description>PASS top-level MMIO (DSABv2, INTR)</description>
    <interrupts></interrupts>
    <name>PASS</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt cause register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTB0 interrupt pending</description>
            <name>CTB0_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTB1 interrupt pending</description>
            <name>CTB1_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTB2 interrupt pending</description>
            <name>CTB2_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTB3 interrupt pending</description>
            <name>CTB3_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTDAC0 interrupt pending</description>
            <name>CTDAC0_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTDAC1 interrupt pending</description>
            <name>CTDAC1_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTDAC2 interrupt pending</description>
            <name>CTDAC2_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTDAC3 interrupt pending</description>
            <name>CTDAC3_INT</name>
          </field>
        </fields>
        <name>INTR_CAUSE</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>VREF Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>VREF_ABS_TRIM</name>
          </field>
        </fields>
        <name>VREF_TRIM0</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>VREF Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>VREF_TEMPCO_TRIM</name>
          </field>
        </fields>
        <name>VREF_TRIM1</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>VREF Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>VREF_CURV_TRIM</name>
          </field>
        </fields>
        <name>VREF_TRIM2</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0C</addressOffset>
        <description>VREF Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Obsolete</description>
            <name>VREF_ATTEN_TRIM</name>
          </field>
        </fields>
        <name>VREF_TRIM3</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF10</addressOffset>
        <description>IZTAT Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>N/A</description>
            <name>IZTAT_ABS_TRIM</name>
          </field>
        </fields>
        <name>IZTAT_TRIM0</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF14</addressOffset>
        <description>IZTAT Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IZTAT temperature correction trim (RMB)
            0x00 : No IZTAT temperature correction
            0xFF : Maximum IZTAT temperature correction
            
            As this is a Risk Mitigation Register, it should be loaded with 0x08.</description>
            <name>IZTAT_TC_TRIM</name>
          </field>
        </fields>
        <name>IZTAT_TRIM1</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF18</addressOffset>
        <description>IPTAT Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>IPTAT trim
            0x0 : Minimum IPTAT current (~150nA at room)
            0xF : Maximum IPTAT current (~350nA at room)</description>
            <name>IPTAT_CORE_TRIM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>CTMB PTAT Current Trim
            0x0 : Minimum CTMB IPTAT Current (~875nA)
            0xF : Maximum CTMB IPTAT Current (~1.1uA)</description>
            <name>IPTAT_CTBM_TRIM</name>
          </field>
        </fields>
        <name>IPTAT_TRIM0</name>
        <resetMask>0xFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF1C</addressOffset>
        <description>ICTAT Trim bits</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>ICTAT trim
            0x00 : Minimum ICTAT current (~150nA at room)
            0x0F : Maximum ICTAT current (~350nA at room)</description>
            <name>ICTAT_TRIM</name>
          </field>
        </fields>
        <name>ICTAT_TRIM0</name>
        <resetMask>0xF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x42A10000</baseAddress>
    <description>I2S registers</description>
    <interrupts></interrupts>
    <name>I2S0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the I2S TX component:
            '0': Disabled.
            '1': Enabled.</description>
            <name>TX_ENABLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the I2S RX component:
            '0': Disabled.
            '1': Enabled.</description>
            <name>RX_ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0xC0000000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Clock control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Frequency divisor for generating I2S clock frequency.
            The selected clock with CLOCK_SEL is divided by this. 
            '0': Bypass
            '1': 2 x
            '2': 3 x
            '3': 4 x
            ...
            '62': 63 x
            '63': 64 x</description>
            <name>CLOCK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects clock to be used by I2S:
            '0': Internal clock ('clk_audio_i2s')
            '1': External clock ('clk_i2s_if')</description>
            <name>CLOCK_SEL</name>
          </field>
        </fields>
        <name>CLOCK_CTL</name>
        <resetMask>0x13F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter enable:
            '0': Disabled.
            '1': Enabled.</description>
            <name>TX_START</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pause enable:
            '0': Disabled (TX FIFO data is sent over I2S).
            '1': Enabled ('0' data is sent over I2S, instead of TX FIFO data).</description>
            <name>TX_PAUSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver enable:
            '0': Disabled.
            '1': Enabled.</description>
            <name>RX_START</name>
          </field>
        </fields>
        <name>CMD</name>
        <resetMask>0x10101</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Trigger control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger output ('tr_i2s_tx_req') enable for requests of DMA transfer in transmission
            '0': Disabled.
            '1': Enabled.</description>
            <name>TX_REQ_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger output ('tr_i2s_rx_req') enable for requests of DMA transfer in reception
            '0': Disabled.
            '1': Enabled.</description>
            <name>RX_REQ_EN</name>
          </field>
        </fields>
        <name>TR_CTL</name>
        <resetMask>0x10001</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>Transmitter control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Serial data transmission is advanced by 0.5 SCK cycles. This bit is valid only in TX slave mode.
            When set to '1', the serial data will be transmitted 0.5 SCK cycles earlier than when set to '0'. 
            
            1) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK falling edge
            2) TX_CTL.SCKI_POL=0 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK rising edge that is 0.5 SCK cycles before the SCK falling edge in 1)
            3) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=0: Serial data will be transmitted off the SCK rising edge
            4) TX_CTL.SCKI_POL=1 and TX_CTL.B_CLOCK_INV=1: Serial data will be transmitted off the SCK falling edge that is 0.5 SCK cycles before the SCK rising edge in 3)
            
            (Note that this is only the appearance w.r.t. SCK edge, the actual timing is generated by an internal clock that runs 8x the SCK frequency). The word sync (TX_WS) signal is not affected by this bit setting. 
            Note: When Master mode, must be '0'.
            (Note: This bit is connected to AR38U12.TX_CFG.TX_BCLKINV)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SDO transmitted at SCK falling edge when TX_CTL.SCKI_POL=0</description>
                <name>FALLING_EDGE_TX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SDO transmitted at SCK rising edge when TX_CTL.SCKI_POL=0</description>
                <name>RISING_EDGE_TX</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>B_CLOCK_INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies number of channels per frame:
            
            Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.
            (Note: These bits are connected to AR38U12.TX_CFG.TX_CHSET)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 channel</description>
                <name>CH_NUM1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 channels</description>
                <name>CH_NUM2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 channels</description>
                <name>CH_NUM3</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 channels</description>
                <name>CH_NUM4</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 channels</description>
                <name>CH_NUM5</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 channels</description>
                <name>CH_NUM6</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 channels</description>
                <name>CH_NUM7</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 channels</description>
                <name>CH_NUM8</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH_NR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set interface in master or slave mode:
            
            (Note: This bit is connected to AR38U12.TX_CFG.TX_MS)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select I2S, left-justified or TDM:
            
            (Note: These bits are connected to AR38U12.TX_CFG.TX_I2S_MODE)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Left Justified</description>
                <name>LEFT_JUSTIFIED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2S mode</description>
                <name>I2S</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TDM mode A, the 1st Channel align to WSO 
                Rising Edge</description>
                <name>TDM_A</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TDM mode B, the 1st Channel align to WSO
                Rising edge with1 SCK Delay</description>
                <name>TDM_B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set WS pulse width in TDM mode:
            
            (Note: This bit is connected to AR38U12.TX_CFG.TX_WS_PULSE)
            Note: When not TDM mode, must be '1'.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pulse width is 1 SCK period</description>
                <name>SCK_PERIOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pulse width is 1 channel length</description>
                <name>CH_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WS_PULSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set overhead value:
            '0': Set to '0'
            '1': Set to '1'
            (Note: This bit is connected to AR38U12.TX_CFG.TX_OVHDATA)</description>
            <name>OVHDATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set watchdog for 'tx_ws_in':
            '0': Disabled.
            '1': Enabled.</description>
            <name>WD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Channel length in number of bits:
            
            Note: 
            - When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
            - When TDM mode, must be 32-bit length to this field.
            (Note: These bits are connected to AR38U12.TX_CFG.TX_CHLEN)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit</description>
                <name>BIT_LEN8</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit</description>
                <name>BIT_LEN16</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>18-bit</description>
                <name>BIT_LEN18</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20-bit</description>
                <name>BIT_LEN20</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>24-bit</description>
                <name>BIT_LEN24</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit</description>
                <name>BIT_LEN32</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Word length in number of bits:
            
            Note: 
            - When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
            - Don't configure this field as beyond Channel length.
            (Note: These bits are connected to AR38U12.TX_CFG.TX_IWL)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit</description>
                <name>BIT_LEN8</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit</description>
                <name>BIT_LEN16</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>18-bit</description>
                <name>BIT_LEN18</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20-bit</description>
                <name>BIT_LEN20</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>24-bit</description>
                <name>BIT_LEN24</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit</description>
                <name>BIT_LEN32</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WORD_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX master bit clock polarity. 
            When this bit is 1, the outgoing tx_sck signal is inverted after it has been transmitted from the I2S transceiver core. This bit does not affect the internal serial data transmission timing. The word sync (TX_WS) signal is not affected by this bit setting. 
            '0': When transmitter is in master mode, serial data is transmitted from the falling bit clock edge
            '1': When transmitter is in master mode, serial data is transmitted from the rising bit clock edge</description>
            <name>SCKO_POL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX slave bit clock polarity. 
            When this bit is 1, the incoming tx_sck signal is inverted before it is received by the I2S transceiver core. This bit does not affect the internal serial data transmission timing. The word sync (TX_WS) signal is not affected by this bit setting. See TX_CTL.B_CLOCK_INV for more details.</description>
            <name>SCKI_POL</name>
          </field>
        </fields>
        <name>TX_CTL</name>
        <resetMask>0x37737F8</resetMask>
        <resetValue>0x440510</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>Transmitter watchdog</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Start value of the TX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
            <name>WD_COUNTER</name>
          </field>
        </fields>
        <name>TX_WATCHDOG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>Receiver control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Serial data capture is delayed by 0.5 SCK cycles. This bit is valid only in RX master mode.
            When set to '1', the serial data will be captured 0.5 SCK cycles later than when set to '0'.
            
            1) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK rising edge
            2) RX_CTL.SCKO_POL=0 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK falling edge that is 0.5 SCK cycles after the SCK rising edge in 1)
            3) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=0: Serial data will be captured by the SCK falling edge
            4) RX_CTL.SCKO_POL=1 and RX_CTL.B_CLOCK_INV=1: Serial data will be captured by the SCK rising edge that is 0.5 SCK cycles after the SCK falling edge in 3)
            
            (Note that this is only the appearance w.r.t. SCK edge, the actual capture timing is derived from an internal clock that runs 8x the SCK frequency). The word sync (RX_WS) signal is not affected by this bit setting. 
            Note: When Slave mode, must be '0'.
            (Note: This bit is connected to AR38U12.TX_CFG.RX_BCLKINV)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SDI received at SCK rising edge when RX_CTL.SCKO_POL=0</description>
                <name>RISING_EDGE_RX</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SDI received at SCK falling edge when RX_CTL.SCKO_POL=0</description>
                <name>FALLING_EDGE_RX</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>B_CLOCK_INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies number of channels per frame:
            
            Note: only '2channels' is supported during Left Justfied or I2S mode. Hence software must set '1' to this field in the modes.
            (Note: These bits are connected to AR38U12.RX_CFG.RX_CHSET)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 channel</description>
                <name>CH_NUM1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 channels</description>
                <name>CH_NUM2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 channels</description>
                <name>CH_NUM3</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 channels</description>
                <name>CH_NUM4</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 channels</description>
                <name>CH_NUM5</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 channels</description>
                <name>CH_NUM6</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 channels</description>
                <name>CH_NUM7</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 channels</description>
                <name>CH_NUM8</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH_NR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set interface in master or slave mode:
            
            (Note: This bit is connected to AR38U12.TX_CFG.RX_MS)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave</description>
                <name>SLAVE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master</description>
                <name>MASTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Select I2S, left-justified or TDM:
            
            (Note: These bits are connected to AR38U12.RX_CFG.RX_I2S_MODE)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Left Justified</description>
                <name>LEFT_JUSTIFIED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>I2S mode</description>
                <name>I2S</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TDM mode A, the 1st Channel align to WSO 
                Rising Edge</description>
                <name>TDM_A</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>TDM mode B, the 1st Channel align to WSO
                Rising edge with1 SCK Delay</description>
                <name>TDM_B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set WS pulse width in TDM mode:
            
            (Note: This bit is connected to AR38U12.RX_CFG.RX_WS_PULSE)
            Note: When not TDM mode, must be '1'.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pulse width is 1 SCK period</description>
                <name>SCK_PERIOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pulse width is 1 channel length</description>
                <name>CH_LENGTH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WS_PULSE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set watchdog for 'rx_ws_in'
            '0': Disabled.
            '1': Enabled.</description>
            <name>WD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Channel length in number of bits:
            
            Note: 
            - When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
            - When TDM mode, must be 32-bit length to this field.
            (Note: These bits are connected to AR38U12.RX_CFG.RX_CHLEN)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit</description>
                <name>BIT_LEN8</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit</description>
                <name>BIT_LEN16</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>18-bit</description>
                <name>BIT_LEN18</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20-bit</description>
                <name>BIT_LEN20</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>24-bit</description>
                <name>BIT_LEN24</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit</description>
                <name>BIT_LEN32</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CH_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Word length in number of bits:
            
            Note: 
            - When this field is configured to '6' or '7', the length is set to 32-bit (same as '5').
            - Don't configure this field as beyond Channel length.
            (Note: These bits are connected to AR38U12.RX_CFG.RX_IWL)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>8-bit</description>
                <name>BIT_LEN8</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit</description>
                <name>BIT_LEN16</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>18-bit</description>
                <name>BIT_LEN18</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20-bit</description>
                <name>BIT_LEN20</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>24-bit</description>
                <name>BIT_LEN24</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>32-bit</description>
                <name>BIT_LEN32</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WORD_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When reception word length is shorter than the word length of RX_FIFO_RD, extension mode of upper bit should be set.
            '0': Extended by '0'
            '1': Extended by sign bit (if MSB word is '1', then it is extended by '1', if MSB is '0' then it is extended by '0')</description>
            <name>BIT_EXTENSION</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX master bit clock polarity.
            When this bit is 1, the outgoing rx_sck signal is inverted after it has been transmitted from the I2S receiver core. This bit does not affect the internal serial data capture timing. The word sync (RX_WS) signal is not affected by this bit setting.See RX_CTL.B_CLOCK_INV for more details.</description>
            <name>SCKO_POL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX slave bit clock polarity.
            When this bit is 1, the incoming rx_sck signal is inverted before it is received by the I2S receiver core. This bit does not affect the internal serial data capture timing. The word sync (RX_WS) signal is not affected by this bit setting.
            '0': When receiver is in slave mode, serial data is sampled on the rising bit clock edge
            '1': When receiver is in slave mode, serial data is sampled on the falling bit clock edge</description>
            <name>SCKI_POL</name>
          </field>
        </fields>
        <name>RX_CTL</name>
        <resetMask>0x3F727F8</resetMask>
        <resetValue>0x440510</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>Receiver watchdog</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Start value of the RX watchdog. With the reset value of 0x0000:0000 the counter is disabled. This is clocked by the AHB-Lite system clock 'clk_sys'.</description>
            <name>WD_COUNTER</name>
          </field>
        </fields>
        <name>RX_WATCHDOG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>TX FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated.</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the TX FIFO and TX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware reads from the TX FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer. This field is used only for debugging purposes.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>TX_FIFO_CTL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x204</addressOffset>
        <description>TX FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Number of entries in the TX FIFO. The field value is in the range [0, 256].</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX FIFO read pointer: FIFO location from which a data frame is read by the hardware.This field is used only for debugging purposes.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX FIFO write pointer: FIFO location at which a new data frame is written by the host. This field is used only for debugging purposes.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>TX_FIFO_STATUS</name>
        <resetMask>0xFFFF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x208</addressOffset>
        <description>TX FIFO write</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data written into the TX FIFO. Behavior is similar to that of a PUSH operation. 
            Note: Don't access to this register while TX_FIFO_CTL.CLEAR is '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TX_FIFO_WR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>RX FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
            Note: software can configure up to 253 in I2S mode or Left Justified (RX_CTL.I2S_MODE = '0' or '1'). In TDM mode (RX_CTL.I2S_MODE = '2' or '3'), it can configure up to [256 - (RX_CTL.CH_NR+2)].</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the RX FIFO and RX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the RX FIFO have no effect. Freeze will not advance the RX FIFO write pointer. This field is used only for debugging purposee.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x304</addressOffset>
        <description>RX FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Number of entries in the RX FIFO. The field value is in the range [0, 256].</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX FIFO read pointer: FIFO location from which a data frame is read by the host. This field is used only for debugging purposes.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX FIFO write pointer: FIFO location at which a new data frame is written by the hardware. This field is used only for debugging purposes.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF01FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>RX FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data read from the RX FIFO. Reading a data frame will remove the data frame from the RX FIFO; i.e. behavior is similar to that of a POP operation. 
            Notes: 
             - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
             - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30C</addressOffset>
        <description>RX FIFO silent read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data read from the RX FIFO. Reading a data frame will NOT remove the data frame from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. This field is used only for debugging purposes.
            Notes: 
             - Don't access to this register while RX_FIFO_CTL.CLEAR is '1'. 
             - Two stored data may be not valid after CMD.RX_START is set '1'. Therefore we recommend software discard those data.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Interrupt register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Less entries in the TX FIFO than the value specified by TRIGGER_LEVEL in TX_FIFO_CTRL.</description>
            <name>TX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX FIFO is not full.</description>
            <name>TX_NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX FIFO is empty; i.e. it has 0 entries.</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to write to a full TX FIFO.</description>
            <name>TX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty TX FIFO. This happens when the IP is ready to transfer data and TX_EMPTY is '1'.</description>
            <name>TX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Triggers (sets to '1') when the Tx watchdog event occurs.</description>
            <name>TX_WD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in RX_FIFO_CTRL.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX FIFO is not empty.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX FIFO is full.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to write to a full RX FIFO.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty RX FIFO.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Triggers (sets to '1') when the Rx watchdog event occurs.</description>
            <name>RX_WD</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x16D0173</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Interrupt set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>TX_WD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_WD</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x16D0173</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Interrupt mask register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>TX_WD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_WD</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x16D0173</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Interrupt masked register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_NOT_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>TX_WD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_WD</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x16D0173</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1000</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x42A20000</baseAddress>
    <description>PDM registers</description>
    <interrupts></interrupts>
    <name>PDM0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Right channel PGA gain:
            +1.5dB/step, -12dB ~ +10.5dB
            '0': -12 dB
            '1': -10.5 dB 
            ...
            '15' +10.5 dB
            (Note: These bits are connected to AR36U12.PDM_CORE_CFG.PGA_R)</description>
            <name>PGA_R</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Left channel PGA gain:
            +1.5dB/step, -12dB ~ +10.5dB
            '0': -12 dB
            '1': -10.5 dB 
            ...
            '15': +10.5 dB
            (Note: These bits are connected to AR36U12.PDM_CORE_CFG.PGA_L)</description>
            <name>PGA_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Soft mute function to mute the volume smoothly
            '0': Disabled.
            '1': Enabled.
            (Note: This bit is connected to AR36U12.PDM_CORE_CFG.SOFT_MUTE)</description>
            <name>SOFT_MUTE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set fine gain step for smooth PGA or Soft-Mute attenuation transition.
            '0': 0.13dB
            '1': 0.26dB
            (Note: This bit is connected to AR36U12.PDM_CORE2_CFG.SEL_STEP)</description>
            <name>STEP_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the PDM component:
            '0': Disabled.
            '1': Enabled.</description>
            <name>ENABLED</name>
          </field>
        </fields>
        <name>CTL</name>
        <resetMask>0x80030F0F</resetMask>
        <resetValue>0x20808</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Clock control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDM CLK (FPDM_CLK) (1st divider):
            This configures a frequency of PDM CLK. The configured frequency is used to operate PDM core. I.e. the frequency is input to MCLKQ_CLOCK_DIV register.
            
            Note: configure a frequency of PDM CLK as lower than or equal 50MHz with this divider.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 1</description>
                <name>DIVBY1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 2 (no 50 percent duty cycle)</description>
                <name>DIVBY2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 3 (no 50 percent duty cycle)</description>
                <name>DIVBY3</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 4 (no 50 percent duty cycle)</description>
                <name>DIVBY4</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_CLOCK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>MCLKQ divider (2nd divider)
            
            (Note: These bits are connected to 
            AR36U12.PDM_CORE2_CFG.DIV_MCLKQ)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 1</description>
                <name>DIVBY1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 2 (no 50 percent duty cycle)</description>
                <name>DIVBY2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 3 (no 50 percent duty cycle)</description>
                <name>DIVBY3</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divide by 4 (no 50 percent duty cycle)</description>
                <name>DIVBY4</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MCLKQ_CLOCK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDM CKO (FPDM_CKO) clock divider (3rd divider):
            FPDM_CKO = MCLKQ / (CKO_CLOCK_DIV + 1)
            
            Note: To configure '0' to this field is prohibited.
            (Note: PDM_CKO is configured by MCLKQ_CLOCK_DIV,  CLK_CLOCK_DIV and CKO_CLOCK_DIV. )
            (Note: These bits are connected to 
            AR36U12.PDM_CORE_CFG.MCLKDIV)</description>
            <name>CKO_CLOCK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>SINC Decimation Rate. For details, see the data sheet provided by Archband.
            Oversampling Ratio = Decimation Rate = 2 X SINC_RATE
            (Note: These bits are connected to AR36U12.PDM_CORE_CFG.SINC_RATE)</description>
            <name>SINC_RATE</name>
          </field>
        </fields>
        <name>CLOCK_CTL</name>
        <resetMask>0x7F0F33</resetMask>
        <resetValue>0x200310</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Mode control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Specifies PCM output channels as mono or stereo:
            
            (Note: These bits are connected to AR36U12.PDM_CORE2_CFG.PCM_CHSET)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Channel disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mono left channel enable</description>
                <name>MONO_L</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Mono right channel enable</description>
                <name>MONO_R</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stereo channel enable</description>
                <name>STEREO</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PCM_CH_SET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input data L/R channel swap:
            '1': Right/Left channel recording swap
            '0': No Swap
            (Note: This bit is connected to AR36U12.PDM_CORE_CFG.LRSWAP)</description>
            <name>SWAP_LR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Set time step for gain change during PGA or soft mute operation in
            number of 1/a sampling rate.
            (Note: These bits are connected to AR36U12.PDM_CORE_CFG.S_CYCLES)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>64steps</description>
                <name>STEP_NUM64</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>96steps</description>
                <name>STEP_NUM96</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>128steps</description>
                <name>STEP_NUM128</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>160steps</description>
                <name>STEP_NUM160</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>192steps</description>
                <name>STEP_NUM192</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>256steps</description>
                <name>STEP_NUM256</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>384steps</description>
                <name>STEP_NUM384</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>512steps</description>
                <name>STEP_NUM512</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_CYCLES</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Phase difference from the rising edge of internal sampler clock (CLK_IS) to that of PDM_CKO clock:
            
            (Note: These bits are connected to AR36U12.PDM_CORE2_CFG.PDMCKO_DLY)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 3*PDM_CLK period early</description>
                <name>ADV3</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 2*PDM_CLK period early</description>
                <name>ADV2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 1*PDM_CLK period early</description>
                <name>ADV1</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is the same as PDM_CKO</description>
                <name>NO_DELAY</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 1*PDM_CLK period late</description>
                <name>DLY1</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 2*PDM_CLK period late</description>
                <name>DLY2</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 3*PDM_CLK period late</description>
                <name>DLY3</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLK_IS is 4*PDM_CLK period late</description>
                <name>DLY4</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CKO_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Adjust high pass filter coefficients. 
            H(Z) = (1 - Z-1 ) / [1 - (1- 2 -HPF_GAIN) Z-1 ]
            (Note: These bits are connected to AR36U12.PDM_CORE_CFG.HPGAIN)</description>
            <name>HPF_GAIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable high pass filter (active low)
            '1': Disabled.
            '0': Enabled.
            (Note: This bit is connected to AR36U12.PDM_CORE_CFG.ADCHPD)</description>
            <name>HPF_EN_N</name>
          </field>
        </fields>
        <name>MODE_CTL</name>
        <resetMask>0x1F070707</resetMask>
        <resetValue>0x1B000103</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Data control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PCM Word Length in number of bits:
            
            (Note: These bits are connected to AR36U12.PDM_CORE2_CFG.PCM_IWL)</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>16-bit</description>
                <name>BIT_LEN16</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>18-bit</description>
                <name>BIT_LEN18</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20-bit</description>
                <name>BIT_LEN20</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>24-bit</description>
                <name>BIT_LEN24</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WORD_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When reception word length is shorter than the word length of RX_FIFO_RD, extension mode of upper bit should be set.
            '0': Extended by '0'
            '1': Extended by sign bit (if MSB word is '1', then it is extended by '1', if MSB is '0' then it is extended by '0')</description>
            <name>BIT_EXTENSION</name>
          </field>
        </fields>
        <name>DATA_CTL</name>
        <resetMask>0x103</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Command</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable data streaming flow:
            '0': Disabled.
            '1': Enabled.
            (Note: This bit is connected to AR36U12.PDM_CORE_CFG.PDMA_EN)</description>
            <name>STREAM_EN</name>
          </field>
        </fields>
        <name>CMD</name>
        <resetMask>0x1</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Trigger control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trigger output ('tr_pdm_rx_req') enable for requests of DMA transfer
            '0': Disabled.
            '1': Enabled.</description>
            <name>RX_REQ_EN</name>
          </field>
        </fields>
        <name>TR_CTL</name>
        <resetMask>0x10000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>RX FIFO control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Trigger level. When the RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
            Note: software can configure up to 254 in Mono channel enabled (MODE_CTL.PCM_CH_SET = '1' or '2'), up to 253 in Stereo channel enabled (MODE_CTL.PCM_CH_SET = '3').</description>
            <name>TRIGGER_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', the RX FIFO and RX_BUF are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
            <name>CLEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When '1', hardware writes to the RX FIFO have no effect. Freeze will not advance the RX FIFO write pointer.This field is used only for debugging purposes.</description>
            <name>FREEZE</name>
          </field>
        </fields>
        <name>RX_FIFO_CTL</name>
        <resetMask>0x300FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x304</addressOffset>
        <description>RX FIFO status</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Number of entries in the RX FIFO. The field value is in the range [0, 255]. When this is zero, the RX FIFO is empty.</description>
            <name>USED</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX FIFO read pointer: RX FIFO location from which a data frame is read by the host.This field is used only for debugging purposes.</description>
            <name>RD_PTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>RX FIFO write pointer: RX FIFO location at which a new data frame is written by the hardware.This field is used only for debugging purposes.</description>
            <name>WR_PTR</name>
          </field>
        </fields>
        <name>RX_FIFO_STATUS</name>
        <resetMask>0xFFFF00FF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x308</addressOffset>
        <description>RX FIFO read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data read from the RX FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. 
            Note: Don't access to this bit while RX_FIFO_CTL.CLEAR is '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30C</addressOffset>
        <description>RX FIFO silent read</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data read from the RX FIFO. Reading a data frame will NOT remove the data frame from the RX FIFO; i.e. behavior is similar to that of a PEEK operation. This field is used only for debugging purposes.
            Note: Don't access to this bit while RX_FIFO_CTL.CLEAR is '1'.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>RX_FIFO_RD_SILENT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF00</addressOffset>
        <description>Interrupt register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>More entries in the RX FIFO than the value specified by TRIGGER_LEVEL in RX_FIFO_CTL.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX FIFO is not empty.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to write to a full RX FIFO</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Attempt to read from an empty RX FIFO</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR</name>
        <resetMask>0x650000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF04</addressOffset>
        <description>Interrupt set register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write with '1' to set corresponding bit in interrupt request register.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR_SET</name>
        <resetMask>0x650000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF08</addressOffset>
        <description>Interrupt mask register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask bit for corresponding bit in interrupt request register.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR_MASK</name>
        <resetMask>0x650000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF0C</addressOffset>
        <description>Interrupt masked register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_TRIGGER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_NOT_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_OVERFLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Logical and of corresponding request and mask bits.</description>
            <name>RX_UNDERFLOW</name>
          </field>
        </fields>
        <name>INTR_MASKED</name>
        <resetMask>0x650000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0xFFFFFFFF</resetMask>
    <resetValue>0x0</resetValue>
  </peripheral>
</peripherals>
<resetMask>0xFFFFFFFF</resetMask>
<resetValue>0x0</resetValue>
<vendor>Cypress Semiconductor</vendor>
<vendorId>Cypress</vendorId>
<version>1.0</version>
<width>0x20</width></device>
<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd"><access>read-write</access>
<addressUnitBits>0x8</addressUnitBits>
<cpu>
  <dcachePresent>
    <dcachePresen></dcachePresen>
  </dcachePresent>
  <dtcmPresent>
    <dtcmPresen></dtcmPresen>
  </dtcmPresent>
  <icachePresent>
    <icachePresen></icachePresen>
  </icachePresent>
  <itcmPresent>
    <itcmPresen></itcmPresen>
  </itcmPresent>
</cpu>
<description>M05x_registers Microcontroller dummy device</description>
<name>M05x_registers</name>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x38</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400E0000</baseAddress>
    <description>Registers group</description>
    <groupName>ADC</groupName>
    <interrupts></interrupts>
    <name>ADC</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>A/D Data Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>A/D Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>A/D Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>A/D Data Register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>A/D Data Register 4</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>A/D Data Register 5</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>A/D Data Register 6</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>A/D Data Register 7</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>A/D Conversion Result
                        This field contains 12 bits conversion result.</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>A/D Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Converter Enable
                        1 = Enable
                        0 = Disable
                        Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.</description>
            <name>ADEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Interrupt Enable
                        1 = Enable A/D interrupt function
                        0 = Disable A/D interrupt function
                        A/D conversion end interrupt request is generated if ADIE bit is set to 1.</description>
            <name>ADIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>A/D Converter Operation Mode
                        00 = Single conversion
                        01 = Burst conversion
                        10 = Single-cycle scan
                        11 = Continuous scan
                        When changing the operation mode, software should disable ADST bit firstly.
                        Note: In Burst Mode, the A/D result data always at Data Register 0.</description>
            <name>ADMD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Hardware Trigger Source
                        00 = A/D conversion is started by external STADC pin.
                        Others = Reserved
                        Software should disable TRGE and ADST before change TRGS. 
                        In hardware trigger mode, the ADST bit is set by the external trigger from STADC.</description>
            <name>TRGS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Trigger Condition
                        These two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state.
                        00 = Low level
                        01 = High level
                        10 = Falling edge
                        11 = Rising edge</description>
            <name>TRGCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Trigger Enable
                        Enable or disable triggering of A/D conversion by external STADC pin.
                        1= Enable
                        0= Disable</description>
            <name>TRGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Differential Input Mode Enable
                        1 = A/D is in differential analog input mode
                        0 = A/D is in single-end analog input mode
                        Differential input voltage (Vdiff) = Vplus - Vminus
                        The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin.
                        The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin.
                        The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin.
                        The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin.
                        In differential input mode, only one of the two corresponding channels needs to be enabled in ADCHER. The conversion result will be placed to the corresponding data register of the enabled channel. If both channels of a differential input paired channel are enabled, the ADC will convert it twice in scan mode. And then write the conversion result to the two corresponding data registers.</description>
            <name>DIFFEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Conversion Start
                        1 = Conversion start.
                        0 = Conversion stopped and A/D converter enter idle state.
                        ADST bit can be controlled by two sources: software write and external pin STADC. ADST is cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode on specified channels. In continuous scan mode, A/D conversion is continuously performed sequentially until this bit is cleared to 0 or chip reset.</description>
            <name>ADST</name>
          </field>
        </fields>
        <name>ADCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>A/D Channel Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 0 Enable
                        1 = Enable
                        0 = Disable
                        This channel is the default enabled channel if CHEN0~7 are set as 0s.</description>
            <name>CHEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 1 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 2 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 3 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 4 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 5 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 6 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 7 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Analog Input Channel 7 select
                        00: External analog input
                        01: Internal bandgap voltage
                        1x: Reserved</description>
            <name>PRESEL</name>
          </field>
        </fields>
        <name>ADCHER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>A/D Compare Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Enable
                        1 = Enable compare.
                        0 = Disable compare.
                        Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.</description>
            <name>CMPEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Interrupt Enable
                        1 = Enable compare function interrupt.
                        0 = Disable compare function interrupt.
                        If the compare function is enabled and the compare condition matches the settings of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted. If CMPIE is set to 1, a compare interrupt request is generated.</description>
            <name>CMPIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Condition
                        1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will increase one.
                        0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD(ADCMPR0[27:16]), the internal match counter will increase one.
                        Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit will be set.</description>
            <name>CMPCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Compare Channel Selection
                        000 = Channel 0 conversion result is selected to be compared.
                        001 = Channel 1 conversion result is selected to be compared.
                        010 = Channel 2 conversion result is selected to be compared.
                        011 = Channel 3 conversion result is selected to be compared.
                        100 = Channel 4 conversion result is selected to be compared.
                        101 = Channel 5 conversion result is selected to be compared.
                        110 = Channel 6 conversion result is selected to be compared.
                        111 = Channel 7 conversion result is selected to be compared.</description>
            <name>CMPCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Compare Match Count
                        When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit will be set.</description>
            <name>CMPMATCNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Comparison Data
                        The 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.</description>
            <name>CMPD</name>
          </field>
        </fields>
        <name>ADCMPR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>A/D Compare Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Enable
                        1 = Enable compare.
                        0 = Disable compare.
                        Set this bit to 1 to enable compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.</description>
            <name>CMPEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Interrupt Enable
                        1 = Enable compare function interrupt.
                        0 = Disable compare function interrupt.
                        If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF1 bit will be asserted. If CMPIE is set to 1, a compare interrupt request is generated.</description>
            <name>CMPIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Condition
                        1= Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD(ADCMPR1[27:16]), the internal match counter will increase one.
                        0= Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD(ADCMPR1[27:16]), the internal match counter will increase one.
                        Note: When the internal counter reaches the value to (CMPMATCNT +1), the CMPF1 bit will be set.</description>
            <name>CMPCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Compare Channel Selection
                        000 = Channel 0 conversion result is selected to be compared.
                        001 = Channel 1 conversion result is selected to be compared.
                        010 = Channel 2 conversion result is selected to be compared.
                        011 = Channel 3 conversion result is selected to be compared.
                        100 = Channel 4 conversion result is selected to be compared.
                        101 = Channel 5 conversion result is selected to be compared.
                        110 = Channel 6 conversion result is selected to be compared.
                        111 = Channel 7 conversion result is selected to be compared.</description>
            <name>CMPCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Compare Match Count
                        When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF1 bit will be set.</description>
            <name>CMPMATCNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Comparison Data
                        The 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.</description>
            <name>CMPD</name>
          </field>
        </fields>
        <name>ADCMPR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>A/D Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Conversion End Flag
                        A status flag that indicates the end of A/D conversion.
                        ADF is set to 1 at these two conditions:
                        When A/D conversion ends in single mode
                        When A/D conversion ends on all specified channels in scan mode.
                        When more than 4 samples in FIFO in Burst mode.
                        This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ADF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Flag
                        When the selected channel A/D conversion result meets the setting conditions of ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
                        1 = Conversion result in ADDR meets ADCMPR0 setting
                        0 = Conversion result in ADDR does not meet ADCMPR0 setting</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CMPF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Flag
                        When the selected channel A/D conversion result meets the setting conditions of ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
                        1 = Conversion result in ADDR meets ADCMPR1 setting
                        0 = Conversion result in ADDR does not meet ADCMPR1 setting</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CMPF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BUSY/IDLE
                        1 = A/D converter is busy at conversion.
                        0 = A/D converter is in idle state.
                        This bit is mirror of as ADST bit in ADCR.
                        It is read only.</description>
            <name>BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Current Conversion Channel
                        This filed reflects current conversion channel when BUSY=1. When BUSY=0, it shows the next channel will be converted.
                        It is read only.</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data Valid flag
                        It is a mirror of VALID bit in ADDRx
                        When ADC is in Burst Mode, and there is at least one valid conversion result in buffer, VALID[7:0] will all set to 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Over Run flag
                        It is a mirror to OVERRUN bit in ADDRx
                        When ADC is in Burst Mode, and the buffer is overrun, OVERRUN[7:0] will all set to 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>OVERRUN</name>
          </field>
        </fields>
        <name>ADSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>A/D Calibration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Self Calibration Enable
                        1 = Enable self calibration
                        0 = Disable self calibration
                        Software can set this bit to 1 enables A/D converter to do self calibration function. It needs 127 ADC clocks to complete calibration. This bit must be kept at 1 after CALDONE asserted. Clearing this bit will disable self calibration function.</description>
            <name>CALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Calibration is Done
                        1 = A/D converter self calibration is done.
                        0 = A/D converter has not been calibrated or calibration is in progress if CALEN bit is set.
                        When 0 is written to CALEN bit, CALDONE bit is cleared by hardware immediately. It is a read only bit.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CALDONE</name>
          </field>
        </fields>
        <name>ADCALR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000200</baseAddress>
    <description>Registers group</description>
    <groupName>CLK</groupName>
    <interrupts></interrupts>
    <name>CLK</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>System Power Down Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Crystal Oscillator Control
                        The bit default value is set by flash controller user configuration register config0 [26:24]. When the default clock source is from external crystal. The bit is auto set to "1"
                        1 = Crystal oscillation enable 
                        0 = Crystal oscillation disable </description>
            <name>XTL12M_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Internal 22.1184 MHz Oscillator Control
                        1 = 22.1184 MHz Oscillation enable 
                        0 = 22.1184 MHz Oscillation disable </description>
            <name>OSC22M_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Internal 10KHz Oscillator Control
                        1 = 10KHz Oscillation enable 
                        0 = 10KHz Oscillation disable </description>
            <name>OSC10K_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the wake up delay counter.
                        When the chip wakes up from power down mode, the clock control will delay certain clock cycles to wait system clock stable.
                        The delayed clock cycle is 4096 clock cycles when chip work at external crystal (4 ~ 24MHz), and 256 clock cycles when chip work at 22.1184 MHz oscillator.
                        1 = Enable the clock cycle delay
                        0 = Disable the clock cycle delay</description>
            <name>PD_WU_DLY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Power down mode wake Up Interrupt Enable
                        0 = Disable
                        1 = Enable. The interrupt will occur when Power down mode (Deep Sleep Mode) wakeup.</description>
            <name>PD_WU_INT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Chip power down wake up status flag
                        Set by "power down wake up", it indicates that resume from power down mode 
                        The flag is set if the GPIO(P0~P4), UART wakeup
                        Write 1 to clear the bit 
                        Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. </description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PD_WU_STS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System power down enable bit
                        When set this bit "1", the chip power down mode is enabled and the chip power down active is depend on the PD_WAIT_CPU bit
                        (a) if the PD_WAIT_CPU is "0" then the chip power down after the PWR_DOWN_EN bit set.
                        (b) if the PD_WAIT_CPU is "1" then the chip keep active till the CPU sleep mode also active and then the chip power down
                        When chip wake up from power down, this bit is auto cleared, user need to set this bit again for next power down.
                        When in power down mode, external crystal (4~ 24MHz) and the 22.1184 MHz OSC will be disabled in this mode, but the 10 kHz OSC is not controlled by power down mode. 
                        When in power down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by power down mode, if the peripheral clock source is from 10 kHz oscillator.
                        1 = Chip enter the power down mode instant or wait CPU sleep command WFI
                        0 = Chip operate in normal mode or CPU in idle mode (sleep mode) because of WFI command</description>
            <name>PWR_DOWN_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit control the power down entry condition
                        1 = Chip entry power down mode when the both PWR_DOWN and CPU run WFI instruction.
                        0 = Chip entry power down mode when the PWR_DOWN bit is set to 1</description>
            <name>PD_WAIT_CPU</name>
          </field>
        </fields>
        <name>PWRCON</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>AHB Devices Clock Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash ISP Controller Clock Enable Control.
                        1 = To enable the Flash ISP controller clock.
                        0 = To disable the Flash ISP controller clock.</description>
            <name>ISP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI Controller Clock Enable Control.
                        1 = To enable the EBI Controller clock.
                        0 = To disable the EBI Controller clock.</description>
            <name>EBI_EN</name>
          </field>
        </fields>
        <name>AHBCLK</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>APB Devices Clock Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watch Dog Timer Clock Enable.
                        This bit is the protected bit, program this need a open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        0 = Disable Watchdog Timer Clock
                        1 = Enable Watchdog Timer Clock</description>
            <name>WDT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer0 Clock Enable Control
                        0 = Disable Timer0 Clock
                        1 = Enable Timer0 Clock</description>
            <name>TMR0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer1 Clock Enable Control
                        0 = Disable Timer1 Clock
                        1 = Enable Timer1 Clock</description>
            <name>TMR1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer2 Clock Enable Control
                        0 = Disable Timer2 Clock
                        1 = Enable Timer2 Clock</description>
            <name>TMR2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer3 Clock Enable Control
                        0 = Disable Timer3 Clock
                        1 = Enable Timer3 Clock</description>
            <name>TMR3_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Divider Clock Enable Control
                        0 = Disable FDIV Clock
                        1 = Enable FDIV Clock</description>
            <name>FDIV_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C Clock Enable Control. 
                        0 = Disable I2C Clock
                        1 = Enable I2C Clock</description>
            <name>I2C_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 Clock Enable Control. 
                        0 = Disable SPI0 Clock
                        1 = Enable SPI0 Clock</description>
            <name>SPI0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 Clock Enable Control. 
                        0 = Disable SPI1 Clock
                        1 = Enable SPI1 Clock</description>
            <name>SPI1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART0 Clock Enable Control.
                        1 = Enable UART0 clock
                        0 = Disable UART0 clock</description>
            <name>UART0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART1 Clock Enable Control.
                        1 = Enable UART1 clock
                        0 = Disable UART1 clock</description>
            <name>UART1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_01 Clock Enable Control.
                        1 = Enable PWM01 clock
                        0 = Disable PWM01 clock</description>
            <name>PWM01_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_23 Clock Enable Control.
                        1 = Enable PWM23 clock
                        0 = Disable PWM23 clock</description>
            <name>PWM23_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_45 Clock Enable Control.
                        1 = Enable PWM45 clock
                        0 = Disable PWM45 clock</description>
            <name>PWM45_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_67 Clock Enable Control.
                        1 = Enable PWM67 clock
                        0 = Disable PWM67 clock</description>
            <name>PWM67_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog-Digital-Converter (ADC) Clock Enable Control.
                        1 = Enable ADC clock
                        0 = Disable ADC clock</description>
            <name>ADC_EN</name>
          </field>
        </fields>
        <name>APBCLK</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Clock status monitor Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>XTL12M clock source stable flag
                        1 = External Crystal clock is stable
                        0 = External Crystal clock is not stable or not enable</description>
            <name>XTL12M_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL clock source stable flag
                        1 = PLL clock is stable
                        0 = PLL clock is not stable or not enable</description>
            <name>PLL_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>OSC10K clock source stable flag
                        1 = OSC10K clock is stable
                        0 = OSC10K clock is not stable or not enable</description>
            <name>OSC10K_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>OSC22M clock source stable flag
                        1 = OSC22M clock is stable
                        0 = OSC22M clock is not stable or not enable</description>
            <name>OSC22M_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock switch fail flag
                        1 = Clock switch fail
                        0 = Clock switch success
                        This bit will be set when target switch clock source is not stable. Write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLK_SW_FAIL</name>
          </field>
        </fields>
        <name>CLKSTATUS</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Clock Source Select Control Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HCLK clock source select.
                        Note:
                        Before clock switch the related clock sources (pre-select and new-select) must be turn on
                        The 3-bit default value is reloaded with the value of Config0.CFOSC[26:24] in user configuration register in Flash controller by any reset. Therefore the default value is either 000b or 111b.
                        These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        000 = clock source from external crystal clock (4 ~ 24MHz)
                        010 = clock source from PLL clock
                        011 = clock source from internal 10KHz oscillator clock
                        111 = clock source from internal 22.1184 MHz oscillator clock
                        others = Reserved</description>
            <name>HCLK_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>MCU Cortex_M0 SysTick clock source select.
                        These bits are protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        000 = Clock source from external crystal clock (4 ~ 24MHz)
                        010 = Clock source from external crystal clock (4 ~ 24MHz)/2
                        011 = clock source from HCLK/2
                        1xx = clock source from internal 22.1184 MHz oscillator clock/2</description>
            <name>STCLK_S</name>
          </field>
        </fields>
        <name>CLKSEL0</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Clock Source Select Control Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Watchdog Timer clock source select.
                        These bits are protected bit, program this need a open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        00 = clock source from external crystal clock (4 ~ 24MHz).
                        10 = clock source from HCLK/2048 clock
                        11 = clock source from internal 10KHz oscillator clock</description>
            <name>WDT_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>ADC clock source select.
                        00 = clock source from external crystal clock (4 ~ 24MHz).
                        01 = clock source from PLL clock
                        1x = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>ADC_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER0 clock source select.
                        000 = clock source from external crystal clock (4 ~ 24MHz)
                        010 = clock source from HCLK
                        011 = clock source from external trigger
                        1xx = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>TMR0_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER1 clock source select.
                        000 = clock source from external crystal clock (4 ~ 24MHz)
                        010 = clock source from HCLK
                        011 = clock source from external trigger
                        1xx = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>TMR1_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER2 clock source select.
                        000 = clock source from external crystal clock (4 ~ 24MHz)
                        010 = clock source from HCLK
                        011 = clock source from external trigger
                        1xx = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>TMR2_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER3 clock source select.
                        000 = clock source from external crystal clock (4 ~ 24MHz)
                        010 = clock source from HCLK
                        011 = clock source from external trigger
                        1xx = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>TMR3_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>UART clock source select.
                        00 = clock source from external crystal clock (4 ~ 24MHz)
                        01 = clock source from PLL clock
                        1x = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>UART_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM0 and PWM1 clock source select.
                        PWM0 and PWM1 uses the same Engine clock source, both of them with the same pre-scalar
                        00 = clock source from external crystal clock (4 ~ 24MHz)
                        10 = clock source from HCLK
                        11 = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>PWM01_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM2 and PWM3 clock source select.
                        PWM2 and PWM3 uses the same Engine clock source, both of them with the same pre-scalar
                        00 = clock source from external crystal clock (4 ~ 24MHz)
                        10 = clock source from HCLK
                        11 = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>PWM23_S</name>
          </field>
        </fields>
        <name>CLKSEL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Clock Divider Number Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>HCLK clock divide number from HCLK clock source
                        The HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)</description>
            <name>HCLK_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>UART clock divide number from UART clock source
                        The UART clock frequency = (UART clock source frequency ) / (UART_N + 1)</description>
            <name>UART_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>ADC clock divide number from ADC clock source
                        The ADC clock frequency = (ADC clock source frequency ) / (ADC_N + 1)</description>
            <name>ADC_N</name>
          </field>
        </fields>
        <name>CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Clock Source Select Control Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock Divider Clock Source Select
                        00 = clock source from external crystal clock (4 ~ 24MHz)
                        10 = clock source from HCLK
                        11 = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>FRQDIV_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM4 and PWM5 clock source select. - PWM4 and PWM5 used the same Engine clock source, both of them with the same pre-scalar
                        00 = clock source from external crystal clock (4 ~ 24MHz)
                        10 = clock source from HCLK
                        11 = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>PWM45_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM6 and PWM7 clock source select. - PWM6 and PWM7 used the same Engine clock source, both of them with the same pre-scalar
                        00 = clock source from external crystal clock (4 ~ 24MHz)
                        10 = clock source from HCLK
                        11 = clock source from internal 22.1184 MHz oscillator clock</description>
            <name>PWM67_S</name>
          </field>
        </fields>
        <name>CLKSEL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PLL Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>PLL Feedback Divider Control Pins (PLL_F[8:0])</description>
            <name>FB_DV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>PLL Input Divider Control Pins (PLL_R[4:0])</description>
            <name>IN_DV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PLL Output Divider Control Pins (PLL_OD[1:0])</description>
            <name>OUT_DV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Power Down Mode. 
                        If set the IDLE bit "1" in PWRCON register, the PLL will enter power down mode too
                        0 = PLL is in normal mode (default)
                        1 = PLL is in power-down mode</description>
            <name>PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Bypass Control
                        0 = PLL is in normal mode (default)
                        1 = PLL clock output is same as clock input (XTALin)</description>
            <name>BP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL OE (FOUT enable) pin Control
                        0 = PLL FOUT enable
                        1 = PLL FOUT is fixed low</description>
            <name>OE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Source Clock Select
                        1 = PLL source clock from 22.1184 MHz oscillator
                        0 = PLL source clock from external crystal clock (4 ~ 24 MHz)</description>
            <name>PLL_SRC</name>
          </field>
        </fields>
        <name>PLLCON</name>
        <resetMask>0xFFFA3DD1</resetMask>
        <resetValue>0x5C22E</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Frequency Divider Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider Output Frequency Selection Bits
                        The formula of output frequency is
                        Fout = Fin/2(N+1), 
                        where Fin is the input clock frequency, Fout is the frequency of divider output clock, N is the 4-bit value of FSEL[3:0].</description>
            <name>FSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Frequency Divider Enable Bit
                        0 = Disable Frequency Divider
                        1 = Enable Frequency Divider</description>
            <name>DIVIDER_EN</name>
          </field>
        </fields>
        <name>FRQDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x8</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50010000</baseAddress>
    <description>Registers group</description>
    <groupName>EBI_CTL</groupName>
    <interrupts></interrupts>
    <name>EBI_CTL</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>External Bus Interface General Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI Enable
                        This bit is the functional enable bit for EBI.
                        0 = EBI function is disabled
                        1 = EBI function is enabled</description>
            <name>ExtEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI data width 16 bit
                        This bit defines if the data bus is 8-bit or 16-bit.
                        0 = EBI data width is 8 bit
                        1 = EBI data width is 16 bit</description>
            <name>ExtBW16</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>External Output Clock Divider
                        The frequency of EBI output clock is controlled by MCLKDIV.
                        
                        MCLKDIV	Output clock (MCLK)	
                        000	HCLK/1	
                        001	HCLK/2	
                        010	HCLK/4	
                        011	HCLK/8	
                        100	HCLK/16	
                        101	HCKL/32	
                        11X	default	
                        
                        Notice: Default value of output clock is HCLK/1</description>
            <name>MCLKDIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Expand Time of ALE
                        The ALE width (tALE) to latch the address can be controlled by ExttALE.
                        tALE = (ExttALE + 1) * MCLK</description>
            <name>ExttALE</name>
          </field>
        </fields>
        <name>EBICON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>External Bus Interface 0 Timing Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>EBI Data Accesss Time
                        ExttACC define data access time (tACC).
                        tACC = (ExttACC + 1) * MCLK</description>
            <name>ExttACC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>EBI Data Access Hold Time
                        ExttAHD define data access hold time (tAHD).
                        tAHD = (ExttAHD + 1) * MCLK</description>
            <name>ExttAHD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Idle State Cycle After Write
                        When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero.
                        Idle state cycle = (ExtIW2X * MCLK)</description>
            <name>ExtIW2X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Idle State Cycle Between Read-Read
                        When read action is finish and next action is going to read, idle state is inserted and nCS return to high if ExtIR2R is not zero.
                        Idle state cycle = (ExtIR2R * MCLK)</description>
            <name>ExtIR2R</name>
          </field>
        </fields>
        <name>EXTIME</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1C</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x5000C000</baseAddress>
    <description>Registers group</description>
    <groupName>FMC</groupName>
    <interrupts></interrupts>
    <name>FMC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>ISP Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP Enable
                        This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
                        1 = Enable ISP function
                        0 = Disable ISP function</description>
            <name>ISPEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Boot Select 
                        This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as MCU booting status flag, which can be used to check where MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-on reset; It keeps the same value at other reset.
                        1 = boot from LDROM
                        0 = boot from APROM</description>
            <name>BS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Config Update Enable
                        Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program code is running in APROM or LDROM.
                        1 = Config update enable 
                        0 = Config update disable</description>
            <name>CFGUEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LDROM Update Enable
                        LDROM update enable bit. 
                        1 = LDROM can be updated when the MCU runs in APROM.
                        0 = LDROM cannot be updated</description>
            <name>LDUEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP Fail Flag
                        This bit is set by hardware when a triggered ISP meets any of the following conditions:
                        (1) APROM writes to itself.
                        (2) LDROM writes to itself. 
                        (3) Destination address is illegal, such as over an available range.
                        Write 1 to clear.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISPFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Reset
                        Writing 1 to this bit to start software reset. 
                        It is cleared by hardware after reset is finished.</description>
            <name>SWRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash Program Time
                        PT[2]	PT[1]	PT[0]	Program Time (us)	
                        0	0	0	40	
                        0	0	1	45	
                        0	1	0	50	
                        0	1	1	55	
                        1	0	0	20	
                        1	0	1	25	
                        1	1	0	30	
                        1	1	1	35	</description>
            <name>PT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash Erase Time
                        ET[2]	ET[1]	ET[0]	Erase Time (ms)	
                        0	0	0	20 (default)	
                        0	0	1	25	
                        0	1	0	30	
                        0	1	1	35	
                        1	0	0	3	
                        1	0	1	5	
                        1	1	0	10	
                        1	1	1	15	</description>
            <name>ET</name>
          </field>
        </fields>
        <name>ISPCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>ISP Address Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>ISP Address 
                        NuMicro M051 series equips with a maximum 16kx32 embedded flash, it supports word program only. ISPARD[1:0] must be kept 2'b00 for ISP operation. </description>
            <name>ISPADR</name>
          </field>
        </fields>
        <name>ISPADR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>ISP Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>ISP Data 
                        Write data to this register before ISP program operation
                        Read data from this register after ISP read operation</description>
            <name>ISPDAT</name>
          </field>
        </fields>
        <name>ISPDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>ISP Command Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>ISP Command 
                        ISP command table is shown below:
                        Operation Mode	FOEN	FCEN	FCTRL[3:0]	
                        Read	0	0	0	0	0	0	
                        Program	1	0	0	0	0	1	
                        Page Erase	1	0	0	0	1	0	</description>
            <name>FOEN_FCEN_FCTRL</name>
          </field>
        </fields>
        <name>ISPCMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>ISP Trigger Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP start trigger
                        Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finish.
                        
                        1 = ISP is on going
                        
                        0 = ISP done</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>ISPGO</name>
          </field>
        </fields>
        <name>ISPTRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Flash Base Address</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Flash Base Address
                        This register indicates data flash start address.
                        
                        It is a read only register.
                        
                        For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed at 0x01F000 by hardware internally.</description>
            <name>DFBA</name>
          </field>
        </fields>
        <name>DFBADR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Flash Access Time Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash Power Save Enable
                        If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
                        1 = Enable flash power saving
                        0 = Disable flash power saving</description>
            <name>FPSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash Access Time Window Select
                        These bits are used to decide flash sense amplifier active duration.
                        
                        
                        
                        FATS	Access Time window (ns)	
                        000	40	
                        001	50	
                        010	60	
                        011	70	
                        100	80	
                        101	90	
                        110	100	
                        111	Reserved	</description>
            <name>FATS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash Low Speed Mode Enable
                        1 = Flash access always no wait state (zero wait state)
                        0 = Insert wait state while Flash access discontinued address. 
                        Note: Set this bit only when HCLK &lt;= 25MHz. If HCLK &gt; 25MHz, CPU will fetch wrong code and cause fail result.</description>
            <name>L_SPEED</name>
          </field>
        </fields>
        <name>FATCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000000</baseAddress>
    <description>Registers group</description>
    <groupName>GCR</groupName>
    <interrupts></interrupts>
    <name>GCR</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Part Device Identification number Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>This register reflects device part number code. S/W can read this register to identify which device is used.</description>
            <name>PDID</name>
          </field>
        </fields>
        <name>PDID</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>System Reset Source Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_POR flag is set by the "reset signal" which is from the Power-On Reset (POR) module or bit CHIP_RST (IPRSTC1[0]) is set, to indicate the previous reset source.
                        1= The Power-On-Reset(POR) or CHIP_RST=1 had issued the reset signal to reset the system.
                        0= No reset from POR
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_POR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
                        1= The Pin /RESET had issued the reset signal to reset the system.
                        0= No reset from Pin /RESET
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_RESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_WDT flag is set by the "reset signal" from the Watch Dog Timer to indicate the previous reset source.
                        1= The Watch Dog Timer had issued the reset signal to reset the system.
                        0= No reset from Watch-Dog
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_WDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_LVR flag is set by the "reset signal" from the Low-Voltage-Reset module to indicate the previous reset source.
                        1= The LVR module had issued the reset signal to reset the system.
                        0= No reset from LVR
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_LVR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_BOD flag is set by the "reset signal" from the Brown-Out-Detected module to indicate the previous reset source.
                        1= The Brown-Out-Detected module had issued the reset signal to reset the system.
                        0= No reset from BOD
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_MCU flag is set by the "reset signal" from the MCU Cortex_M0 kernel to indicate the previous reset source.
                        1= The MCU Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register) in system control registers of Cortex_M0 kernel.
                        0= No reset from MCU
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_MCU</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) with a "1" to rest Cortex-M0 CPU kernel and Flash memory controller(FMC).
                        1= The Cortex-M0 CPU kernel and FMC are reset by software set CPU_RST to 1.
                        0= No reset from CPU
                        This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_CPU</name>
          </field>
        </fields>
        <name>RSTSRC</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>IP Reset Control Resister1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CHIP one shot reset.
                        Set this bit will reset the CHIP, including CPU kernel and all peripherals, and this bit will automatically return to "0" after the 2 clock cycles.
                        The CHIP_RST is same as the POR reset , all the chip module is reset and the chip setting from flash are also reload
                        This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        0= Normal
                        1= Reset CHIP</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CHIP_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CPU kernel one shot reset.
                        Set this bit will reset the Cortex-M0 CPU kernel and Flash memory controller (FMC). This bit will automatically return to "0" after the 2 clock cycles
                        This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        0= Normal
                        1= Reset CPU</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CPU_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI Controller Reset
                        Set these bit "1" will generate a reset signal to the EBI. User need to set this bit to "0" to release from the reset state
                        This bit is the protected bit, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100
                        0= Normal operation
                        1= EBI IP reset</description>
            <name>EBI_RST</name>
          </field>
        </fields>
        <name>IPRSTC1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>IP Reset Control Resister 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO (P0~P4) controller Reset
                        0= GPIO controller normal operation
                        1= GPIO controller reset</description>
            <name>GPIO_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer0 controller Reset
                        0= Timer0 controller normal operation
                        1= Timer0 controller reset</description>
            <name>TMR0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer1 controller Reset
                        0= Timer1 controller normal operation
                        1= Timer1 controller reset</description>
            <name>TMR1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer2 controller Reset
                        0= Timer2 controller normal operation
                        1= Timer2 controller reset</description>
            <name>TMR2_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer3 controller Reset
                        0= Timer3 controller normal operation
                        1= Timer3 controller reset</description>
            <name>TMR3_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C controller Reset
                        0= I2C controller normal operation
                        1= I2C controller reset</description>
            <name>I2C_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 controller Reset
                        0= SPI0 controller normal operation
                        1= SPI0 controller reset</description>
            <name>SPI0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 controller Reset
                        0= SPI1 controller normal operation
                        1= SPI1 controller reset</description>
            <name>SPI1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART0 controller Reset
                        0= UART0 controller Normal operation
                        1= UART0 controller reset</description>
            <name>UART0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART1 controller Reset
                        0 = UART1 controller normal operation
                        1 = UART1 controller reset</description>
            <name>UART1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM0~3 controller Reset
                        0= PWM0~3 controller normal operation
                        1= PWM0~3 controller reset</description>
            <name>PWM03_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM4~7 controller Reset
                        0= PWM4~7 controller normal operation
                        1= PWM4~7 controller reset</description>
            <name>PWM47_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC Controller Reset
                        0= ADC controller normal operation
                        1= ADC controller reset</description>
            <name>ADC_RST</name>
          </field>
        </fields>
        <name>IPRSTC2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Brown Out Detector Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector Enable (initiated &amp; write-protected bit)
                        The default value is set by flash controller user configuration register config0 bit[23]
                        1= Brown Out Detector function is enabled
                        0= Brown Out Detector function is disabled</description>
            <name>BOD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Brown Out Detector Threshold Voltage Selection (initiated &amp; write-protected bit)
                        The default value is set by flash controller user configuration register config0 bit[22:21]
                        BOV_VL[1]	BOV_VL[0]	Brown out voltage	
                        1	1	4.5V	
                        1	0	3.8V	
                        0	1	2.7V	
                        0	0	2.2V	</description>
            <name>BOD_VL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Reset Enable (initiated &amp; write-protected bit)
                        1= Enable the Brown Out "RESET" function, when the Brown Out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to reset the chip
                        The default value is set by flash controller user configuration register config0 bit[20]
                        0= Enable the Brown Out "INTERRUPT" function, when the Brown Out Detector function is enable and the detected voltage is lower than the threshold then assert a signal to interrupt the MCU Cortex-M0
                        When the BOD_EN is enabled and the interrupt is assert, the interrupt will keep till to the BOD_EN set to "0". The interrupt for CPU can be blocked by disable the NVIC in CPU for BOD interrupt or disable the interrupt source by disable the BOD_EN and then re-enable the BOD_EN function if the BOD function is required</description>
            <name>BOD_RSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector Interrupt Flag
                        1= When Brown Out Detector detects the VDD is dropped through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to "1" and the brown out interrupt is requested if brown out interrupt is enabled.
                        0= Brown Out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BOD_INTF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector Low power Mode (write-protected bit)
                        1= Enable the BOD low power mode
                        0= BOD operate in normal mode (default)
                        The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.</description>
            <name>BOD_LPM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The status for Brown Out Detector output state
                        1= Brown Out Detector status output is 1, the detected voltage is lower than BOD_VL setting. If the BOD_EN is "0"(disabled), this bit always response "0"
                        0= Brown Out Detector status output is 0, the detected voltage is higher than BOD_VL setting</description>
            <name>BOD_OUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Low Voltage Reset Enable (write-protected bit)
                        The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled in default.
                        1= Enabled Low Voltage Reset function - After enable the bit, the LVR function will active with 100uS delay for LVR output stable.(default).
                        0= Disabled Low Voltage Reset function</description>
            <name>LVR_EN</name>
          </field>
        </fields>
        <name>BODCR</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Power-On-Reset Controller Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>The register is used for the Power-On-Reset enable control. 
                        When power on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. If set the POR_DIS_CODE equal to 0x5AA5, the POR reset function will be disabled and the POR function will re-active till the power voltage is lower to set the POR_DIS_CODE to another value or reset by chip other reset function. Include:
                        PIN reset, Watch dog, LVR reset BOD reset, ICE reset command and the software-chip reset function
                        This register is the protected register, program this need an open lock sequence, write "59h","16h","88h" to address 0x5000_0100 to un-lock this bit. Reference the register REGWRPROT at address GCR_BA + 0x100</description>
            <name>POR_DIS_CODE</name>
          </field>
        </fields>
        <name>PORCR</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>P0 multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P0 multiple function Selection
                        The pin function of P0 is depending on P0_MFP and P0_ALT.
                        Refer to P0_ALT descriptions in detail.</description>
            <name>P0_MFP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.0 alternate function Selection
                        The pin function of P0.0 is depend on P0_MFP[0] and P0_ALT[0].
                        P0_ALT[0]	P0_MFP[0]	P0.0function	
                        0	0	P0.0	
                        0	1	AD0(EBI)	
                        1	0	CTS1(UART1)	
                        1	1	Reserved	</description>
            <name>P0_ALT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.1 alternate function Selection
                        The pin function of P0.1 is depend on P0_MFP[1] and P0_ALT[1].
                        P0_ALT[1]	P0_MFP[1]	P0.1function	
                        0	0	P0.1	
                        0	1	AD1(EBI)	
                        1	0	RTS1(UART1)	
                        1	1	Reserved	</description>
            <name>P0_ALT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.2 alternate function Selection
                        The pin function of P0.2 is depend on P0_MFP[2] and P0_ALT[2].
                        P0_ALT[2]	P0_MFP[2]	P0.2function	
                        0	0	P0.2	
                        0	1	AD2(EBI)	
                        1	0	CTS0(UART0)	
                        1	1	Reserved	</description>
            <name>P0_ALT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.3 alternate function Selection
                        The pin function of P0.3 is depend on P0_MFP[3] and P0_ALT[3].
                        P0_ALT[3]	P0_MFP[3]	P0.3function	
                        0	0	P0.3	
                        0	1	AD3(EBI)	
                        1	0	RTS0(UART0)	
                        1	1	Reserved	</description>
            <name>P0_ALT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.4 alternate function Selection
                        The pin function of P0.4 is depend on P0_MFP[4] and P0_ALT[4].
                        P0_ALT[4]	P0_MFP[4]	P0.4function	
                        0	0	P0.4	
                        0	1	AD4(EBI)	
                        1	0	SPISS1(SPI1)	
                        1	1	Reserved	</description>
            <name>P0_ALT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.5 alternate function Selection
                        The pin function of P0.5 is depend on P0_MFP[5] and P0_ALT[5].
                        P0_ALT[5]	P0_MFP[5]	P0.5 function	
                        0	0	P0.5	
                        0	1	AD5(EBI)	
                        1	0	MOSI_1(SPI1)	
                        1	1	Reserved	</description>
            <name>P0_ALT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.6 alternate function Selection
                        The pin function of P0.6 is depend on P0_MFP[6] and P0_ALT[6].
                        P0_ALT[6]	P0_MFP[6]	P0.6 function	
                        0	0	P0.6	
                        0	1	AD6(EBI)	
                        1	0	MISO_1(SPI1)	
                        1	1	Reserved	</description>
            <name>P0_ALT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.7 alternate function Selection
                        The pin function of P0.7 is depend on P0_MFP[7] and P0_ALT[7].
                        P0_ALT[7]	P0_MFP[7]	P0.7 function	
                        0	0	P0.7	
                        0	1	AD7(EBI)	
                        1	0	SPICLK1(SPI1)	
                        1	1	Reserved	</description>
            <name>P0_ALT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P0[7:0] input Schmitt Trigger function Enable
                        1= P0[7:0] I/O input Schmitt Trigger function enable
                        0= P0[7:0] I/O input Schmitt Trigger function disable </description>
            <name>P0_TYPEn</name>
          </field>
        </fields>
        <name>P0_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>P1 multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P1 multiple function Selection
                        The pin function of P1 is depending on P1_MFP and P1_ALT.
                        Refer to P1_ALT descriptions in detail.</description>
            <name>P1_MFP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.0 alternate function Selection
                        The pin function of P1.0 is depend on P1_MFP[0] and P1_ALT[0].
                        P1_ALT[0]	P1_MFP[0]	P1.0function	
                        0	0	P1.0	
                        0	1	AIN0(ADC)	
                        1	0	T2(Timer2)	
                        1	1	Reserved	</description>
            <name>P1_ALT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.1 alternate function Selection
                        The pin function of P1.1 is depend on P1_MFP[1] and P1_ALT[1].
                        P1_ALT[1]	P1_MFP[1]	P1.1function	
                        0	0	P1.1	
                        0	1	AIN1(ADC)	
                        1	0	T3(Timer3)	
                        1	1	Reserved	</description>
            <name>P1_ALT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.2 alternate function Selection
                        The pin function of P1.2 is depend on P1_MFP[2] and P1_ALT[2].
                        P1_ALT[2]	P1_MFP[2]	P1.2function	
                        0	0	P1.2	
                        0	1	AIN2(ADC)	
                        1	0	RXD1(UART1)	
                        1	1	Reserved	</description>
            <name>P1_ALT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.3 alternate function Selection
                        The pin function of P1.3 is depend on P1_MFP[3] and P1_ALT[3].
                        P1_ALT[3]	P1_MFP[3]	P1.3function	
                        0	0	P1.3	
                        0	1	AIN3(ADC)	
                        1	0	TXD1(UART1)	
                        1	1	Reserved	</description>
            <name>P1_ALT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.4 alternate function Selection
                        The pin function of P1.4 is depend on P1_MFP[4] and P1_ALT[4].
                        P1_ALT[4]	P1_MFP[4]	P1.4function	
                        0	0	P1.4	
                        0	1	AIN4(ADC)	
                        1	0	SPISS0(SPI0)	
                        1	1	Reserved	</description>
            <name>P1_ALT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.5 alternate function Selection
                        The pin function of P1.5 is depend on P1_MFP[5] and P1_ALT[5].
                        P1_ALT[5]	P1_MFP[5]	P1.5 function	
                        0	0	P1.5	
                        0	1	AIN5(ADC)	
                        1	0	MOSI_0(SPI0)	
                        1	1	Reserved	</description>
            <name>P1_ALT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.6 alternate function Selection
                        The pin function of P1.6 is depend on P1_MFP[6] and P1_ALT[6].
                        P1_ALT[6]	P1_MFP[6]	P1.6 function	
                        0	0	P1.6	
                        0	1	AIN6(ADC)	
                        1	0	MISO_0(SPI0)	
                        1	1	Reserved	</description>
            <name>P1_ALT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P1.7 alternate function Selection
                        The pin function of P1.7 is depend on P1_MFP[7] and P1_ALT[7].
                        P1_ALT[7]	P1_MFP[7]	P1.7 function	
                        0	0	P1.7	
                        0	1	AIN7(ADC)	
                        1	0	SPICLK0(SPI0)	
                        1	1	Reserved	</description>
            <name>P1_ALT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P1[7:0] input Schmitt Trigger function Enable
                        1= P1[7:0] I/O input Schmitt Trigger function enable
                        0= P1[7:0] I/O input Schmitt Trigger function disable </description>
            <name>P1_TYPEn</name>
          </field>
        </fields>
        <name>P1_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>P2 multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P2 multiple function Selection
                        The pin function of P2 is depending on P2_MFP and P2_ALT.
                        Refer to P2_ALT descriptions in detail.</description>
            <name>P2_MFP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.0 alternate function Selection
                        The pin function of P2.0 is depend on P2_MFP[0] and P2_ALT[0].
                        P2_ALT[0]	P2_MFP[0]	P2.0function	
                        0	0	P2.0	
                        0	1	AD8(EBI)	
                        1	0	PWM0(PWM generator 0)	
                        1	1	Reserved	</description>
            <name>P2_ALT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.1 alternate function Selection
                        The pin function of P2.1 is depend on P2_MFP[1] and P2_ALT[1].
                        P2_ALT[1]	P2_MFP[1]	P2.1function	
                        0	0	P2.1	
                        0	1	AD9(EBI)	
                        1	0	PWM1(PWM generator 0)	
                        1	1	Reserved	</description>
            <name>P2_ALT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.2 alternate function Selection
                        The pin function of P2.2 is depend on P2_MFP[2] and P2_ALT[2].
                        P2_ALT[2]	P2_MFP[2]	P2.2function	
                        0	0	P2.2	
                        0	1	AD10(EBI)	
                        1	0	PWM2(PWM generator 2)	
                        1	1	Reserved	</description>
            <name>P2_ALT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.3 alternate function Selection
                        The pin function of P2.3 is depend on P2_MFP[3] and P2_ALT[3].
                        P2_ALT[3]	P2_MFP[3]	P2.3function	
                        0	0	P2.3	
                        0	1	AD11(EBI)	
                        1	0	PWM3(PWM generator 2)	
                        1	1	Reserved	</description>
            <name>P2_ALT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.4 alternate function Selection
                        The pin function of P2.4 is depend on P2_MFP[4] and P2_ALT[4].
                        P2_ALT[4]	P2_MFP[4]	P0.4function	
                        0	0	P0.4	
                        0	1	AD12(EBI)	
                        1	0	PWM4(PWM generator 4)	
                        1	1	Reserved	</description>
            <name>P2_ALT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.5 alternate function Selection
                        The pin function of P2.5 is depend on P2_MFP[5] and P2_ALT[5].
                        P2_ALT[5]	P2_MFP[5]	P2.5 function	
                        0	0	P2.5	
                        0	1	AD13(EBI)	
                        1	0	PWM5(PWM generator 4)	
                        1	1	Reserved	</description>
            <name>P2_ALT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.6 alternate function Selection
                        The pin function of P2.6 is depend on P2_MFP[6] and P2_ALT[6].
                        P2_ALT[6]	P2_MFP[6]	P2.6 function	
                        0	0	P2.6	
                        0	1	AD14(EBI)	
                        1	0	PWM6(PWM generator 6)	
                        1	1	Reserved	</description>
            <name>P2_ALT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P2.7 alternate function Selection
                        The pin function of P2.7 is depend on P2_MFP[7] and P2_ALT[7].
                        P2_ALT[7]	P2_MFP[7]	P2.7 function	
                        0	0	P2.7	
                        0	1	AD15(EBI)	
                        1	0	PWM7(PWM generator 6)	
                        1	1	Reserved	</description>
            <name>P2_ALT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P2[7:0] input Schmitt Trigger function Enable
                        1= P2[7:0] I/O input Schmitt Trigger function enable
                        0= P2[7:0] I/O input Schmitt Trigger function disable </description>
            <name>P2_TYPEn</name>
          </field>
        </fields>
        <name>P2_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>P3 multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P3 multiple function Selection
                        The pin function of P3 is depending on P3_MFP and P3_ALT.
                        Refer to P3_ALT descriptions in detail.</description>
            <name>P3_MFP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.0 alternate function Selection
                        The pin function of P3.0 is depend on P3_MFP[0] and P3_ALT[0].
                        P3_ALT[0]	P3_MFP[0]	P3.0function	
                        0	0	P3.0	
                        0	1	RXD(UART0)	
                        1	x	Reserved	</description>
            <name>P3_ALT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.1 alternate function Selection
                        The pin function of P3.1 is depend on P3_MFP[1] and P3_ALT[1].
                        P3_ALT[1]	P3_MFP[1]	P3.1function	
                        0	0	P3.1	
                        0	1	TXD(UART0)	
                        1	x	Reserved	</description>
            <name>P3_ALT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.2 alternate function Selection
                        The pin function of P3.2 is depend on P3_MFP[2] and P3_ALT[2].
                        P3_ALT[2]	P3_MFP[2]	P3.2function	
                        0	0	P3.2	
                        0	1	/INT0	
                        1	1	Reserved	</description>
            <name>P3_ALT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.3 alternate function Selection
                        The pin function of P3.3 is depend on P3_MFP[3] and P3_ALT[3].
                        P3_ALT[3]	P3_MFP[3]	P3.3function	
                        0	0	P3.3	
                        0	1	/INT1	
                        1	0	MCLK(EBI)	
                        1	x	Reserved	</description>
            <name>P3_ALT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.4 alternate function Selection
                        The pin function of P3.4 is depend on P3_MFP[4] and P3_ALT[4].
                        P3_ALT[4]	P3_MFP[4]	P3.4function	
                        0	0	P3.4	
                        0	1	T0(Timer0)	
                        1	0	SDA(I2C)	
                        1	1	Reserved	</description>
            <name>P3_ALT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.5 alternate function Selection
                        The pin function of P3.5 is depend on P3_MFP[5] and P3_ALT[5].
                        P3_ALT[5]	P3_MFP[5]	P3.5 function	
                        0	0	P3.5	
                        0	1	T1(Timer1)	
                        1	0	SCL(I2C)	
                        1	1	Reserved	</description>
            <name>P3_ALT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.6 alternate function Selection
                        The pin function of P3.6 is depend on P3_MFP[6] and P3_ALT[6].
                        P3_ALT[6]	P3_MFP[6]	P3.6 function	
                        0	0	P3.6	
                        0	1	WR(EBI)	
                        1	0	CKO(Clock Driver output)	
                        1	1	Reserved	</description>
            <name>P3_ALT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P3.7 alternate function Selection
                        The pin function of P3.7 is depend on P3_MFP[7] and P3_ALT[7].
                        P3_ALT[7]	P3_MFP[7]	P3.7 function	
                        0	0	P3.7	
                        0	1	RD(EBI)	
                        1	x	Reserved	</description>
            <name>P3_ALT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P3[7:0] input Schmitt Trigger function Enable
                        1= P3[7:0] I/O input Schmitt Trigger function enable
                        0= P3[7:0] I/O input Schmitt Trigger function disable </description>
            <name>P3_TYPEn</name>
          </field>
        </fields>
        <name>P3_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>P4 input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P4 multiple function Selection
                        The pin function of P4 is depending on P4_MFP and P4_ALT.
                        Refer to P4_ALT descriptions in detail.</description>
            <name>P4_MFP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.0 alternate function Selection
                        The pin function of P4.0 is depend on P4_MFP[0] and P4_ALT[0].
                        P4_ALT[0]	P4_MFP[0]	P4.0function	
                        0	0	P4.0	
                        0	1	PWM0(PWM generator 0)	
                        1	x	Reserved	</description>
            <name>P4_ALT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.1 alternate function Selection
                        The pin function of P4.1 is depend on P4_MFP[1] and P4_ALT[1].
                        P4_ALT[1]	P4_MFP[1]	P4.1function	
                        0	0	P4.1	
                        0	1	PWM1(PWM generator 0)	
                        1	x	Reserved	</description>
            <name>P4_ALT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.2 alternate function Selection
                        The pin function of P4.2 is depend on P4_MFP[2] and P4_ALT[2].
                        P4_ALT[2]	P4_MFP[2]	P4.2function	
                        0	0	P4.2	
                        0	1	PWM2(PWM generator 2)	
                        1	x	Reserved	</description>
            <name>P4_ALT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.3 alternate function Selection
                        The pin function of P4.3 is depend on P4_MFP[3] and P4_ALT[3].
                        P4_ALT[3]	P4_MFP[3]	P4.3function	
                        0	0	P4.3	
                        0	1	PWM3(PWM generator 2)	
                        1	x	Reserved	</description>
            <name>P4_ALT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.4 alternate function Selection
                        The pin function of P4.4 is depend on P4_MFP[4] and P4_ALT[4].
                        P4_ALT[4]	P4_MFP[4]	P4.4function	
                        0	0	P4.4	
                        0	1	/CS(EBI)	
                        1	x	Reserved	</description>
            <name>P4_ALT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.5 alternate function Selection
                        The pin function of P4.5 is depend on P4_MFP[5] and P4_ALT[5].
                        P4_ALT[5]	P4_MFP[5]	P4.5 function	
                        0	0	P4.5	
                        0	1	ALE(EBI)	
                        1	x	Reserved	</description>
            <name>P4_ALT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.6 alternate function Selection
                        The pin function of P4.6 is depend on P4_MFP[6] and P4_ALT[6].
                        P4_ALT[6]	P4_MFP[6]	P4.6 function	
                        0	0	P4.6	
                        0	1	ICE_CLK(ICE)	
                        1	x	Reserved	</description>
            <name>P4_ALT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P4.7 alternate function Selection
                        The pin function of P4.7 is depend on P4_MFP[7] and P4_ALT[7].
                        P4_ALT[7]	P4_MFP[7]	P4.7 function	
                        0	0	P4.7	
                        0	1	ICE_DAT(ICE)	
                        1	x	Reserved	</description>
            <name>P4_ALT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>P4[7:0] input Schmitt Trigger function Enable
                        1= P4[7:0] I/O input Schmitt Trigger function enable
                        0= P4[7:0] I/O input Schmitt Trigger function disable </description>
            <name>P4_TYPEn</name>
          </field>
        </fields>
        <name>P4_MFP</name>
        <resetMask>0xFFFFFF3F</resetMask>
        <resetValue>0xC0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Register Lock Key address</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Register Write-Protected Code (Write Only)
                        Some write-protected registers have to be disabled the protected function by writing the sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.</description>
            <name>REGWRPROT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Register Write-Protected Disable index (Read only)
                        1 = Protection is disabled for writing protected registers
                        0 = Protection is enabled for writing protected registers. Any write to the protected register is ignored.
                        The Write-Protected registers list are below table:
                        Registers	Address	Note	
                        IPRSTC1	0x5000_0008	None	
                        BODCR	0x5000_0018	None	
                        PORCR	0x5000_001C	None	
                        PWRCON	0x5000_0200	bit[6] is not protected for power wake-up interrupt clear	
                        APBCLK bit[0]	0x5000_0208	bit[0] is watch dog clock enable	
                        CLKSEL0	0x5000_0210	HCLK and CPU STCLK clock source select	
                        CLK_SEL1 bit[1:0]	0x5000_0214	Watch dog clock source select	
                        ISPCON	0x5000_C000	Flash ISP Control register	
                        WTCR	0x4000_4000	None	
                        FATCON	0x5000_C018	None	</description>
            <name>REGPROTDIS</name>
          </field>
        </fields>
        <name>REGWRPROT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004000</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GP0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Bit Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[0] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[0] pin is in INPUT mode.
                        01 = P0[0] pin is in OUTPUT mode.
                        10 = P0[0] pin is in Open-Drain mode.
                        11 = P0[0] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[1] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[1] pin is in INPUT mode.
                        01 = P0[1] pin is in OUTPUT mode.
                        10 = P0[1] pin is in Open-Drain mode.
                        11 = P0[1] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[2] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[2] pin is in INPUT mode.
                        01 = P0[2] pin is in OUTPUT mode.
                        10 = P0[2] pin is in Open-Drain mode.
                        11 = P0[2] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[3] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[3] pin is in INPUT mode.
                        01 = P0[3] pin is in OUTPUT mode.
                        10 = P0[3] pin is in Open-Drain mode.
                        11 = P0[3] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[4] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[4] pin is in INPUT mode.
                        01 = P0[4] pin is in OUTPUT mode.
                        10 = P0[4] pin is in Open-Drain mode.
                        11 = P0[4] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[5] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[5] pin is in INPUT mode.
                        01 = P0[5] pin is in OUTPUT mode.
                        10 = P0[5] pin is in Open-Drain mode.
                        11 = P0[5] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[6] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[6] pin is in INPUT mode.
                        01 = P0[6] pin is in OUTPUT mode.
                        10 = P0[6] pin is in Open-Drain mode.
                        11 = P0[6] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[7] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[7] pin is in INPUT mode.
                        01 = P0[7] pin is in OUTPUT mode.
                        10 = P0[7] pin is in Open-Drain mode.
                        11 = P0[7] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Bit OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>OFFD: P0 Pin OFF digital input path Enable
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[0] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[1] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[2] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[3] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[4] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[5] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[6] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[7] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[0] bit can be updated
                        1 = The corresponding P0_DOUT[0] bit is protected</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[1] bit can be updated
                        1 = The corresponding P0_DOUT[1] bit is protected</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[2] bit can be updated
                        1 = The corresponding P0_DOUT[2] bit is protected</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[3] bit can be updated
                        1 = The corresponding P0_DOUT[3] bit is protected</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[4] bit can be updated
                        1 = The corresponding P0_DOUT[4] bit is protected</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[7] bit can be updated
                        1 = The corresponding P0_DOUT[7] bit is protected</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[0].</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[1].</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[2].</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[3].</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[4].</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[5].</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[6].</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[7].</description>
            <name>PIN7</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[0] de-bounce function is disabled
                        1 = The bit[0] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[1] de-bounce function is disabled
                        1 = The bit[1] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[2] de-bounce function is disabled
                        1 = The bit[2] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[3] de-bounce function is disabled
                        1 = The bit[3] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[4] de-bounce function is disabled
                        1 = The bit[4] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[5] de-bounce function is disabled
                        1 = The bit[5] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[6] de-bounce function is disabled
                        1 = The bit[6] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[7] de-bounce function is disabled
                        1 = The bit[7] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[0] state low-level or high-to-low change interrupt
                        0 = Disable the P0[0] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[1] state low-level or high-to-low change interrupt
                        0 = Disable the P0[1] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[2] state low-level or high-to-low change interrupt
                        0 = Disable the P0[2] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[3] state low-level or high-to-low change interrupt
                        0 = Disable the P0[3] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[4] state low-level or high-to-low change interrupt
                        0 = Disable the P0[4] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[5] state low-level or high-to-low change interrupt
                        0 = Disable the P0[5] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[6] state low-level or high-to-low change interrupt
                        0 = Disable the P0[6] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[7] state low-level or high-to-low change interrupt
                        0 = Disable the P0[7] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[0] level-high or low-to-high interrupt
                        0 = Disable the P0[0] level-high or low-to-high interrupt</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[1] level-high or low-to-high interrupt
                        0 = Disable the P0[1] level-high or low-to-high interrupt</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[2] level-high or low-to-high interrupt
                        0 = Disable the P0[2] level-high or low-to-high interrupt</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[3] level-high or low-to-high interrupt
                        0 = Disable the P0[3] level-high or low-to-high interrupt</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[4] level-high or low-to-high interrupt
                        0 = Disable the P0[4] level-high or low-to-high interrupt</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[5] level-high or low-to-high interrupt
                        0 = Disable the P0[5] level-high or low-to-high interrupt</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[6] level-high or low-to-high interrupt
                        0 = Disable the P0[6] level-high or low-to-high interrupt</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[7] level-high or low-to-high interrupt
                        0 = Disable the P0[7] level-high or low-to-high interrupt</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt Trigger Source</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[0] generate an interrupt
                        0 = No interrupt at P0[0]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[1] generate an interrupt
                        0 = No interrupt at P0[1]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[2] generate an interrupt
                        0 = No interrupt at P0[2]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[3] generate an interrupt
                        0 = No interrupt at P0[3]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[4] generate an interrupt
                        0 = No interrupt at P0[4]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[5] generate an interrupt
                        0 = No interrupt at P0[5]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[6] generate an interrupt
                        0 = No interrupt at P0[6]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[7] generate an interrupt
                        0 = No interrupt at P0[7]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004040</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GP1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Bit Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[0] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[0] pin is in INPUT mode.
                        01 = P0[0] pin is in OUTPUT mode.
                        10 = P0[0] pin is in Open-Drain mode.
                        11 = P0[0] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[1] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[1] pin is in INPUT mode.
                        01 = P0[1] pin is in OUTPUT mode.
                        10 = P0[1] pin is in Open-Drain mode.
                        11 = P0[1] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[2] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[2] pin is in INPUT mode.
                        01 = P0[2] pin is in OUTPUT mode.
                        10 = P0[2] pin is in Open-Drain mode.
                        11 = P0[2] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[3] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[3] pin is in INPUT mode.
                        01 = P0[3] pin is in OUTPUT mode.
                        10 = P0[3] pin is in Open-Drain mode.
                        11 = P0[3] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[4] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[4] pin is in INPUT mode.
                        01 = P0[4] pin is in OUTPUT mode.
                        10 = P0[4] pin is in Open-Drain mode.
                        11 = P0[4] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[5] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[5] pin is in INPUT mode.
                        01 = P0[5] pin is in OUTPUT mode.
                        10 = P0[5] pin is in Open-Drain mode.
                        11 = P0[5] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[6] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[6] pin is in INPUT mode.
                        01 = P0[6] pin is in OUTPUT mode.
                        10 = P0[6] pin is in Open-Drain mode.
                        11 = P0[6] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[7] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[7] pin is in INPUT mode.
                        01 = P0[7] pin is in OUTPUT mode.
                        10 = P0[7] pin is in Open-Drain mode.
                        11 = P0[7] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Bit OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>OFFD: P0 Pin OFF digital input path Enable
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[0] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[1] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[2] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[3] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[4] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[5] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[6] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[7] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[0] bit can be updated
                        1 = The corresponding P0_DOUT[0] bit is protected</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[1] bit can be updated
                        1 = The corresponding P0_DOUT[1] bit is protected</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[2] bit can be updated
                        1 = The corresponding P0_DOUT[2] bit is protected</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[3] bit can be updated
                        1 = The corresponding P0_DOUT[3] bit is protected</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[4] bit can be updated
                        1 = The corresponding P0_DOUT[4] bit is protected</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[7] bit can be updated
                        1 = The corresponding P0_DOUT[7] bit is protected</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[0].</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[1].</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[2].</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[3].</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[4].</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[5].</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[6].</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[7].</description>
            <name>PIN7</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[0] de-bounce function is disabled
                        1 = The bit[0] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[1] de-bounce function is disabled
                        1 = The bit[1] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[2] de-bounce function is disabled
                        1 = The bit[2] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[3] de-bounce function is disabled
                        1 = The bit[3] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[4] de-bounce function is disabled
                        1 = The bit[4] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[5] de-bounce function is disabled
                        1 = The bit[5] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[6] de-bounce function is disabled
                        1 = The bit[6] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[7] de-bounce function is disabled
                        1 = The bit[7] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[0] state low-level or high-to-low change interrupt
                        0 = Disable the P0[0] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[1] state low-level or high-to-low change interrupt
                        0 = Disable the P0[1] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[2] state low-level or high-to-low change interrupt
                        0 = Disable the P0[2] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[3] state low-level or high-to-low change interrupt
                        0 = Disable the P0[3] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[4] state low-level or high-to-low change interrupt
                        0 = Disable the P0[4] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[5] state low-level or high-to-low change interrupt
                        0 = Disable the P0[5] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[6] state low-level or high-to-low change interrupt
                        0 = Disable the P0[6] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[7] state low-level or high-to-low change interrupt
                        0 = Disable the P0[7] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[0] level-high or low-to-high interrupt
                        0 = Disable the P0[0] level-high or low-to-high interrupt</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[1] level-high or low-to-high interrupt
                        0 = Disable the P0[1] level-high or low-to-high interrupt</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[2] level-high or low-to-high interrupt
                        0 = Disable the P0[2] level-high or low-to-high interrupt</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[3] level-high or low-to-high interrupt
                        0 = Disable the P0[3] level-high or low-to-high interrupt</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[4] level-high or low-to-high interrupt
                        0 = Disable the P0[4] level-high or low-to-high interrupt</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[5] level-high or low-to-high interrupt
                        0 = Disable the P0[5] level-high or low-to-high interrupt</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[6] level-high or low-to-high interrupt
                        0 = Disable the P0[6] level-high or low-to-high interrupt</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[7] level-high or low-to-high interrupt
                        0 = Disable the P0[7] level-high or low-to-high interrupt</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt Trigger Source</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[0] generate an interrupt
                        0 = No interrupt at P0[0]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[1] generate an interrupt
                        0 = No interrupt at P0[1]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[2] generate an interrupt
                        0 = No interrupt at P0[2]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[3] generate an interrupt
                        0 = No interrupt at P0[3]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[4] generate an interrupt
                        0 = No interrupt at P0[4]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[5] generate an interrupt
                        0 = No interrupt at P0[5]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[6] generate an interrupt
                        0 = No interrupt at P0[6]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[7] generate an interrupt
                        0 = No interrupt at P0[7]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004080</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GP2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Bit Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[0] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[0] pin is in INPUT mode.
                        01 = P0[0] pin is in OUTPUT mode.
                        10 = P0[0] pin is in Open-Drain mode.
                        11 = P0[0] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[1] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[1] pin is in INPUT mode.
                        01 = P0[1] pin is in OUTPUT mode.
                        10 = P0[1] pin is in Open-Drain mode.
                        11 = P0[1] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[2] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[2] pin is in INPUT mode.
                        01 = P0[2] pin is in OUTPUT mode.
                        10 = P0[2] pin is in Open-Drain mode.
                        11 = P0[2] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[3] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[3] pin is in INPUT mode.
                        01 = P0[3] pin is in OUTPUT mode.
                        10 = P0[3] pin is in Open-Drain mode.
                        11 = P0[3] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[4] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[4] pin is in INPUT mode.
                        01 = P0[4] pin is in OUTPUT mode.
                        10 = P0[4] pin is in Open-Drain mode.
                        11 = P0[4] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[5] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[5] pin is in INPUT mode.
                        01 = P0[5] pin is in OUTPUT mode.
                        10 = P0[5] pin is in Open-Drain mode.
                        11 = P0[5] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[6] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[6] pin is in INPUT mode.
                        01 = P0[6] pin is in OUTPUT mode.
                        10 = P0[6] pin is in Open-Drain mode.
                        11 = P0[6] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[7] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[7] pin is in INPUT mode.
                        01 = P0[7] pin is in OUTPUT mode.
                        10 = P0[7] pin is in Open-Drain mode.
                        11 = P0[7] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Bit OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>OFFD: P0 Pin OFF digital input path Enable
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[0] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[1] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[2] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[3] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[4] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[5] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[6] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[7] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[0] bit can be updated
                        1 = The corresponding P0_DOUT[0] bit is protected</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[1] bit can be updated
                        1 = The corresponding P0_DOUT[1] bit is protected</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[2] bit can be updated
                        1 = The corresponding P0_DOUT[2] bit is protected</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[3] bit can be updated
                        1 = The corresponding P0_DOUT[3] bit is protected</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[4] bit can be updated
                        1 = The corresponding P0_DOUT[4] bit is protected</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[7] bit can be updated
                        1 = The corresponding P0_DOUT[7] bit is protected</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[0].</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[1].</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[2].</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[3].</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[4].</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[5].</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[6].</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[7].</description>
            <name>PIN7</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[0] de-bounce function is disabled
                        1 = The bit[0] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[1] de-bounce function is disabled
                        1 = The bit[1] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[2] de-bounce function is disabled
                        1 = The bit[2] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[3] de-bounce function is disabled
                        1 = The bit[3] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[4] de-bounce function is disabled
                        1 = The bit[4] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[5] de-bounce function is disabled
                        1 = The bit[5] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[6] de-bounce function is disabled
                        1 = The bit[6] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[7] de-bounce function is disabled
                        1 = The bit[7] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[0] state low-level or high-to-low change interrupt
                        0 = Disable the P0[0] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[1] state low-level or high-to-low change interrupt
                        0 = Disable the P0[1] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[2] state low-level or high-to-low change interrupt
                        0 = Disable the P0[2] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[3] state low-level or high-to-low change interrupt
                        0 = Disable the P0[3] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[4] state low-level or high-to-low change interrupt
                        0 = Disable the P0[4] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[5] state low-level or high-to-low change interrupt
                        0 = Disable the P0[5] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[6] state low-level or high-to-low change interrupt
                        0 = Disable the P0[6] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[7] state low-level or high-to-low change interrupt
                        0 = Disable the P0[7] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[0] level-high or low-to-high interrupt
                        0 = Disable the P0[0] level-high or low-to-high interrupt</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[1] level-high or low-to-high interrupt
                        0 = Disable the P0[1] level-high or low-to-high interrupt</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[2] level-high or low-to-high interrupt
                        0 = Disable the P0[2] level-high or low-to-high interrupt</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[3] level-high or low-to-high interrupt
                        0 = Disable the P0[3] level-high or low-to-high interrupt</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[4] level-high or low-to-high interrupt
                        0 = Disable the P0[4] level-high or low-to-high interrupt</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[5] level-high or low-to-high interrupt
                        0 = Disable the P0[5] level-high or low-to-high interrupt</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[6] level-high or low-to-high interrupt
                        0 = Disable the P0[6] level-high or low-to-high interrupt</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[7] level-high or low-to-high interrupt
                        0 = Disable the P0[7] level-high or low-to-high interrupt</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt Trigger Source</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[0] generate an interrupt
                        0 = No interrupt at P0[0]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[1] generate an interrupt
                        0 = No interrupt at P0[1]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[2] generate an interrupt
                        0 = No interrupt at P0[2]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[3] generate an interrupt
                        0 = No interrupt at P0[3]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[4] generate an interrupt
                        0 = No interrupt at P0[4]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[5] generate an interrupt
                        0 = No interrupt at P0[5]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[6] generate an interrupt
                        0 = No interrupt at P0[6]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[7] generate an interrupt
                        0 = No interrupt at P0[7]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x500040C0</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GP3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Bit Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[0] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[0] pin is in INPUT mode.
                        01 = P0[0] pin is in OUTPUT mode.
                        10 = P0[0] pin is in Open-Drain mode.
                        11 = P0[0] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[1] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[1] pin is in INPUT mode.
                        01 = P0[1] pin is in OUTPUT mode.
                        10 = P0[1] pin is in Open-Drain mode.
                        11 = P0[1] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[2] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[2] pin is in INPUT mode.
                        01 = P0[2] pin is in OUTPUT mode.
                        10 = P0[2] pin is in Open-Drain mode.
                        11 = P0[2] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[3] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[3] pin is in INPUT mode.
                        01 = P0[3] pin is in OUTPUT mode.
                        10 = P0[3] pin is in Open-Drain mode.
                        11 = P0[3] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[4] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[4] pin is in INPUT mode.
                        01 = P0[4] pin is in OUTPUT mode.
                        10 = P0[4] pin is in Open-Drain mode.
                        11 = P0[4] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[5] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[5] pin is in INPUT mode.
                        01 = P0[5] pin is in OUTPUT mode.
                        10 = P0[5] pin is in Open-Drain mode.
                        11 = P0[5] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[6] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[6] pin is in INPUT mode.
                        01 = P0[6] pin is in OUTPUT mode.
                        10 = P0[6] pin is in Open-Drain mode.
                        11 = P0[6] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[7] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[7] pin is in INPUT mode.
                        01 = P0[7] pin is in OUTPUT mode.
                        10 = P0[7] pin is in Open-Drain mode.
                        11 = P0[7] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Bit OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>OFFD: P0 Pin OFF digital input path Enable
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[0] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[1] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[2] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[3] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[4] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[5] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[6] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[7] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[0] bit can be updated
                        1 = The corresponding P0_DOUT[0] bit is protected</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[1] bit can be updated
                        1 = The corresponding P0_DOUT[1] bit is protected</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[2] bit can be updated
                        1 = The corresponding P0_DOUT[2] bit is protected</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[3] bit can be updated
                        1 = The corresponding P0_DOUT[3] bit is protected</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[4] bit can be updated
                        1 = The corresponding P0_DOUT[4] bit is protected</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[7] bit can be updated
                        1 = The corresponding P0_DOUT[7] bit is protected</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[0].</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[1].</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[2].</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[3].</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[4].</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[5].</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[6].</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[7].</description>
            <name>PIN7</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[0] de-bounce function is disabled
                        1 = The bit[0] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[1] de-bounce function is disabled
                        1 = The bit[1] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[2] de-bounce function is disabled
                        1 = The bit[2] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[3] de-bounce function is disabled
                        1 = The bit[3] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[4] de-bounce function is disabled
                        1 = The bit[4] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[5] de-bounce function is disabled
                        1 = The bit[5] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[6] de-bounce function is disabled
                        1 = The bit[6] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[7] de-bounce function is disabled
                        1 = The bit[7] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[0] state low-level or high-to-low change interrupt
                        0 = Disable the P0[0] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[1] state low-level or high-to-low change interrupt
                        0 = Disable the P0[1] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[2] state low-level or high-to-low change interrupt
                        0 = Disable the P0[2] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[3] state low-level or high-to-low change interrupt
                        0 = Disable the P0[3] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[4] state low-level or high-to-low change interrupt
                        0 = Disable the P0[4] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[5] state low-level or high-to-low change interrupt
                        0 = Disable the P0[5] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[6] state low-level or high-to-low change interrupt
                        0 = Disable the P0[6] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[7] state low-level or high-to-low change interrupt
                        0 = Disable the P0[7] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[0] level-high or low-to-high interrupt
                        0 = Disable the P0[0] level-high or low-to-high interrupt</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[1] level-high or low-to-high interrupt
                        0 = Disable the P0[1] level-high or low-to-high interrupt</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[2] level-high or low-to-high interrupt
                        0 = Disable the P0[2] level-high or low-to-high interrupt</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[3] level-high or low-to-high interrupt
                        0 = Disable the P0[3] level-high or low-to-high interrupt</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[4] level-high or low-to-high interrupt
                        0 = Disable the P0[4] level-high or low-to-high interrupt</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[5] level-high or low-to-high interrupt
                        0 = Disable the P0[5] level-high or low-to-high interrupt</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[6] level-high or low-to-high interrupt
                        0 = Disable the P0[6] level-high or low-to-high interrupt</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[7] level-high or low-to-high interrupt
                        0 = Disable the P0[7] level-high or low-to-high interrupt</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt Trigger Source</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[0] generate an interrupt
                        0 = No interrupt at P0[0]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[1] generate an interrupt
                        0 = No interrupt at P0[1]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[2] generate an interrupt
                        0 = No interrupt at P0[2]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[3] generate an interrupt
                        0 = No interrupt at P0[3]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[4] generate an interrupt
                        0 = No interrupt at P0[4]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[5] generate an interrupt
                        0 = No interrupt at P0[5]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[6] generate an interrupt
                        0 = No interrupt at P0[6]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[7] generate an interrupt
                        0 = No interrupt at P0[7]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004100</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GP4</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Bit Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[0] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[0] pin is in INPUT mode.
                        01 = P0[0] pin is in OUTPUT mode.
                        10 = P0[0] pin is in Open-Drain mode.
                        11 = P0[0] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[1] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[1] pin is in INPUT mode.
                        01 = P0[1] pin is in OUTPUT mode.
                        10 = P0[1] pin is in Open-Drain mode.
                        11 = P0[1] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[2] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[2] pin is in INPUT mode.
                        01 = P0[2] pin is in OUTPUT mode.
                        10 = P0[2] pin is in Open-Drain mode.
                        11 = P0[2] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[3] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[3] pin is in INPUT mode.
                        01 = P0[3] pin is in OUTPUT mode.
                        10 = P0[3] pin is in Open-Drain mode.
                        11 = P0[3] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[4] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[4] pin is in INPUT mode.
                        01 = P0[4] pin is in OUTPUT mode.
                        10 = P0[4] pin is in Open-Drain mode.
                        11 = P0[4] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[5] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[5] pin is in INPUT mode.
                        01 = P0[5] pin is in OUTPUT mode.
                        10 = P0[5] pin is in Open-Drain mode.
                        11 = P0[5] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[6] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[6] pin is in INPUT mode.
                        01 = P0[6] pin is in OUTPUT mode.
                        10 = P0[6] pin is in Open-Drain mode.
                        11 = P0[6] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>P0 I/O Pin[7] Mode Control
                        Determine each I/O type of P0 pins
                        00 = P0[7] pin is in INPUT mode.
                        01 = P0[7] pin is in OUTPUT mode.
                        10 = P0[7] pin is in Open-Drain mode.
                        11 = P0[7] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Bit OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>OFFD: P0 Pin OFF digital input path Enable
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[0] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[0] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[0] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[1] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[1] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[1] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[2] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[2] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[2] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[3] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[3] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[3] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[4] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[4] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[4] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[5] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[5] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[5] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[6] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[6] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[6] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin[7] Output Value
                        Each of these bits control the status of a P0 pin when the P0 pin is configures as output, open-drain and quasi-mode.
                        1 = P0 Pin[7] will drive High if the corresponding output mode enabling bit is set.
                        0 = P0 Pin[7] will drive Low if the corresponding output mode enabling bit is set.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[0]. When set the DMASK bit[0] to "1", the corresponding DOUT0 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[0] bit can be updated
                        1 = The corresponding P0_DOUT[0] bit is protected</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[1]. When set the DMASK bit[1] to "1", the corresponding DOUT1 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[1] bit can be updated
                        1 = The corresponding P0_DOUT[1] bit is protected</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[2]. When set the DMASK bit[2] to "1", the corresponding DOUT2 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[2] bit can be updated
                        1 = The corresponding P0_DOUT[2] bit is protected</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[3]. When set the DMASK bit[3] to "1", the corresponding DOUT3 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[3] bit can be updated
                        1 = The corresponding P0_DOUT[3] bit is protected</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[4]. When set the DMASK bit[4] to "1", the corresponding DOUT4 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[4] bit can be updated
                        1 = The corresponding P0_DOUT[4] bit is protected</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[6]. When set the DMASK bit[6] to "1", the corresponding DOUT6 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[6] bit can be updated
                        1 = The corresponding P0_DOUT[6] bit is protected</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Data Output Write Mask
                        These bits are used to protect the corresponding register of P0_DOUT bit[7]. When set the DMASK bit[7] to "1", the corresponding DOUT7 bit is protected. The write signal is masked, write data to the protect bit is ignored
                        0 = The corresponding P0_DOUT[7] bit can be updated
                        1 = The corresponding P0_DOUT[7] bit is protected</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[0].</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[1].</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[2].</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[3].</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[4].</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[5].</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[6].</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Pin Values
                        The value read from each of these bit reflects the actual status of the respective P0 Pin[7].</description>
            <name>PIN7</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[0] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[0] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[0] de-bounce function is disabled
                        1 = The bit[0] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[1] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[1] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[1] de-bounce function is disabled
                        1 = The bit[1] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[2] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[2] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[2] de-bounce function is disabled
                        1 = The bit[2] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[3] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[3] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[3] de-bounce function is disabled
                        1 = The bit[3] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[4] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[4] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[4] de-bounce function is disabled
                        1 = The bit[4] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[5] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[5] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[5] de-bounce function is disabled
                        1 = The bit[5] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[6] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[6] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[6] de-bounce function is disabled
                        1 = The bit[6] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0 Input Signal De-bounce Enable
                        DBEN[7] used to enable the de-bounce function for each corresponding bit. if the input signal pulse width can't be sampled by continuous two de-bounce sample cycle. The input signal transition is seen as the signal bounce and will not trigger the interrupt.
                        The DBEN[7] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        0 = The bit[7] de-bounce function is disabled
                        1 = The bit[7] de-bounce function is enabled
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[0] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[1] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[2] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[3] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[4] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[5] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[6] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Mode Control
                        IMD[7] used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger souce is control de-bounce. If the interrupt is by level trigger, the input source is sampled by one clock and the generate the interrupt
                        0 = Edge trigger interrupt
                        1 = Level trigger interrupt
                        if set pin as the level trigger interrupt, then only one level can be set on the registers P0_IEN.
                        if set both the level to trigger interrupt, the setting is ignored and no interrupt will occur.
                        The de-bounce function is valid for edge triggered interrupt. if the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[0] state low-level or high-to-low change interrupt
                        0 = Disable the P0[0] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[1] state low-level or high-to-low change interrupt
                        0 = Disable the P0[1] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[2] state low-level or high-to-low change interrupt
                        0 = Disable the P0[2] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[3] state low-level or high-to-low change interrupt
                        0 = Disable the P0[3] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[4] state low-level or high-to-low change interrupt
                        0 = Disable the P0[4] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[5] state low-level or high-to-low change interrupt
                        0 = Disable the P0[5] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[6] state low-level or high-to-low change interrupt
                        0 = Disable the P0[6] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port0 Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IF_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "low" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the P0[7] state low-level or high-to-low change interrupt
                        0 = Disable the P0[7] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[0] used to enable the interrupt for each of the corresponding input P0[0]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[0] bit "1":
                        If the interrupt is level mode trigger, the input P0[0] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[0] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[0] level-high or low-to-high interrupt
                        0 = Disable the P0[0] level-high or low-to-high interrupt</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[1] used to enable the interrupt for each of the corresponding input P0[1]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[1] bit "1":
                        If the interrupt is level mode trigger, the input P0[1] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[1] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[1] level-high or low-to-high interrupt
                        0 = Disable the P0[1] level-high or low-to-high interrupt</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[2] used to enable the interrupt for each of the corresponding input P0[2]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[2] bit "1":
                        If the interrupt is level mode trigger, the input P0[2] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[2] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[2] level-high or low-to-high interrupt
                        0 = Disable the P0[2] level-high or low-to-high interrupt</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[3] used to enable the interrupt for each of the corresponding input P0[3]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[3] bit "1":
                        If the interrupt is level mode trigger, the input P0[3] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[3] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[3] level-high or low-to-high interrupt
                        0 = Disable the P0[3] level-high or low-to-high interrupt</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[4] used to enable the interrupt for each of the corresponding input P0[4]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[4] bit "1":
                        If the interrupt is level mode trigger, the input P0[4] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[4] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[4] level-high or low-to-high interrupt
                        0 = Disable the P0[4] level-high or low-to-high interrupt</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[5] used to enable the interrupt for each of the corresponding input P0[5]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[5] bit "1":
                        If the interrupt is level mode trigger, the input P0[5] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[5] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[5] level-high or low-to-high interrupt
                        0 = Disable the P0[5] level-high or low-to-high interrupt</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[6] used to enable the interrupt for each of the corresponding input P0[6]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[6] bit "1":
                        If the interrupt is level mode trigger, the input P0[6] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[6] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[6] level-high or low-to-high interrupt
                        0 = Disable the P0[6] level-high or low-to-high interrupt</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[7] used to enable the interrupt for each of the corresponding input P0[7]. Set bit "1" also enable the pin wakeup function.
                        When set the IR_EN[7] bit "1":
                        If the interrupt is level mode trigger, the input P0[7] state at level "high" will generate the interrupt.
                        If the interrupt is edge mode trigger, the input P0[7] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the P0[7] level-high or low-to-high interrupt
                        0 = Disable the P0[7] level-high or low-to-high interrupt</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Interrupt Trigger Source</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[0] generate an interrupt
                        0 = No interrupt at P0[0]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[1] generate an interrupt
                        0 = No interrupt at P0[1]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[2] generate an interrupt
                        0 = No interrupt at P0[2]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[3] generate an interrupt
                        0 = No interrupt at P0[3]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[4] generate an interrupt
                        0 = No interrupt at P0[4]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[5] generate an interrupt
                        0 = No interrupt at P0[5]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[6] generate an interrupt
                        0 = No interrupt at P0[6]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port 0 Interrupt Trigger Source Indicator
                        Read:
                        1 = Indicates P0[7] generate an interrupt
                        0 = No interrupt at P0[7]
                        Write:
                        1 = Clear the correspond pending interrupt
                        0 = No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x4</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004180</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_GCR</groupName>
    <interrupts></interrupts>
    <name>GPIO</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt De-bounce Cycle Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>De-bounce sampling cycle selection
                        DBCLKSEL	Description	
                        0	Sample interrupt input once per 1 clocks	
                        1	Sample interrupt input once per 2 clocks	
                        2	Sample interrupt input once per 4 clocks	
                        3	Sample interrupt input once per 8 clocks	
                        4	Sample interrupt input once per 16 clocks	
                        5	Sample interrupt input once per 32 clocks	
                        6	Sample interrupt input once per 64 clocks	
                        7	Sample interrupt input once per 128 clocks	
                        8	Sample interrupt input once per 256 clocks	
                        9	Sample interrupt input once per 2*256 clocks	
                        10	Sample interrupt input once per 4*256clocks	
                        11	Sample interrupt input once per 8*256 clocks	
                        12	Sample interrupt input once per 16*256 clocks	
                        13	Sample interrupt input once per 32*256 clocks	
                        14	Sample interrupt input once per 64*256 clocks	
                        15	Sample interrupt input once per 128*256 clocks	</description>
            <name>DBCLKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>De-bounce counter clock source select
                        1 = De-bounce counter clock source is the internal 10KHz clock
                        0 = De-bounce counter clock source is the HCLK</description>
            <name>DBCLKSRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt clock On mode
                        Set this bit "0" will disable the interrupt generate circuit clock, if the pin[n] interrupt is disabled
                        0 = disable the clock if the P0/1/2/3/4[n] interrupt is disabled
                        1 = interrupt generated circuit clock always enable 
                        n=0~7</description>
            <name>ICLK_ON</name>
          </field>
        </fields>
        <name>DBNCECON</name>
        <resetMask>0xFFFFFFDF</resetMask>
        <resetValue>0x20</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x200</offset>
      <size>0x20</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004200</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GP0_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Px.0 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.0 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px0_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Px.1 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.1 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px1_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>Px.2 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.2 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px2_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>Px.3 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.3 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px3_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Px.4 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.4 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px4_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Px.5 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.5 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px5_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>Px.6 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.6 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px6_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>Px.7 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.7 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px7_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x200</offset>
      <size>0x20</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004220</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GP1_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Px.0 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.0 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px0_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Px.1 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.1 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px1_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>Px.2 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.2 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px2_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>Px.3 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.3 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px3_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Px.4 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.4 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px4_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Px.5 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.5 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px5_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>Px.6 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.6 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px6_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>Px.7 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.7 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px7_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x200</offset>
      <size>0x20</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004240</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GP2_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Px.0 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.0 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px0_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Px.1 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.1 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px1_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>Px.2 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.2 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px2_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>Px.3 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.3 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px3_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Px.4 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.4 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px4_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Px.5 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.5 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px5_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>Px.6 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.6 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px6_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>Px.7 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.7 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px7_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x200</offset>
      <size>0x20</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004260</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GP3_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Px.0 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.0 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px0_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Px.1 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.1 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px1_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>Px.2 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.2 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px2_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>Px.3 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.3 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px3_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Px.4 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.4 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px4_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Px.5 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.5 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px5_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>Px.6 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.6 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px6_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>Px.7 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.7 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px7_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x200</offset>
      <size>0x20</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004280</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GP4_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>Px.0 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.0 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px0_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Px.1 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.1 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px1_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>Px.2 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.2 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px2_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>Px.3 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.3 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px3_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>Px.4 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.4 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px4_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Px.5 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.5 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px5_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x218</addressOffset>
        <description>Px.6 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.6 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px6_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x21C</addressOffset>
        <description>Px.7 Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>P0.7 I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>Px7_DOUT</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40020000</baseAddress>
    <description>Registers group</description>
    <groupName>I2C</groupName>
    <interrupts></interrupts>
    <name>I2C</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I2C Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert Acknowledge control bit. 
                        When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.</description>
            <name>AA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C Interrupt Flag. 
                        When a new SIO state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing one to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>SI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C STOP Flag. 
                        In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this flag will be cleared by hardware automatically.
                        In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
            <name>STO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C START Flag. 
                        Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
            <name>STA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C controller is enabled/disable
                        1 = Enable
                        0 = Disable
                        Set to enable I2C serial function block. When ENS=1 the I2C serial function enables. The multi-function pin function of SDA and SCL must set to I2C function first.</description>
            <name>ENSI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable interrupt. 
                        1 = Enable I2C interrupt.
                        0 = Disable I2C interrupt. </description>
            <name>EI</name>
          </field>
        </fields>
        <name>I2CON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>I2C slave Address Register0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I2C DATA Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Data Register
                        Bit[7:0] is located with the 8-bit transferred data of I2C serial port. </description>
            <name>I2CDAT</name>
          </field>
        </fields>
        <name>I2CDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>I2C Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Status Register 
                        The status register of I2C:
                        The three least significant bits are always 0. The five most significant bits contain the status code. There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is requested. All other I2STATUS values correspond to defined I2C states. When each of these states is entered, a status interrupt is requested (SI = 1). A valid status code is present in I2STATUS one machine cycle after SI is set by hardware and is still present one machine cycle after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
            <name>I2CSTATUS</name>
          </field>
        </fields>
        <name>I2CSTATUS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xF8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>I2C clock divided Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C clock divided Register
                        The I2C clock rate bits: Data Baud Rate of I2C = PCLK /(4x(I2CLK+1)).</description>
            <name>I2CLK</name>
          </field>
        </fields>
        <name>I2CLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>I2C Time out control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out flag. 
                        1 = Time-Out falg is set by H/W. It can interrupt CPU.
                        0 = S/W can clear the flag.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out counter input clock is divider by 4 
                        1 = Enable
                        0 = Disable
                        When Enable, The time-Out period is prolong 4 times.</description>
            <name>DIV4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-out counter is enabled/disable
                        1 = Enable
                        0 = Disable
                        When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.</description>
            <name>ENTI</name>
          </field>
        </fields>
        <name>I2CTOC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>I2C slave Address Register1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>I2C slave Address Register2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I2C slave Address Register3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I2C Slave address Mask Register0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2ADMx</name>
          </field>
        </fields>
        <name>I2CADM0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I2C Slave address Mask Register1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2ADMx</name>
          </field>
        </fields>
        <name>I2CADM1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>I2C Slave address Mask Register2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2ADMx</name>
          </field>
        </fields>
        <name>I2CADM2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I2C Slave address Mask Register3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask register. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2ADMx</name>
          </field>
        </fields>
        <name>I2CADM3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x40</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000300</baseAddress>
    <description>Registers group</description>
    <groupName>INT</groupName>
    <interrupts></interrupts>
    <name>INT</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>MCU IRQ0 (BOD) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: BOD_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ0_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>MCU IRQ1 (WDT) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: WDT_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ1_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>MCU IRQ2 ((EINT0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: EINT0 - external interrupt 0 from P3.2</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ2_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>MCU IRQ3 (EINT1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: EINT1 - external interrupt 1 from P3.3</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ3_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>MCU IRQ4 (P0/1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1: P1_INT
                        Bit0: P0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ4_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>MCU IRQ5 (P2/3/4) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: P4_INT
                        Bit1: P3_INT
                        Bit0: P2_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ5_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>MCU IRQ6 (PWMA) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Bit3: PWM3_INT
                        Bit2: PWM2_INT
                        Bit1: PWM1_INT
                        Bit0: PWM0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ6_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>MCU IRQ7 (PWMB) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Bit3: PWM7_INT
                        Bit2: PWM6_INT
                        Bit1: PWM5_INT
                        Bit0: PWM4_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ7_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>MCU IRQ8 (TMR0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: TMR0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ8_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>MCU IRQ9 (TMR1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: TMR1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ9_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>MCU IRQ10 (TMR2) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: TMR2_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ10_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>MCU IRQ11 (TMR3) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: TMR3_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ11_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>MCU IRQ12 (URT0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: URT0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ12_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>MCU IRQ13 (URT1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: URT1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ13_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>MCU IRQ14 (SPI0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: SPI0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ14_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3C</addressOffset>
        <description>MCU IRQ15 (SPI1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: SPI1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ15_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>MCU IRQ18 (I2C) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: I2C_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ18_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x54</addressOffset>
        <description>MCU IRQ21 (Reserved) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Reserved</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ21_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x58</addressOffset>
        <description>MCU IRQ22 (Reserved) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Reserved</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ22_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70</addressOffset>
        <description>MCU IRQ28 (PWRWU) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: PWRWU_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ28_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x74</addressOffset>
        <description>MCU IRQ29 (ADC) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2 = 0
                        Bit1 = 0
                        Bit0: ADC_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ29_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x78</addressOffset>
        <description>MCU IRQ30 (Reserved) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Reserved</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ30_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>NMI source interrupt select control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>The NMI interrupt to Cortex-M0 can be selected from one of the interrupt[31:0]
                        The NMI_SEL bit[4:0] used to select the NMI interrupt source</description>
            <name>NMI_SEL</name>
          </field>
        </fields>
        <name>NMI_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>MCU IRQ Number identify register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>MCU IRQ Source Register 
                        The MCU_IRQ collect all the interrupts from the peripherals and generate the synchronous interrupt to MCU Cortex-M0. There are two modes to generate interrupt to MCU Cortex-M0, the normal mode and test mode.
                        The MCU_IRQ collects all interrupts from each peripheral and synchronizes them then interrupts the Cortex-M0. 
                        When the MCU_IRQ[n] is "0": Set MCU_IRQ[n] "1" will generate an interrupt to Cortex_M0 NVIC[n].
                        When the MCU_IRQ[n] is "1"(mean an interrupt is assert) set 1 the MCU_bit[n] will clear the interrupt
                        Set MCU_IRQ[n] "0": no any effect</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>MCU_IRQ</name>
          </field>
        </fields>
        <name>MCU_IRQ</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x3C</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40040000</baseAddress>
    <description>Registers group</description>
    <groupName>PWM</groupName>
    <interrupts></interrupts>
    <name>PWMA</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PWM Pre-scalar Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock pre-scalar 0(PWM counter 0 &amp; 1 for group A and PWM counter 4 &amp; 5 for group B)
                        Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
                        If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM counter will be stopped also.</description>
            <name>CP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock pre-scalar 2(PWM counter 2 &amp; 3 for group A and PWM counter 6 &amp; 7 for group B)
                        Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
                        If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM counter will be stopped also.</description>
            <name>CP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI23</name>
          </field>
        </fields>
        <name>PPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PWM Clock Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
                        Select clock input for timer.
                        (Table is the same as CSR3)</description>
            <name>CSR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
                        Select clock input for timer.
                        (Table is the same as CSR3)</description>
            <name>CSR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
                        Select clock input for timer.
                        (Table is the same as CSR3)</description>
            <name>CSR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
                        Select clock input for timer.
                        CSR3 [14:12]	Input clock divided by	
                        100	1	
                        011	16	
                        010	8	
                        001	4	
                        000	2	</description>
            <name>CSR3</name>
          </field>
        </fields>
        <name>CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PWM Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH0INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.</description>
            <name>CH0MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
            <name>DZEN01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
            <name>DZEN23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH1INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.</description>
            <name>CH1MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH2INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.</description>
            <name>CH2MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH3INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.</description>
            <name>CH3MOD</name>
          </field>
        </fields>
        <name>PCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PWM Counter Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>PWM Comparator Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PWM Data Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>PWM Counter Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>PWM Comparator Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>PWM Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PWM Counter Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>PWM Comparator Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>PWM Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>PWM Counter Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>PWM Comparator Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>PWM Data Register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>PWM Interrupt Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 0 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 1 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 2 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 3 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE3</name>
          </field>
        </fields>
        <name>PIER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>PWM Interrupt Indication Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 0 Interrupt Status
                        Flag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 1 Interrupt Status
                        Flag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 2 Interrupt Status
                        Flag is set by hardware when PWM2 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 3 Interrupt Status
                        Flag is set by hardware when PWM3 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF3</name>
          </field>
        </fields>
        <name>PIIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Capture Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 0 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 0 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 0.
                        0 = Disable capture function on PWM group channel 0
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
            <name>CAPCH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture0 Interrupt Indication Flag
                        
                        If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR0 Latched Indicator Bit
                        
                        When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR0 Latched Indicator Bit
                        
                        When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 1 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 1 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 1.
                        0 = Disable capture function on PWM group channel 1
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
            <name>CAPCH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture1 Interrupt Indication Flag
                        
                        If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR1 Latched Indicator Bit
                        
                        When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR1 Latched Indicator Bit
                        
                        When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI1</name>
          </field>
        </fields>
        <name>CCR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Capture Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 2 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 2 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 2.
                        0 = Disable capture function on PWM group channel 2
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
            <name>CAPCH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture2 Interrupt Indication Flag
                        
                        If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR2 Latched Indicator Bit
                        
                        When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR2 Latched Indicator Bit
                        
                        When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 3 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 3 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 3.
                        0 = Disable capture function on PWM group channel 3
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
            <name>CAPCH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture3 Interrupt Indication Flag
                        
                        If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR3 Latched Indicator Bit
                        
                        When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR3 Latched Indicator Bit
                        
                        When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI3</name>
          </field>
        </fields>
        <name>CCR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x58</addressOffset>
        <description>Capture Rising Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5C</addressOffset>
        <description>Capture Falling Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 01/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>Capture Rising Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>Capture Falling Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 01/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Capture Rising Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x6C</addressOffset>
        <description>Capture Falling Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70</addressOffset>
        <description>Capture Rising Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x74</addressOffset>
        <description>Capture Falling Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>Capture Input Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Capture Input Enable Register
                        There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or OFF. 
                        0 = OFF (PWMx multi-function pin input does not affect input capture function.)
                        1 = (PWMx multi-function pin input will affect its input capture function.)
                        
                        
                        
                        CAPENR
                        Bit 3210 for PWM group A
                        Bit xxx1 -&gt; Capture channel 0 is from P2 [0] 
                        Bit xx1x -&gt; Capture channel 1 is from P2 [1] 
                        Bit x1xx -&gt; Capture channel 2 is from P2 [2]
                        Bit 1xxx -&gt; Capture channel 3 is from P2 [3]
                        Bit 3210 for PWM group B
                        Bit xxx1 -&gt; Capture channel 0 is from P2 [4] 
                        Bit xx1x -&gt; Capture channel 1 is from P2 [5] 
                        Bit x1xx -&gt; Capture channel 2 is from P2 [6]
                        Bit 1xxx -&gt; Capture channel 3 is from P2 [7]</description>
            <name>CAPENR</name>
          </field>
        </fields>
        <name>CAPENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>PWM Output Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Output Enable Register
                        1 = Enable PWM channel 0 output to pin.
                        0 = Disable PWM channel 0 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Output Enable Register
                        1 = Enable PWM channel 1 output to pin.
                        0 = Disable PWM channel 1 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Output Enable Register
                        1 = Enable PWM channel 2 output to pin.
                        0 = Disable PWM channel 2 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Output Enable Register
                        1 = Enable PWM channel 3 output to pin.
                        0 = Disable PWM channel 3 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM3</name>
          </field>
        </fields>
        <name>POE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x3C</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40140000</baseAddress>
    <description>Registers group</description>
    <groupName>PWM</groupName>
    <interrupts></interrupts>
    <name>PWMB</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PWM Pre-scalar Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock pre-scalar 0(PWM counter 0 &amp; 1 for group A and PWM counter 4 &amp; 5 for group B)
                        Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM counter
                        If CP01=0, then the pre-scalar 0 output clock will be stopped. So corresponding PWM counter will be stopped also.</description>
            <name>CP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock pre-scalar 2(PWM counter 2 &amp; 3 for group A and PWM counter 6 &amp; 7 for group B)
                        Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM counter
                        If CP23=0, then the pre-scalar 2 output clock will be stopped. So corresponding PWM counter will be stopped also.</description>
            <name>CP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead zone interval register for pair of channel 0 and channel 1(PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead zone interval register for pair of channel 2 and channel 3(PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI23</name>
          </field>
        </fields>
        <name>PPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PWM Clock Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
                        Select clock input for timer.
                        (Table is the same as CSR3)</description>
            <name>CSR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
                        Select clock input for timer.
                        (Table is the same as CSR3)</description>
            <name>CSR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
                        Select clock input for timer.
                        (Table is the same as CSR3)</description>
            <name>CSR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
                        Select clock input for timer.
                        CSR3 [14:12]	Input clock divided by	
                        100	1	
                        011	16	
                        010	8	
                        001	4	
                        000	2	</description>
            <name>CSR3</name>
          </field>
        </fields>
        <name>CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PWM Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Enable/Disable Start Run (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Output Inverter ON/OFF(PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH0INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Auto-reload/One-Shot Mode(PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.</description>
            <name>CH0MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 0 Generator Enable/Disable(PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
            <name>DZEN01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 2 Generator Enable/Disable(PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
            <name>DZEN23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Enable/Disable Start Run (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Output Inverter ON/OFF(PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH1INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Auto-reload/One-Shot Mode(PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.</description>
            <name>CH1MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Enable/Disable Start Run (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Output Inverter ON/OFF(PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH2INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Auto-reload/One-Shot Mode(PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.</description>
            <name>CH2MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Enable/Disable Start Run (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Output Inverter ON/OFF(PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Inverter ON
                        0 = Inverter OFF</description>
            <name>CH3INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Auto-reload/One-Shot Mode(PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.</description>
            <name>CH3MOD</name>
          </field>
        </fields>
        <name>PCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PWM Counter Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>PWM Comparator Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PWM Data Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>PWM Counter Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>PWM Comparator Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>PWM Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PWM Counter Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>PWM Comparator Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>PWM Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>PWM Counter Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>PWM Comparator Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CNR determines the PWM duty.
                        
                        PWM frequency = PWMxy_CLK/(prescale+1)/(clock divider)/(CNR+1); where xy, could be 01, 23, 45 or 67, depends on selected PWM channel.
                        
                        Duty ratio = (CMR+1)/(CNR+1).
                        
                        CMR &gt;= CNR: PWM output is always high.
                        
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        
                        (Unit = one PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>PWM Data Register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know the current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>PWM Interrupt Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 0 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 1 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 2 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 3 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE3</name>
          </field>
        </fields>
        <name>PIER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>PWM Interrupt Indication Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 0 Interrupt Status
                        Flag is set by hardware when PWM0 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 1 Interrupt Status
                        Flag is set by hardware when PWM1 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 2 Interrupt Status
                        Flag is set by hardware when PWM2 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM channel 3 Interrupt Status
                        Flag is set by hardware when PWM3 down counter reaches zero, software can clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF3</name>
          </field>
        </fields>
        <name>PIIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Capture Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 0 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 0 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 0 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 0 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 0.
                        0 = Disable capture function on PWM group channel 0
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
            <name>CAPCH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture0 Interrupt Indication Flag
                        
                        If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR0 Latched Indicator Bit
                        
                        When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR0 Latched Indicator Bit
                        
                        When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 1 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 1 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 1 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 1 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 1.
                        0 = Disable capture function on PWM group channel 1
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
            <name>CAPCH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture1 Interrupt Indication Flag
                        
                        If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR1 Latched Indicator Bit
                        
                        When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR1 Latched Indicator Bit
                        
                        When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI1</name>
          </field>
        </fields>
        <name>CCR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Capture Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 2 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 2 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 2 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 2 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 2.
                        0 = Disable capture function on PWM group channel 2
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
            <name>CAPCH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture2 Interrupt Indication Flag
                        
                        If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR2 Latched Indicator Bit
                        
                        When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR2 Latched Indicator Bit
                        
                        When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 3 Inverter ON/OFF
                        
                        1 = Inverter ON. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter OFF</description>
            <name>INV3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 3 Rising Latch Interrupt Enable ON/OFF
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Group Channel 3 Falling Latch Interrupt Enable ON/OFF
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture Channel 3 transition Enable/Disable
                        1 = Enable capture function on PWM group channel 3.
                        0 = Disable capture function on PWM group channel 3
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
            <name>CAPCH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Capture3 Interrupt Indication Flag
                        
                        If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1). This flag is clear by software with a write 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR3 Latched Indicator Bit
                        
                        When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CRLRI3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR3 Latched Indicator Bit
                        
                        When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        
                        Clear this bit by writing a one to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CFLRI3</name>
          </field>
        </fields>
        <name>CCR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x58</addressOffset>
        <description>Capture Rising Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5C</addressOffset>
        <description>Capture Falling Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 01/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>Capture Rising Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>Capture Falling Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 01/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Capture Rising Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x6C</addressOffset>
        <description>Capture Falling Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70</addressOffset>
        <description>Capture Rising Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x74</addressOffset>
        <description>Capture Falling Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 0/1/2/3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>Capture Input Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Capture Input Enable Register
                        There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs ON or OFF. 
                        0 = OFF (PWMx multi-function pin input does not affect input capture function.)
                        1 = (PWMx multi-function pin input will affect its input capture function.)
                        
                        
                        
                        CAPENR
                        Bit 3210 for PWM group A
                        Bit xxx1 -&gt; Capture channel 0 is from P2 [0] 
                        Bit xx1x -&gt; Capture channel 1 is from P2 [1] 
                        Bit x1xx -&gt; Capture channel 2 is from P2 [2]
                        Bit 1xxx -&gt; Capture channel 3 is from P2 [3]
                        Bit 3210 for PWM group B
                        Bit xxx1 -&gt; Capture channel 0 is from P2 [4] 
                        Bit xx1x -&gt; Capture channel 1 is from P2 [5] 
                        Bit x1xx -&gt; Capture channel 2 is from P2 [6]
                        Bit 1xxx -&gt; Capture channel 3 is from P2 [7]</description>
            <name>CAPENR</name>
          </field>
        </fields>
        <name>CAPENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>PWM Output Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Output Enable Register
                        1 = Enable PWM channel 0 output to pin.
                        0 = Disable PWM channel 0 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Output Enable Register
                        1 = Enable PWM channel 1 output to pin.
                        0 = Disable PWM channel 1 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Output Enable Register
                        1 = Enable PWM channel 2 output to pin.
                        0 = Disable PWM channel 2 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Output Enable Register
                        1 = Enable PWM channel 3 output to pin.
                        0 = Disable PWM channel 3 output to pin.
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM3</name>
          </field>
        </fields>
        <name>POE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x10</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0xE000E000</baseAddress>
    <description>Registers group</description>
    <groupName>SCS</groupName>
    <interrupts></interrupts>
    <name>SCS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SysTick Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = The counter will operate in a multi-shot manner.
                        0 = The counter is disabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended.
                        0 = Counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to zero has occurred.</description>
            <name>TICKINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Core clock used for SysTick.
                        0 = Clock source is optional, refer to STCLK_S.</description>
            <name>CLKSRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Returns 1 if timer counted to 0 since last time this register was read.
                        COUNTFLAG is set by a count transition from 1 to 0.
                        COUNTFLAG is cleared on read or by a write to the Current Value register.</description>
            <name>COUNTFLAG</name>
            <readAction>modify</readAction>
          </field>
        </fields>
        <name>SYST_CSR</name>
        <resetMask>0xFFFFFFFB</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SysTick Reload value Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Value to load into the Current Value register when the counter reaches 0.</description>
            <name>RELOAD</name>
          </field>
        </fields>
        <name>SYST_RVR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>SysTick Current value Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Current counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0. Unsupported bits RAZ (see SysTick Reload Value register).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CURRENT</name>
          </field>
        </fields>
        <name>SYST_CVR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>IRQ0 ~ IRQ31 Set-Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). 
                        Writing 1 will enable the associated interrupt.
                        Writing 0 has no effect.
                        The register reads back with the current enable state.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SETENA</name>
          </field>
        </fields>
        <name>NVIC_ISER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>IRQ0 ~ IRQ31 Clear-Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Disable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). 
                        Writing 1 will disable the associated interrupt.
                        Writing 0 has no effect.
                        The register reads back with the current enable state.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRENA</name>
          </field>
        </fields>
        <name>NVIC_ICER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>IRQ0 ~ IRQ31 Set-Pending Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 to a bit pends the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).
                        Writing 0 has no effect.
                        The register reads back with the current pending state.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SETPEND</name>
          </field>
        </fields>
        <name>NVIC_ISPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x280</addressOffset>
        <description>IRQ0 ~ IRQ31 Clear-Pending Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 to a bit un-pends the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).
                        Writing 0 has no effect.
                        The register reads back with the current pending state.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRPEND</name>
          </field>
        </fields>
        <name>NVIC_ICPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>IRQ0 ~ IRQ3 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ0
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ1
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ2
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ3
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_3</name>
          </field>
        </fields>
        <name>NVIC_IPR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x404</addressOffset>
        <description>IRQ4 ~ IRQ7 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ4
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ5
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ6
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ7
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_7</name>
          </field>
        </fields>
        <name>NVIC_IPR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x408</addressOffset>
        <description>IRQ8 ~ IRQ11 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ8
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ9
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ10
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ11
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_11</name>
          </field>
        </fields>
        <name>NVIC_IPR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40C</addressOffset>
        <description>IRQ12 ~ IRQ15 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ12
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ13
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ14
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ15
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_15</name>
          </field>
        </fields>
        <name>NVIC_IPR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x410</addressOffset>
        <description>IRQ16 ~ IRQ19 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ16
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_16</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ17
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_17</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ18
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_18</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ19
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_19</name>
          </field>
        </fields>
        <name>NVIC_IPR4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x414</addressOffset>
        <description>IRQ20 ~ IRQ23 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ20
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_20</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ21
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_21</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ22
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_22</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ23
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_23</name>
          </field>
        </fields>
        <name>NVIC_IPR5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x418</addressOffset>
        <description>IRQ24 ~ IRQ27 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ24
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_24</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ25
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_25</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ26
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_26</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ27
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_27</name>
          </field>
        </fields>
        <name>NVIC_IPR6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x41C</addressOffset>
        <description>IRQ28 ~ IRQ31 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ28
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_28</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ29
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_29</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ30
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_30</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ31
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_31</name>
          </field>
        </fields>
        <name>NVIC_IPR7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD00</addressOffset>
        <description>CPUID Base Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Reads as 0x0</description>
            <name>REVISION</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Reads as 0xC20.</description>
            <name>PARTNO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Reads as 0xC for ARMv6-M parts</description>
            <name>PART</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Implementer code assigned by ARM. ( ARM = 0x41)</description>
            <name>IMPLEMENTER</name>
          </field>
        </fields>
        <name>CPUID</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x410CC200</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD04</addressOffset>
        <description>Interrupt Control State Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>0 = Thread mode
                        value &gt; 1: the exception number for the current executing exception.</description>
            <name>VECTACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Indicates the exception number for the highest priority pending exception. The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier. A value of zero indicates no pending exceptions.</description>
            <name>VECTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates if an external configurable (NVIC generated) interrupt is pending.</description>
            <name>ISRPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If set, a pending exception will be serviced on exit from the debug halt state.</description>
            <name>ISRPREEMPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write 1 to clear a pending SysTick.</description>
            <name>PENDSTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set a pending SysTick. Reads back with current state (1 if Pending, 0 if not).</description>
            <name>PENDSTSET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write 1 to clear a pending PendSV interrupt.</description>
            <name>PENDSVCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set a pending PendSV interrupt. This is normally used to request a context switch. Reads back with current state (1 if Pending, 0 if not).</description>
            <name>PENDSVSET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. Reads back with current state (1 if Pending, 0 if not).</description>
            <name>NMIPENDSET</name>
          </field>
        </fields>
        <name>ICSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD0C</addressOffset>
        <description>Application Interrupt and Reset Control Register</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set this bit to 1 will clears all active state information for fixed and configurable exceptions. The bit is a write only bit and can only be written when the core is halted. Note: It is the debugger's responsibility to re-initialize the stack. </description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>VECTCLRACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested. The bit is a write only bit and self-clears as part of the reset sequence. </description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SYSRESETREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When write this register, this field should be 0x05FA, otherwise the write action will be unpredictable. </description>
            <name>VECTORKEY</name>
          </field>
        </fields>
        <name>AIRCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD10</addressOffset>
        <description>System Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1, the core can enter a sleep state on an exception return to Thread mode. This is the mode and exception level entered at reset, the base level of execution.</description>
            <name>SLEEPONEXIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A qualifying hint that indicates waking from sleep might take longer.</description>
            <name>SLEEPDEEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When enabled, interrupt transitions from Inactive to Pending are included in the list of wakeup events for the WFE instruction.</description>
            <name>SEVONPEND</name>
          </field>
        </fields>
        <name>SCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD1C</addressOffset>
        <description>System Handler Priority Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of system handler 11 - SVCall
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_11</name>
          </field>
        </fields>
        <name>SHPR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD20</addressOffset>
        <description>System Handler Priority Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of system handler 14 - PendSV
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of system handler 15 - SysTick
                        "0" denotes the highest priority &amp; "3" denotes lowest priority</description>
            <name>PRI_15</name>
          </field>
        </fields>
        <name>SHPR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010000</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle.	
                        11	Reserved 	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010020</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle.	
                        11	Reserved 	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40110000</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle.	
                        11	Reserved 	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40110020</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle.	
                        11	Reserved 	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x4</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40004000</baseAddress>
    <description>Registers group</description>
    <groupName>WDT</groupName>
    <interrupts></interrupts>
    <name>WDT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Watchdog Timer Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Watchdog Timer 
                        Set this bit will clear the Watchdog timer. 
                        0= Writing 0 to this bit has no effect
                        1= Reset the contents of the Watchdog timer
                        NOTE: This bit will auto clear after few clock cycle</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>WTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Reset Enable
                        Setting this bit will enable the Watchdog timer reset function.
                        0= Disable Watchdog timer reset function
                        1= Enable Watchdog timer reset function</description>
            <name>WTRE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Reset Flag
                        When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing 1 to it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.
                        0= Watchdog timer reset does not occur
                        1= Watchdog timer reset occurs
                        NOTE: This bit is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WTRF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Interrupt Flag
                        If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred. If the Watchdog timer interrupt is not enabled, then this bit indicates that a timeout period has elapsed.
                        0= Watchdog timer interrupt does not occur
                        1= Watchdog timer interrupt occurs
                        NOTE: Write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WTIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Wakeup Function Enable bit
                        0 = Disable Watchdog timer Wakeup CPU function.
                        1 = Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down mode.</description>
            <name>WTWKE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Wakeup Flag
                        If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.
                        1 = CPU wake up from sleep or power-down mode by Watchdog timeout.
                        0 = Watchdog timer does not cause CPU wakeup.
                        NOTE: Write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WTWKF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Interrupt Enable
                        0= Disable the Watchdog timer interrupt
                        1= Enable the Watchdog timer interrupt</description>
            <name>WTIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Enable
                        0= Disable the Watchdog timer (This action will reset the internal counter)
                        1= Enable the Watchdog timer</description>
            <name>WTE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Watchdog Timer Interval Select (write protection bit)
                        These three bits select the timeout interval for the Watchdog timer. 
                        WTIS	Timeout Interval Selection	Interrupt Period	WTR Timeout Interval (WDT_CLK=12MHz)	
                        000	2^4 * WDT_CLK	(2^4 + 1024) * WDT_CLK	1.33 us ~ 86.67 us	
                        001	2^6 * WDT_CLK	(2^6 + 1024) * WDT_CLK	5.33 us ~ 90.67 us	
                        010	2^8 * WDT_CLK	(2^8 + 1024) * WDT_CLK	21.33 us ~ 106.67 us	
                        011	2^10 * WDT_CLK	(2^10 + 1024) * WDT_CLK	85.33 us ~ 170.67 us	
                        100	2^12 * WDT_CLK	(2^12 + 1024) * WDT_CLK	341.33 us ~ 426.67 us	
                        101	2^14 * WDT_CLK	(2^14 + 1024) * WDT_CLK	1.36 ms ~ 1.45 ms	
                        110	2^16 * WDT_CLK	(2^16 + 1024) * WDT_CLK	5.46 ms ~ 5.55 ms	
                        111	2^18 * WDT_CLK	(2^18 + 1024) * WDT_CLK	21.84 ms ~ 21.93 ms	</description>
            <name>WTIS</name>
          </field>
        </fields>
        <name>WTCR</name>
        <resetMask>0xFFFFF8FF</resetMask>
        <resetValue>0x700</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40030000</baseAddress>
    <description>Registers group</description>
    <groupName>SPI</groupName>
    <interrupts></interrupts>
    <name>SPI0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Go and Busy Status
                        1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
                        0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
                        During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.
                        NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>GO_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive At Negative Edge
                        1 = The received data input signal is latched at the falling edge of SPICLK.
                        0 = The received data input signal is latched at the rising edge of SPICLK.</description>
            <name>RX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit At Negative Edge
                        1 = The transmitted data output signal is changed at the falling edge of SPICLK.
                        0 = The transmitted data output signal is changed at the rising edge of SPICLK.</description>
            <name>TX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Transmit Bit Length
                        This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted.
                        TX_BIT_LEN = 0x01 ... 1 bit
                        TX_BIT_LEN = 0x02 ... 2 bits
                        ......
                        TX_BIT_LEN = 0x1f ... 31 bits
                        TX_BIT_LEN = 0x00 .. 32 bits</description>
            <name>TX_BIT_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Numbers of Transmit/Receive Word
                        This field specifies how many transmit/receive word numbers should be executed in one transfer.
                        00 = Only one transmit/receive word will be executed in one transfer.
                        01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
                        10 = Reserved.
                        11 = Reserved.</description>
            <name>TX_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First
                        1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
                        0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).</description>
            <name>LSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity
                        1 = SPICLK idle high.
                        0 = SPICLK idle low.</description>
            <name>CLKP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Suspend Interval (master only)
                        These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation:
                        (SP_CYCLE[3:0] + 2)*period of SPI clock
                        SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
                        SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
                        ......
                        SP_CYCLE = 0xe ... 16 SPICLK clock cycle
                        SP_CYCLE = 0xf ... 17 SPICLK clock cycle</description>
            <name>SP_CYCLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Flag
                        1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
                        0 = It indicates that the transfer does not finish yet.
                        NOTE: This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable
                        1 = Enable MICROWIRE/SPI Interrupt.
                        0 = Disable MICROWIRE/SPI Interrupt.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SLAVE Mode Indication
                        1 = Slave mode.
                        0 = Master mode.</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reorder Mode Select
                        00 = Disable both byte reorder and byte suspend functions.
                        01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        10 = Enable byte reorder function, but disable byte suspend function.
                        11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.</description>
            <name>REORDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Variable Clock Enable (master only)
                        1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
                        0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. 
                        Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
            <name>VARCLK_EN</name>
          </field>
        </fields>
        <name>SPI_CNTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider Register (master only) 
                        The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER+1)*2)
                        In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
            <name>DIVIDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider 2 Register (master only) 
                        The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER2+1)*2)</description>
            <name>DIVIDER2</name>
          </field>
        </fields>
        <name>SPI_DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Slave Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Register (master only)
                        If AUTOSS bit is cleared, writing 1 to this bit sets the SPISSx line to active state and writing 0 sets the line back to inactive state.
                        If AUTOSS bit is set, writing 1 to this bit will select the SPISSx line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).</description>
            <name>SSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Active Level
                        It defines the active level of slave select signal (SPISSx). 
                        1 = The slave select signal SPISSx is active at high-level/rising-edge.
                        0 = The slave select signal SPISSx is active at low-level/falling-edge.</description>
            <name>SS_LVL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Slave Select (master only)
                        1 = If this bit is set, SPISSx signal is generated automatically. It means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
                        0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting and clearing SSR[0].</description>
            <name>AUTOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Level Trigger (slave only)
                        1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high.
                        0: The input slave select signal is edge-trigger. This is default value.</description>
            <name>SS_LTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Level Trigger Flag
                        When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
                        1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN.
                        0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements.
                        Note: This bit is READ only</description>
            <name>LTRIG_FLAG</name>
          </field>
        </fields>
        <name>SPI_SSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Data Receive Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Receive Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Data Transmit Register 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Data Transmit Register 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Variable Clock Pattern Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Variable Clock Pattern 
                        The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.</description>
            <name>VARCLK</name>
          </field>
        </fields>
        <name>SPI_VARCLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7FFF87</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40034000</baseAddress>
    <description>Registers group</description>
    <groupName>SPI</groupName>
    <interrupts></interrupts>
    <name>SPI1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Go and Busy Status
                        1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
                        0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
                        During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.
                        NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>GO_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive At Negative Edge
                        1 = The received data input signal is latched at the falling edge of SPICLK.
                        0 = The received data input signal is latched at the rising edge of SPICLK.</description>
            <name>RX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit At Negative Edge
                        1 = The transmitted data output signal is changed at the falling edge of SPICLK.
                        0 = The transmitted data output signal is changed at the rising edge of SPICLK.</description>
            <name>TX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Transmit Bit Length
                        This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted.
                        TX_BIT_LEN = 0x01 ... 1 bit
                        TX_BIT_LEN = 0x02 ... 2 bits
                        ......
                        TX_BIT_LEN = 0x1f ... 31 bits
                        TX_BIT_LEN = 0x00 .. 32 bits</description>
            <name>TX_BIT_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Numbers of Transmit/Receive Word
                        This field specifies how many transmit/receive word numbers should be executed in one transfer.
                        00 = Only one transmit/receive word will be executed in one transfer.
                        01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
                        10 = Reserved.
                        11 = Reserved.</description>
            <name>TX_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First
                        1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
                        0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).</description>
            <name>LSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity
                        1 = SPICLK idle high.
                        0 = SPICLK idle low.</description>
            <name>CLKP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Suspend Interval (master only)
                        These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation:
                        (SP_CYCLE[3:0] + 2)*period of SPI clock
                        SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
                        SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
                        ......
                        SP_CYCLE = 0xe ... 16 SPICLK clock cycle
                        SP_CYCLE = 0xf ... 17 SPICLK clock cycle</description>
            <name>SP_CYCLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Flag
                        1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
                        0 = It indicates that the transfer does not finish yet.
                        NOTE: This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable
                        1 = Enable MICROWIRE/SPI Interrupt.
                        0 = Disable MICROWIRE/SPI Interrupt.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SLAVE Mode Indication
                        1 = Slave mode.
                        0 = Master mode.</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reorder Mode Select
                        00 = Disable both byte reorder and byte suspend functions.
                        01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        10 = Enable byte reorder function, but disable byte suspend function.
                        11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.</description>
            <name>REORDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Variable Clock Enable (master only)
                        1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
                        0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. 
                        Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
            <name>VARCLK_EN</name>
          </field>
        </fields>
        <name>SPI_CNTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider Register (master only) 
                        The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER+1)*2)
                        In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
            <name>DIVIDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider 2 Register (master only) 
                        The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER2+1)*2)</description>
            <name>DIVIDER2</name>
          </field>
        </fields>
        <name>SPI_DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Slave Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Register (master only)
                        If AUTOSS bit is cleared, writing 1 to this bit sets the SPISSx line to active state and writing 0 sets the line back to inactive state.
                        If AUTOSS bit is set, writing 1 to this bit will select the SPISSx line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).</description>
            <name>SSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Active Level
                        It defines the active level of slave select signal (SPISSx). 
                        1 = The slave select signal SPISSx is active at high-level/rising-edge.
                        0 = The slave select signal SPISSx is active at low-level/falling-edge.</description>
            <name>SS_LVL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Slave Select (master only)
                        1 = If this bit is set, SPISSx signal is generated automatically. It means that slave select signal will be asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
                        0 = If this bit is cleared, slave select signal will be asserted and de-asserted by setting and clearing SSR[0].</description>
            <name>AUTOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Level Trigger (slave only)
                        1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high.
                        0: The input slave select signal is edge-trigger. This is default value.</description>
            <name>SS_LTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Level Trigger Flag
                        When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
                        1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN.
                        0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements.
                        Note: This bit is READ only</description>
            <name>LTRIG_FLAG</name>
          </field>
        </fields>
        <name>SPI_SSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Data Receive Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Receive Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Data Transmit Register 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Data Transmit Register 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Variable Clock Pattern Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Variable Clock Pattern 
                        The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.</description>
            <name>VARCLK</name>
          </field>
        </fields>
        <name>SPI_VARCLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7FFF87</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40050000</baseAddress>
    <description>Registers group</description>
    <groupName>UART</groupName>
    <interrupts></interrupts>
    <name>UART0</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>UART0 Receive Buffer Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive Buffer Register
                        By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).</description>
            <name>_8_bitReceivedData</name>
          </field>
        </fields>
        <name>UA_RBR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>UART0 Transmit Holding Register.</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit Holding Register
                        By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).</description>
            <name>_8_bitTransmittedData</name>
          </field>
        </fields>
        <name>UA_THR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>UART0 Interrupt Enable Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Enable.
                        0 = Mask off INT_RDA
                        1 = Enable INT_RDA</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RDA_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Enable
                        0 = Mask off INT_THRE
                        1 = Enable INT_THRE</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>THRE_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Enable 
                        0 = Mask off INT_RLS
                        1 = Enable INT_RLS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RLS_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Modem Status Interrupt Enable 
                        0 = Mask off INT_MOS
                        1 = Enable INT_MOS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Modem_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Time out Interrupt Enable
                        0 = Mask off INT_tout
                        1 = Enable INT_tout </description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTO_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Enable
                        0 = Mask off INT_Buf_err
                        1 = Enable INT_Buf_err</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BUF_ERR_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up CPU function enable 
                        0 = Disable UART wake up CPU function
                        1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS change will wake up CPU from deep sleep mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Wake_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable Time-out counter.
                        0 = Disable Time-out counter.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Time_Out_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Auto Flow Control Enable 
                        1 = Enable RTS auto flow control.
                        0 = Disable RTS auto flow control.
                        When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR [RTS_Tri_Lev], the UART will dessert RTS signal.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Auto_RTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Auto Flow Control Enable
                        1 = Enable CTS auto flow control.
                        0 = Disable CTS auto flow control.
                        When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Auto_CTS_EN</name>
          </field>
        </fields>
        <name>UA_IER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>UART0 FIFO Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Software Reset
                        When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
                        Note: This bit will auto clear and takes at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Software Reset
                        When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
                        Note: This bit will auto clear and takes at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Word Length Select
                        RFITL	INTR_RDA Tigger Level(Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RFITL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Disable register.
                        The receiver is disabled or not (set 1 is disable receiver)
                        1: Disable Receiver
                        0: Enable Receiver
                        Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RX_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Word Length Select
                        RTS_Tri_Lev	Trigger Level(Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS_Tri_Lev</name>
          </field>
        </fields>
        <name>UA_FCR</name>
        <resetMask>0xFFFFFEFE</resetMask>
        <resetValue>0x101</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>UART0 Line Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Length Select
                        WLS[1:0]	Character length	
                        00	5 bits	
                        01	6 bits	
                        10	7 bits	
                        11	8 bits	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WLS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of "STOP bit"
                        0= One "STOP bit" is generated in the transmitted data
                        1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
                        Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>NSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Bit Enable
                        0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
                        1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>PBE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Even Parity Enable
                        0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
                        1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
                        This bit has effect only when bit 3 (parity bit enable) is set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>EPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stick Parity Enable 
                        0 = Disable stick parity 
                        1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Control Bit 
                        When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit acts only on Tx and has no effect on the transmitter logic.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BCB</name>
          </field>
        </fields>
        <name>UA_LCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>UART0 Modem Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS (Request-To-Send) Signal 
                        0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered).
                        1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered).
                        0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered).
                        1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Trigger Level 
                        This bit can change the RTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Lev_RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Pin State 
                        This bit is the pin status of RTS.</description>
            <name>RTS_St</name>
          </field>
        </fields>
        <name>UA_MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>UART0 Modem Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Detect CTS State Change Flag 
                        This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when IER [Modem_IEN].
                        NOTE: This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>DCTSF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Pin Status 
                        This bit is the pin status of CTS. </description>
            <name>CTS_St</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Trigger Level
                        This bit can change the CTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Lev_CTS</name>
          </field>
        </fields>
        <name>UA_MSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>UART0 FIFO Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx overflow Error IF (Read Only) 
                        This bit is set when Rx FIFO overflow.
                        If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of UART0/UART1, this bit will be set.
                        NOTE: This bit is cleared by writing 1 to itself.</description>
            <name>Rx_Over_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Byte Detection Flag
                        This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = '1') bit", and it is reset whenever the CPU writes 1 to this bit.
                        Note: This field is used for RS-485 mode.</description>
            <name>RS_485_Add_Det</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.</description>
            <name>PEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.</description>
            <name>FEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Interrupt Flag
                        This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.</description>
            <name>BIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Rx FIFO pointer (Read Only)
                        This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer decreases one.</description>
            <name>Rx_Pointer</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Empty (Read Only)
                        This bit initiate Rx FIFO empty or not.
                        When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
            <name>Rx_Empty</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Full (Read Only)
                        This bit initiates Rx FIFO full or not.
                        This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>Rx_Full</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>TX FIFO Pointer (Read Only)
                        This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift Register, Tx_Pointer decreases one.</description>
            <name>Tx_Pointer</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Empty (Read Only)
                        This bit indicates Tx FIFO empty or not.
                        When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>Tx_Empty</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Full (Read Only)
                        This bit indicates Tx FIFO full or not.
                        This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>Tx_Full</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Overflow Error Interrupt Flag (Read Only)
                        If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
                        NOTE: This bit is cleared by writing 1 to itself.</description>
            <name>Tx_Over_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Empty Flag (Read Only)
                        Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte has been transmitted.
                        Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
                        NOTE: This bit is read only. </description>
            <name>TE_Flag</name>
          </field>
        </fields>
        <name>UA_FSR</name>
        <resetMask>0xEFBFBFFF</resetMask>
        <resetValue>0x10404000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>UART0 Interrupt Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Flag (Read Only).
                        When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
                        NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).</description>
            <name>RDA_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Flag (Read Only). 
                        This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
                        NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>THRE_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Interrupt Flag (Read Only).
                        In UART mode this bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det are cleared.</description>
            <name>RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Interrupt Flag (Read Only) 
                        This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>Modem_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Flag (Read Only)
                        This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>Tout_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared. </description>
            <name>Buf_Err_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA).
                        An AND output with inputs of RDA_IEN and RDA_IF</description>
            <name>RDA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE).
                        An AND output with inputs of THRE_IEN and THRE_IF</description>
            <name>THRE_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). 
                        An AND output with inputs of RLS_IEN and RLS_IF
                        Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.</description>
            <name>RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). 
                        An AND output with inputs of Modem_IEN and Modem_IF</description>
            <name>Modem_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Indicator to Interrupt Controller (INT_Tout)
                        An AND output with inputs of RTO_IEN and Tout_IF</description>
            <name>Tout_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err)
                        An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF</description>
            <name>Buf_Err_INT</name>
          </field>
        </fields>
        <name>UA_ISR</name>
        <resetMask>0xFFFFFFBD</resetMask>
        <resetValue>0x42</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>UART0 Time Out Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Time Out Interrupt Comparator
                        The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER [RTO_IEN]. A new incoming data word or RX FIFO empty clears INT_TOUT.</description>
            <name>TOIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX Delay time value
                        This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO and the de-assertion of by setting UA_TOR. DLY register.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DLY</name>
          </field>
        </fields>
        <name>UA_TOR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>UART0 Baud Rate Divisor Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Baud Rate Divider 
                        The low byte of the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD_LowByte</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Baud Rate Divider 
                        The high byte of the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD_HighByte</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider X
                        The baud rate divider M = X+1.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Divider_X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X equal 1
                        0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must &gt; 8)
                        1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must &gt; 3).
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DIV_X_ONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X Enable
                        The BRD = Baud Rate Divider, and the baud rate equation is 
                        Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
                        0 = Disable divider X (the equation of M = 16)
                        1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must &gt; 8).
                        NOTE: When in IrDA mode, this bit must disable.
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DIV_X_EN</name>
          </field>
        </fields>
        <name>UA_BAUD</name>
        <resetMask>0xF0FFFFFF</resetMask>
        <resetValue>0xF000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>UART0 IrDA Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx_SELECT
                        1: Enable IrDA transmitter
                        0: Enable IrDA receiver</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Tx_SELECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IrDA loop back mode for self test.
                        1: Enable IrDA loop back mode
                        0: Disable IrDA loop back mode</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_Tx
                        1= Inverse Tx output signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_Tx</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_Rx
                        1= Inverse Rx input signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_Rx</name>
          </field>
        </fields>
        <name>UA_IRCR</name>
        <resetMask>0xFFFFFFBF</resetMask>
        <resetValue>0x40</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>UART0 RS485 Control State Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Normal Multi-drop Operation Mode (NMM)
                        1: Enable RS-485 Normal Multi-drop Operation Mode (NMM)
                        0: Disable RS-485 Normal Multi-drop Operation Mode (NMM)
                        Note: It can't be active with RS-485_AAD operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_NMM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Address Detection Operation Mode (AAD)
                        1: Enable RS-485 Auto Address Detection Operation Mode (AAD)
                        0: Disable RS-485 Auto Address Detection Operation Mode (AAD)
                        Note: It can't be active with RS-485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_AAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Direction Mode (AUD)
                        1: Enable RS-485 Auto Direction Mode (AUD)
                        0: Disable RS-485 Auto Direction Mode (AUD)
                        Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_AUD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Detection Enable
                        This bit is use to enable RS-485 address detection mode. 
                        1: Enable address detection mode
                        0: Disable address detection mode 
                        Note: This field is used for RS-485 any operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_Add_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Address match value register
                        This field contains the RS-485 address match values.
                        Note: This field is used for RS-485 auto address detection mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>ADDR_MATCH</name>
          </field>
        </fields>
        <name>UA_ACT_CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>UART0 Function Select Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Function Select Enable
                        00 = UART Function.
                        01 = Reserved.
                        10 = Enable IrDA Function.
                        11 = Enable RS-485 Function.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>FUN_SEL</name>
          </field>
        </fields>
        <name>UA_FUN_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40150000</baseAddress>
    <description>Registers group</description>
    <groupName>UART</groupName>
    <interrupts></interrupts>
    <name>UART1</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>UART0 Receive Buffer Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive Buffer Register
                        By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).</description>
            <name>_8_bitReceivedData</name>
          </field>
        </fields>
        <name>UA_RBR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>UART0 Transmit Holding Register.</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit Holding Register
                        By writing to this register, the UART will send out an 8-bit data through the Tx pin (LSB first).</description>
            <name>_8_bitTransmittedData</name>
          </field>
        </fields>
        <name>UA_THR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>UART0 Interrupt Enable Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Enable.
                        0 = Mask off INT_RDA
                        1 = Enable INT_RDA</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RDA_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Enable
                        0 = Mask off INT_THRE
                        1 = Enable INT_THRE</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>THRE_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Enable 
                        0 = Mask off INT_RLS
                        1 = Enable INT_RLS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RLS_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Modem Status Interrupt Enable 
                        0 = Mask off INT_MOS
                        1 = Enable INT_MOS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Modem_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Time out Interrupt Enable
                        0 = Mask off INT_tout
                        1 = Enable INT_tout </description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTO_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Enable
                        0 = Mask off INT_Buf_err
                        1 = Enable INT_Buf_err</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BUF_ERR_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up CPU function enable 
                        0 = Disable UART wake up CPU function
                        1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS change will wake up CPU from deep sleep mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Wake_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable Time-out counter.
                        0 = Disable Time-out counter.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Time_Out_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Auto Flow Control Enable 
                        1 = Enable RTS auto flow control.
                        0 = Disable RTS auto flow control.
                        When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR [RTS_Tri_Lev], the UART will dessert RTS signal.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Auto_RTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Auto Flow Control Enable
                        1 = Enable CTS auto flow control.
                        0 = Disable CTS auto flow control.
                        When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Auto_CTS_EN</name>
          </field>
        </fields>
        <name>UA_IER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>UART0 FIFO Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Software Reset
                        When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
                        Note: This bit will auto clear and takes at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Software Reset
                        When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
                        Note: This bit will auto clear and takes at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Word Length Select
                        RFITL	INTR_RDA Tigger Level(Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RFITL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Disable register.
                        The receiver is disabled or not (set 1 is disable receiver)
                        1: Disable Receiver
                        0: Enable Receiver
                        Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before RS-485 enable function in UA_FUN_SEL. FUN_SEL is programmed.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RX_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Word Length Select
                        RTS_Tri_Lev	Trigger Level(Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS_Tri_Lev</name>
          </field>
        </fields>
        <name>UA_FCR</name>
        <resetMask>0xFFFFFEFE</resetMask>
        <resetValue>0x101</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>UART0 Line Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Length Select
                        WLS[1:0]	Character length	
                        00	5 bits	
                        01	6 bits	
                        10	7 bits	
                        11	8 bits	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WLS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of "STOP bit"
                        0= One "STOP bit" is generated in the transmitted data
                        1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
                        Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>NSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Bit Enable
                        0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
                        1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>PBE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Even Parity Enable
                        0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
                        1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
                        This bit has effect only when bit 3 (parity bit enable) is set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>EPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stick Parity Enable 
                        0 = Disable stick parity 
                        1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Control Bit 
                        When this bit is set to logic 1, the serial data output (Tx) is forced to the Spacing State (logic 0). This bit acts only on Tx and has no effect on the transmitter logic.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BCB</name>
          </field>
        </fields>
        <name>UA_LCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>UART0 Modem Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS (Request-To-Send) Signal 
                        0: Drive RTS pin to logic 1 (If the Lev_RTS set to low level triggered).
                        1: Drive RTS pin to logic 0 (If the Lev_RTS set to low level triggered).
                        0: Drive RTS pin to logic 0 (If the Lev_RTS set to high level triggered).
                        1: Drive RTS pin to logic 1 (If the Lev_RTS set to high level triggered).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Trigger Level 
                        This bit can change the RTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Lev_RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Pin State 
                        This bit is the pin status of RTS.</description>
            <name>RTS_St</name>
          </field>
        </fields>
        <name>UA_MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>UART0 Modem Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Detect CTS State Change Flag 
                        This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when IER [Modem_IEN].
                        NOTE: This bit is cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>DCTSF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Pin Status 
                        This bit is the pin status of CTS. </description>
            <name>CTS_St</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Trigger Level
                        This bit can change the CTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Lev_CTS</name>
          </field>
        </fields>
        <name>UA_MSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>UART0 FIFO Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx overflow Error IF (Read Only) 
                        This bit is set when Rx FIFO overflow.
                        If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 16 bytes of UART0/UART1, this bit will be set.
                        NOTE: This bit is cleared by writing 1 to itself.</description>
            <name>Rx_Over_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Byte Detection Flag
                        This bit is set to logic 1 and set UA_RS-485_CSR [RS-485_Add_EN] whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = '1') bit", and it is reset whenever the CPU writes 1 to this bit.
                        Note: This field is used for RS-485 mode.</description>
            <name>RS_485_Add_Det</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.</description>
            <name>PEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.</description>
            <name>FEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Interrupt Flag
                        This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.</description>
            <name>BIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Rx FIFO pointer (Read Only)
                        This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer decreases one.</description>
            <name>Rx_Pointer</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Empty (Read Only)
                        This bit initiate Rx FIFO empty or not.
                        When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
            <name>Rx_Empty</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Full (Read Only)
                        This bit initiates Rx FIFO full or not.
                        This bit is set when Rx_Pointer is equal to 16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>Rx_Full</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>TX FIFO Pointer (Read Only)
                        This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift Register, Tx_Pointer decreases one.</description>
            <name>Tx_Pointer</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Empty (Read Only)
                        This bit indicates Tx FIFO empty or not.
                        When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>Tx_Empty</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Full (Read Only)
                        This bit indicates Tx FIFO full or not.
                        This bit is set when Tx_Pointer is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>Tx_Full</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Overflow Error Interrupt Flag (Read Only)
                        If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
                        NOTE: This bit is cleared by writing 1 to itself.</description>
            <name>Tx_Over_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Empty Flag (Read Only)
                        Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte has been transmitted.
                        Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
                        NOTE: This bit is read only. </description>
            <name>TE_Flag</name>
          </field>
        </fields>
        <name>UA_FSR</name>
        <resetMask>0xEFBFBFFF</resetMask>
        <resetValue>0x10404000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>UART0 Interrupt Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Flag (Read Only).
                        When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
                        NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).</description>
            <name>RDA_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Flag (Read Only). 
                        This bit is set when the last data of Tx FIFO is transferred to Transmitter Shift Register. If IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
                        NOTE: This bit is read only and it will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>THRE_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Interrupt Flag (Read Only).
                        In UART mode this bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). In RS-485 mode, the field includes RS-485 Address Byte Detection Flag. If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF, PEF and RS-485_Add_Det are cleared.</description>
            <name>RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Interrupt Flag (Read Only) 
                        This bit is set when the CTS pin has state change (DCTSF=1). If IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>Modem_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Flag (Read Only)
                        This bit is set when the Rx FIFO is not empty and no activities occur in the Rx FIFO and the time out counter equal to TOIC. If IER [Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>Tout_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When Buf_Err_IF is set, the transfer maybe not correct. If IER[Buf_Err_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared. </description>
            <name>Buf_Err_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Indicator to Interrupt Controller (INT_RDA).
                        An AND output with inputs of RDA_IEN and RDA_IF</description>
            <name>RDA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Indicator to Interrupt Controller (INT_THRE).
                        An AND output with inputs of THRE_IEN and THRE_IF</description>
            <name>THRE_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Indicator to Interrupt Controller (INT_RLS). 
                        An AND output with inputs of RLS_IEN and RLS_IF
                        Note: In RS-485 mode, the field includes RS-485 Address Byte Detection Flag.</description>
            <name>RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Status Interrupt Indicator to Interrupt Controller (INT_MOS). 
                        An AND output with inputs of Modem_IEN and Modem_IF</description>
            <name>Modem_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Indicator to Interrupt Controller (INT_Tout)
                        An AND output with inputs of RTO_IEN and Tout_IF</description>
            <name>Tout_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Indicator to Interrupt Controller (INT_Buf_err)
                        An AND output with inputs of BUF_ERR_IEN and Buf_Err_IF</description>
            <name>Buf_Err_INT</name>
          </field>
        </fields>
        <name>UA_ISR</name>
        <resetMask>0xFFFFFFBD</resetMask>
        <resetValue>0x42</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>UART0 Time Out Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Time Out Interrupt Comparator
                        The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (INT_TOUT) is generated if UA_IER [RTO_IEN]. A new incoming data word or RX FIFO empty clears INT_TOUT.</description>
            <name>TOIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX Delay time value
                        This field is use to programming the transfer delay time between the last stop bit leaving the TX-FIFO and the de-assertion of by setting UA_TOR. DLY register.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DLY</name>
          </field>
        </fields>
        <name>UA_TOR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>UART0 Baud Rate Divisor Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Baud Rate Divider 
                        The low byte of the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD_LowByte</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Baud Rate Divider 
                        The high byte of the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD_HighByte</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider X
                        The baud rate divider M = X+1.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Divider_X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X equal 1
                        0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must &gt; 8)
                        1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must &gt; 3).
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DIV_X_ONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X Enable
                        The BRD = Baud Rate Divider, and the baud rate equation is 
                        Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
                        0 = Disable divider X (the equation of M = 16)
                        1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must &gt; 8).
                        NOTE: When in IrDA mode, this bit must disable.
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DIV_X_EN</name>
          </field>
        </fields>
        <name>UA_BAUD</name>
        <resetMask>0xF0FFFFFF</resetMask>
        <resetValue>0xF000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>UART0 IrDA Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx_SELECT
                        1: Enable IrDA transmitter
                        0: Enable IrDA receiver</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>Tx_SELECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IrDA loop back mode for self test.
                        1: Enable IrDA loop back mode
                        0: Disable IrDA loop back mode</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_Tx
                        1= Inverse Tx output signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_Tx</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_Rx
                        1= Inverse Rx input signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_Rx</name>
          </field>
        </fields>
        <name>UA_IRCR</name>
        <resetMask>0xFFFFFFBF</resetMask>
        <resetValue>0x40</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>UART0 RS485 Control State Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Normal Multi-drop Operation Mode (NMM)
                        1: Enable RS-485 Normal Multi-drop Operation Mode (NMM)
                        0: Disable RS-485 Normal Multi-drop Operation Mode (NMM)
                        Note: It can't be active with RS-485_AAD operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_NMM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Address Detection Operation Mode (AAD)
                        1: Enable RS-485 Auto Address Detection Operation Mode (AAD)
                        0: Disable RS-485 Auto Address Detection Operation Mode (AAD)
                        Note: It can't be active with RS-485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_AAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Direction Mode (AUD)
                        1: Enable RS-485 Auto Direction Mode (AUD)
                        0: Disable RS-485 Auto Direction Mode (AUD)
                        Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_AUD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Detection Enable
                        This bit is use to enable RS-485 address detection mode. 
                        1: Enable address detection mode
                        0: Disable address detection mode 
                        Note: This field is used for RS-485 any operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS_485_Add_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Address match value register
                        This field contains the RS-485 address match values.
                        Note: This field is used for RS-485 auto address detection mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>ADDR_MATCH</name>
          </field>
        </fields>
        <name>UA_ACT_CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>UART0 Function Select Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Function Select Enable
                        00 = UART Function.
                        01 = Reserved.
                        10 = Enable IrDA Function.
                        11 = Enable RS-485 Function.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>FUN_SEL</name>
          </field>
        </fields>
        <name>UA_FUN_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<resetMask>0x0</resetMask>
<resetValue>0x0</resetValue>
<size>0x20</size>
<version>0.1</version>
<width>0x20</width></device>
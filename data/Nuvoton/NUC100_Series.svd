<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd"><access>read-write</access>
<addressUnitBits>0x8</addressUnitBits>
<cpu>
  <dcachePresent>
    <dcachePresen></dcachePresen>
  </dcachePresent>
  <dtcmPresent>
    <dtcmPresen></dtcmPresen>
  </dtcmPresent>
  <icachePresent>
    <icachePresen></icachePresen>
  </icachePresent>
  <itcmPresent>
    <itcmPresen></itcmPresen>
  </itcmPresent>
</cpu>
<description>NUC1xx_registers Microcontroller dummy device</description>
<name>NUC1xx_registers</name>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x48</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40040000</baseAddress>
    <description>Registers group</description>
    <groupName>PWM</groupName>
    <interrupts></interrupts>
    <name>PWMA</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PWM Prescaler Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock prescaler 0 (PWM-timer 0 &amp; 1 for group A and PWM-timer 4 &amp; 5 for group B)
                        Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer
                        If CP01=0, then the clock prescaler 0 output clock will be stopped. So corresponding PWM-timer will be stopped also.</description>
            <name>CP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock prescaler 2 (PWM-timer2 &amp; 3 for group A and PWM-timer 6 &amp; 7 for group B)
                        Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer.
                        If CP23=0, then the clock prescaler 2 output clock will be stopped. So corresponding PWM-timer will be stopped also.</description>
            <name>CP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead Zone Interval for Pair of Channel 0 and Channel 1 (PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead Zone Interval for Pair of Channel2 and Channel3 (PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI23</name>
          </field>
        </fields>
        <name>PPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PWM Clock Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 0 Clock Source Selection (PWM timer 0 for group A and PWM timer 4 for group B)
                        Select clock input for PWM timer.
                        (Table is the same as CSR3)</description>
            <name>CSR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 1 Clock Source Selection (PWM timer 1 for group A and PWM timer 5 for group B)
                        Select clock input for PWM timer.
                        (Table is the same as CSR3)</description>
            <name>CSR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 2 Clock Source Selection (PWM timer 2 for group A and PWM timer 6 for group B)
                        Select clock input for PWM timer.
                        (Table is the same as CSR3)</description>
            <name>CSR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
                        Select clock input for PWM timer.
                        CSR3 [14:12]	Input clock divided by	
                        100	1	
                        011	16	
                        010	8	
                        001	4	
                        000	2	</description>
            <name>CSR3</name>
          </field>
        </fields>
        <name>CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PWM Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Enable (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Output Inverter Enable (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH0INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Auto-reload/One-Shot Mode (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CH0MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 0 Generator Enable (PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
            <name>DZEN01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 2 Generator Enable (PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
            <name>DZEN23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Enable (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Output Inverter Enable (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH1INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Auto-reload/One-Shot Mode (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Auto-load Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CH1MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Enable (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Output Inverter Enable (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH2INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Auto-reload/One-Shot Mode (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CH2MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Enable (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Output Inverter Enable (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH3INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Auto-reload/One-Shot Mode (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.</description>
            <name>CH3MOD</name>
          </field>
        </fields>
        <name>PCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PWM Counter Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>PWM Comparator Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PWM Data Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>PWM Counter Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>PWM Comparator Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>PWM Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PWM Counter Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>PWM Comparator Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>PWM Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>PWM Counter Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>PWM Comparator Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>PWM Data Register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>New description for register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Backward Compatible Register
                        0 = PWM register action is compatible with Medium Density
                        1 = PWM register action is not compatible with Medium Density
                        Please reference CCR0/CCR2 register bit 6, 7, 22, 23 description</description>
            <name>BCn</name>
          </field>
        </fields>
        <name>PBCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>PWM Interrupt Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE3</name>
          </field>
        </fields>
        <name>PIER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>PWM Interrupt Indication Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Interrupt Status
                        Flag is set by hardware when PWM0 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Interrupt Status
                        Flag is set by hardware when PWM1 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Interrupt Status
                        Flag is set by hardware when PWM2 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Interrupt Status
                        Flag is set by hardware when PWM3 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF3</name>
          </field>
        </fields>
        <name>PIIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Capture Control Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Capture Function Enable
                        1 = Enable capture function on PWM group channel 0.
                        0 = Disable capture function on PWM group channel 0.
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
            <name>CAPCH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Capture Interrupt Indication Flag
                        If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR0 Latched Indicator Bit
                        When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR0 Latched Indicator Bit
                        When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Capture Function Enable
                        1 = Enable capture function on PWM group channel 1.
                        0 = Disable capture function on PWM group channel 1.
                        When Enable, Capture latched the PMW-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
            <name>CAPCH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Capture Interrupt Indication Flag
                        If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR1 Latched Indicator Bit
                        When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR1 Latched Indicator Bit
                        When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI1</name>
          </field>
        </fields>
        <name>CCR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Capture Control Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Capture Function Enable
                        1 = Enable capture function on PWM group channel 2.
                        0 = Disable capture function on PWM group channel 2.
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
            <name>CAPCH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Capture Interrupt Indication Flag
                        If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR2 Latched Indicator Bit
                        When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR2 Latched Indicator Bit
                        When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Capture Function Enable
                        1 = Enable capture function on PWM group channel 3.
                        0 = Disable capture function on PWM group channel 3.
                        When Enable, Capture latched the PMW-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
            <name>CAPCH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Capture Interrupt Indication Flag
                        If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR3 Latched Indicator Bit
                        When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR3 Latched Indicator Bit
                        When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI3</name>
          </field>
        </fields>
        <name>CCR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x58</addressOffset>
        <description>Capture Rising Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5C</addressOffset>
        <description>Capture Falling Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 0 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>Capture Rising Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 1 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>Capture Falling Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 1 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Capture Rising Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 2 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x6C</addressOffset>
        <description>Capture Falling Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 2 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70</addressOffset>
        <description>Capture Rising Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x74</addressOffset>
        <description>Capture Falling Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>Capture Input Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Capture Input Enable Register
                        There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs enable or disable. 
                        0 = Disable (PWMx multi-function pin input does not affect input capture function)
                        1 = Enable (PWMx multi-function pin input will affect its input capture function.)
                        
                        
                        
                        CAPENR
                        Bit 3210 for PWM group A
                        Bit xxx1 Capture channel 0 is from pin PA.12 
                        Bit xx1x Capture channel 1 is from pin PA.13 
                        Bit x1xx Capture channel 2 is from pin PA.14
                        Bit 1xxx Capture channel 3 is from pin PA.15 
                        Bit 3210 for PWM group B
                        Bit xxx1 Capture channel 0 is from pin PE.11
                        Bit xx1x Capture channel 1 is from pin PE.5
                        Bit x1xx Capture channel 2 is from pin PE.0
                        Bit 1xxx Capture channel 3 is from pin PE.1 </description>
            <name>CAPENR</name>
          </field>
        </fields>
        <name>CAPENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>PWM Output Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Output Enable Register
                        1 = Enable PWM channel 0 output to pin
                        0 = Disable PWM channel 0 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Output Enable Register
                        1 = Enable PWM channel 1 output to pin
                        0 = Disable PWM channel 1 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Output Enable Register
                        1 = Enable PWM channel 2 output to pin
                        0 = Disable PWM channel 2 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Output Enable Register
                        1 = Enable PWM channel 3 output to pin
                        0 = Disable PWM channel 3 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM3</name>
          </field>
        </fields>
        <name>POE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x48</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40140000</baseAddress>
    <description>Registers group</description>
    <groupName>PWM</groupName>
    <interrupts></interrupts>
    <name>PWMB</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PWM Prescaler Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock prescaler 0 (PWM-timer 0 &amp; 1 for group A and PWM-timer 4 &amp; 5 for group B)
                        Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer
                        If CP01=0, then the clock prescaler 0 output clock will be stopped. So corresponding PWM-timer will be stopped also.</description>
            <name>CP01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Clock prescaler 2 (PWM-timer2 &amp; 3 for group A and PWM-timer 6 &amp; 7 for group B)
                        Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer.
                        If CP23=0, then the clock prescaler 2 output clock will be stopped. So corresponding PWM-timer will be stopped also.</description>
            <name>CP23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead Zone Interval for Pair of Channel 0 and Channel 1 (PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Dead Zone Interval for Pair of Channel2 and Channel3 (PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        These 8 bits determine dead zone length.
                        The unit time of dead zone length is received from corresponding CSR bits.</description>
            <name>DZI23</name>
          </field>
        </fields>
        <name>PPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PWM Clock Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 0 Clock Source Selection (PWM timer 0 for group A and PWM timer 4 for group B)
                        Select clock input for PWM timer.
                        (Table is the same as CSR3)</description>
            <name>CSR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 1 Clock Source Selection (PWM timer 1 for group A and PWM timer 5 for group B)
                        Select clock input for PWM timer.
                        (Table is the same as CSR3)</description>
            <name>CSR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 2 Clock Source Selection (PWM timer 2 for group A and PWM timer 6 for group B)
                        Select clock input for PWM timer.
                        (Table is the same as CSR3)</description>
            <name>CSR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>PWM Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
                        Select clock input for PWM timer.
                        CSR3 [14:12]	Input clock divided by	
                        100	1	
                        011	16	
                        010	8	
                        001	4	
                        000	2	</description>
            <name>CSR3</name>
          </field>
        </fields>
        <name>CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PWM Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Enable (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Output Inverter Enable (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH0INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 0 Auto-reload/One-Shot Mode (PWM timer 0 for group A and PWM timer 4 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR0 and CMR0 be clear.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CH0MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 0 Generator Enable (PWM0 and PWM1 pair for PWM group A, PWM4 and PWM5 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM0 and PWM1 becomes a complementary pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.</description>
            <name>DZEN01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Dead-Zone 2 Generator Enable (PWM2 and PWM3 pair for PWM group A, PWM6 and PWM7 pair for PWM group B)
                        1 = Enable
                        0 = Disable
                        Note: When Dead-Zone Generator is enabled, the pair of PWM2 and PWM3 becomes a complementary pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.</description>
            <name>DZEN23</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Enable (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Output Inverter Enable (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH1INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 1 Auto-reload/One-Shot Mode (PWM timer 1 for group A and PWM timer 5 for group B)
                        1 = Auto-load Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR1 and CMR1 be clear.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CH1MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Enable (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Output Inverter Enable (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH2INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 2 Auto-reload/One-Shot Mode (PWM timer 2 for group A and PWM timer 6 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR2 and CMR2 be clear.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CH2MOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Enable (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Enable corresponding PWM-Timer Start Run
                        0 = Stop corresponding PWM-Timer Running</description>
            <name>CH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Output Inverter Enable (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Inverter enable
                        0 = Inverter disable</description>
            <name>CH3INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM-Timer 3 Auto-reload/One-Shot Mode (PWM timer 3 for group A and PWM timer 7 for group B)
                        1 = Auto-reload Mode
                        0 = One-Shot Mode
                        Note: If there is a rising transition at this bit, it will cause CNR3 and CMR3 be clear.</description>
            <name>CH3MOD</name>
          </field>
        </fields>
        <name>PCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PWM Counter Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>PWM Comparator Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PWM Data Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>PWM Counter Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>PWM Comparator Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM01_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>PWM Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PWM Counter Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>PWM Comparator Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>PWM Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>PWM Counter Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Counter/Timer Loaded Value
                        CNR determines the PWM period.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CNR will take effect in next PWM cycle.</description>
            <name>CNR</name>
          </field>
        </fields>
        <name>CNR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>PWM Comparator Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Comparator Register
                        CMR determines the PWM duty.
                        PWM frequency = PWM23_CLK/(prescale+1)*(clock divider)/(CNR+1).
                        Duty ratio = (CMR+1)/(CNR+1).
                        CMR &gt;= CNR: PWM output is always high.
                        CMR &lt; CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
                        CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit
                        (Unit : 1 PWM clock cycle)
                        Note: Any write to CMR will take effect in next PWM cycle.</description>
            <name>CMR</name>
          </field>
        </fields>
        <name>CMR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>PWM Data Register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PWM Data Register
                        User can monitor PDR to know current value in 16-bit down counter.</description>
            <name>PDR</name>
          </field>
        </fields>
        <name>PDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>New description for register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Backward Compatible Register
                        0 = PWM register action is compatible with Medium Density
                        1 = PWM register action is not compatible with Medium Density
                        Please reference CCR0/CCR2 register bit 6, 7, 22, 23 description</description>
            <name>BCn</name>
          </field>
        </fields>
        <name>PBCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>PWM Interrupt Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Interrupt Enable
                        1 = Enable
                        0 = Disable </description>
            <name>PWMIE3</name>
          </field>
        </fields>
        <name>PIER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>PWM Interrupt Indication Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Interrupt Status
                        Flag is set by hardware when PWM0 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Interrupt Status
                        Flag is set by hardware when PWM1 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Interrupt Status
                        Flag is set by hardware when PWM2 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Interrupt Status
                        Flag is set by hardware when PWM3 down counter reaches zero, software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PWMIF3</name>
          </field>
        </fields>
        <name>PIIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Capture Control Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 0 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Capture Function Enable
                        1 = Enable capture function on PWM group channel 0.
                        0 = Disable capture function on PWM group channel 0.
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.</description>
            <name>CAPCH0EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 0 Capture Interrupt Indication Flag
                        If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0=1), a rising transition occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled (CFL_IE0=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR0 Latched Indicator Bit
                        When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR0 Latched Indicator Bit
                        When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 1 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Capture Function Enable
                        1 = Enable capture function on PWM group channel 1.
                        0 = Disable capture function on PWM group channel 1.
                        When Enable, Capture latched the PMW-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.</description>
            <name>CAPCH1EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 1 Capture Interrupt Indication Flag
                        If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1=1), a rising transition occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled (CFL_IE1=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR1 Latched Indicator Bit
                        When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR1 Latched Indicator Bit
                        When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI1</name>
          </field>
        </fields>
        <name>CCR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Capture Control Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 2 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Capture Function Enable
                        1 = Enable capture function on PWM group channel 2.
                        0 = Disable capture function on PWM group channel 2.
                        When Enable, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.</description>
            <name>CAPCH2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 2 Capture Interrupt Indication Flag
                        If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR2 Latched Indicator Bit
                        When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR2 Latched Indicator Bit
                        When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Inverter Enable
                        1 = Inverter enable. Reverse the input signal from GPIO before fed to Capture timer
                        0 = Inverter disable</description>
            <name>INV3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Rising Latch Interrupt Enable
                        1 = Enable rising latch interrupt
                        0 = Disable rising latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has rising transition, Capture issues an Interrupt.</description>
            <name>CRL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Falling Latch Interrupt Enable
                        1 = Enable falling latch interrupt
                        0 = Disable falling latch interrupt
                        When Enable, if Capture detects PWM group channel 3 has falling transition, Capture issues an Interrupt.</description>
            <name>CFL_IE3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Capture Function Enable
                        1 = Enable capture function on PWM group channel 3.
                        0 = Disable capture function on PWM group channel 3.
                        When Enable, Capture latched the PMW-counter and saved to CRLR (Rising latch) and CFLR (Falling latch).
                        When Disable, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.</description>
            <name>CAPCH3EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Channel 3 Capture Interrupt Indication Flag
                        If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1).
                        Write 1 to clear this bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CAPIF3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRLR3 Latched Indicator Bit
                        When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CRLRI3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CFLR3 Latched Indicator Bit
                        When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM down-counter and this bit is set by hardware.
                        In Medium Density, software can write 0 to clear this bit to zero.
                        In Low Density, software can write 0 to clear this bit to zero if BCn bit is 0, and can Write 1 to clear this bit to zero if BCn bit is 1.</description>
            <name>CFLRI3</name>
          </field>
        </fields>
        <name>CCR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x58</addressOffset>
        <description>Capture Rising Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 0 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5C</addressOffset>
        <description>Capture Falling Latch Register (Channel 0)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 0 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>Capture Rising Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 1 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>Capture Falling Latch Register (Channel 1)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 1 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>Capture Rising Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 2 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x6C</addressOffset>
        <description>Capture Falling Latch Register (channel 2)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 2 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70</addressOffset>
        <description>Capture Rising Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Rising Latch Register
                        Latch the PWM counter when Channel 3 has rising transition.</description>
            <name>CRLR</name>
          </field>
        </fields>
        <name>CRLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x74</addressOffset>
        <description>Capture Falling Latch Register (channel 3)</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Capture Falling Latch Register
                        Latch the PWM counter when Channel 3 has Falling transition.</description>
            <name>CFLR</name>
          </field>
        </fields>
        <name>CFLR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>Capture Input Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Capture Input Enable Register
                        There are four capture inputs from pad. Bit0~Bit3 are used to control each inputs enable or disable. 
                        0 = Disable (PWMx multi-function pin input does not affect input capture function)
                        1 = Enable (PWMx multi-function pin input will affect its input capture function.)
                        
                        
                        
                        CAPENR
                        Bit 3210 for PWM group A
                        Bit xxx1 Capture channel 0 is from pin PA.12 
                        Bit xx1x Capture channel 1 is from pin PA.13 
                        Bit x1xx Capture channel 2 is from pin PA.14
                        Bit 1xxx Capture channel 3 is from pin PA.15 
                        Bit 3210 for PWM group B
                        Bit xxx1 Capture channel 0 is from pin PE.11
                        Bit xx1x Capture channel 1 is from pin PE.5
                        Bit x1xx Capture channel 2 is from pin PE.0
                        Bit 1xxx Capture channel 3 is from pin PE.1 </description>
            <name>CAPENR</name>
          </field>
        </fields>
        <name>CAPENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>PWM Output Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 0 Output Enable Register
                        1 = Enable PWM channel 0 output to pin
                        0 = Disable PWM channel 0 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 1 Output Enable Register
                        1 = Enable PWM channel 1 output to pin
                        0 = Disable PWM channel 1 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 2 Output Enable Register
                        1 = Enable PWM channel 2 output to pin
                        0 = Disable PWM channel 2 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM Channel 3 Output Enable Register
                        1 = Enable PWM channel 3 output to pin
                        0 = Disable PWM channel 3 output to pin
                        Note: The corresponding GPIO pin also must be switched to PWM function.</description>
            <name>PWM3</name>
          </field>
        </fields>
        <name>POE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x38</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400E0000</baseAddress>
    <description>Registers group</description>
    <groupName>ADC</groupName>
    <interrupts></interrupts>
    <name>ADC</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>A/D Data Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12]</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>A/D Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>A/D Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>A/D Data Register 3</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>A/D Data Register 4</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>A/D Data Register 5</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>A/D Data Register 6</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>A/D Data Register 7</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>A/D Conversion Result
                        This field contains conversion result of ADC.
                        For Medium density, RSLT[15:12] always read as 0.
                        For Low density, if DMOF bit (ADCR[31]) set to 0, 12 bits ADC conversion result with unsigned format will be filled in RSLT[11:0] and zero will be filled in RSLT[15:12]. If DMOF bit (ADCR[31]) set to 1, 12 bits ADC conversion result with 2's complement format will be filled in RSLT[11:0] and signed bits will be filled in RSLT[15:12].</description>
            <name>RSLT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Over Run Flag
                        1 = Data in RSLT[11:0] is overwrite.
                        0 = Data in RSLT[11:0] is recent conversion result.
                        If converted data in RSLT[11:0] has not been read before new conversion result is loaded to this register, OVERRUN is set to 1 and previous conversion result is gone. It will be cleared by hardware after ADDR register is read.</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Valid Flag
                        1 = Data in RSLT[11:0] bits is valid.
                        0 = Data in RSLT[11:0] bits is not valid.
                        This bit is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.</description>
            <name>VALID</name>
          </field>
        </fields>
        <name>ADDR7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>A/D Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Converter Enable
                        1 = Enable
                        0 = Disable
                        Before starting A/D conversion function, this bit should be set to 1. Clear it to 0 to disable A/D converter analog circuit for saving power consumption.</description>
            <name>ADEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Interrupt Enable
                        1 = Enable A/D interrupt function
                        0 = Disable A/D interrupt function
                        A/D conversion end interrupt request is generated if ADIE bit is set to 1.</description>
            <name>ADIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>A/D Converter Operation Mode
                        00 = Single conversion
                        01 = Reserved
                        10 = Single-cycle scan
                        11 = Continuous scan
                        When changing the operation mode, software should disable ADST bit firstly.</description>
            <name>ADMD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Hardware Trigger Source
                        00 = A/D conversion is started by external STADC pin.
                        Others = Reserved
                        Software should disable TRGE and ADST before change TRGS. 
                        In hardware trigger mode, the ADST bit is set by the external trigger from STADC.</description>
            <name>TRGS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>External Trigger Condition
                        These two bits decide external pin STADC trigger event is level or edge. The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high and low state for edge trigger.
                        00 = Low level
                        01 = High level
                        10 = Falling edge
                        11 = Positive edge</description>
            <name>TRGCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External Trigger Enable
                        Enable or disable triggering of A/D conversion by external STADC pin.
                        1= Enable
                        0= Disable</description>
            <name>TRGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Enable
                        1 = Enable PDMA data transfer in ADDR 0~7
                        0 = Disable PDMA data transfer.
                        When A/D conversion is completed, the converted data is loaded into ADDR 0~7, software can enable this bit to generate a PDMA data transfer request.
                        When PTEN=1, software must set ADIE=0 to disable interrupt.</description>
            <name>PTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Differential Input Mode Enable
                        1 = A/D is in differential analog input mode
                        0 = A/D is in single-end analog input mode
                        Differential input voltage (Vdiff) = Vplus - Vminus
                        The Vplus of differential input paired channel 0 is from ADC0 pin; Vminus is from ADC1 pin.
                        The Vplus of differential input paired channel 1 is from ADC2 pin; Vminus is from ADC3 pin.
                        The Vplus of differential input paired channel 2 is from ADC4 pin; Vminus is from ADC5 pin.
                        The Vplus of differential input paired channel 3 is from ADC6 pin; Vminus is from ADC7 pin.
                        In differential input mode, only one of the two corresponding channels needs to be enabled in ADCHER. The conversion result will be placed to the corresponding data register of the enabled channel. If both channels of a differential input paired channel are enabled, the ADC will convert it twice in scan mode. And then write the conversion result to the two corresponding data registers.</description>
            <name>DIFFEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Conversion Start
                        1 = Conversion start.
                        0 = Conversion stopped and A/D converter enter idle state.
                        ADST bit can be controlled by two sources: software write and external pin STADC. ADST is cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode on specified channels. In continuous scan mode, A/D conversion is continuously performed sequentially until this bit is cleared to 0 or chip reset.</description>
            <name>ADST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D differential input Mode Output Format
                        This bit is only supported in Low Density.
                        1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format.
                        0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format.</description>
            <name>DMOF</name>
          </field>
        </fields>
        <name>ADCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>A/D Channel Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 0 Enable
                        1 = Enable
                        0 = Disable
                        Channel 0 is the default enable channel if CHEN0~7 are set as 0s.</description>
            <name>CHEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 1 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 2 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 3 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 4 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 5 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 6 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Input Channel 7 Enable
                        1 = Enable
                        0 = Disable</description>
            <name>CHEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Analog Input Channel 7 select
                        00: External analog input
                        01: Internal bandgap voltage
                        10: Internal temperature sensor
                        11: Reserved</description>
            <name>PRESEL</name>
          </field>
        </fields>
        <name>ADCHER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>A/D Compare Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Enable
                        1 = Enable compare.
                        0 = Disable compare.
                        Set this bit to 1 to enable ADC controller to compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.</description>
            <name>CMPEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Interrupt Enable
                        1 = Enable
                        0 = Disable
                        If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF0 bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.</description>
            <name>CMPIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Condition
                        1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR0[27:16]), the internal match counter will increase one.
                        0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR0[27:16]), the internal match counter will increase one.
                        When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit will be set.</description>
            <name>CMPCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Compare Channel Selection
                        000 = Channel 0 conversion result is selected to be compared.
                        001 = Channel 1 conversion result is selected to be compared.
                        010 = Channel 2 conversion result is selected to be compared.
                        011 = Channel 3 conversion result is selected to be compared.
                        100 = Channel 4 conversion result is selected to be compared.
                        101 = Channel 5 conversion result is selected to be compared.
                        110 = Channel 6 conversion result is selected to be compared.
                        111 = Channel 7 conversion result is selected to be compared.</description>
            <name>CMPCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Compare Match Count
                        When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF0 bit will be set.</description>
            <name>CMPMATCNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Comparison Data
                        The 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.
                        The following description is only supported in Low Density.
                        When DMOF bit is set to 0, ADC comparator compares CMPD with conversion result with unsigned format. CMPD should be filled in unsigned format.
                        When DMOF bit is set to 1, ADC comparator compares CMPD with conversion result with 2's complement format. CMPD should be filled in 2's complement format.</description>
            <name>CMPD</name>
          </field>
        </fields>
        <name>ADCMPR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>A/D Compare Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Enable
                        1 = Enable compare.
                        0 = Disable compare.
                        Set this bit to 1 to enable ADC controller to compare CMPD[11:0] with specified channel conversion result when converted data is loaded into ADDR register.</description>
            <name>CMPEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Interrupt Enable
                        1 = Enable
                        0 = Disable
                        If the compare function is enabled and the compare condition matches the setting of CMPCOND and CMPMATCNT, CMPF1 bit will be asserted, in the meanwhile, if CMPIE is set to 1, a compare interrupt request is generated.</description>
            <name>CMPIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Condition
                        1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to the 12-bit CMPD (ADCMPR1[27:16]), the internal match counter will increase one.
                        0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the 12-bit CMPD (ADCMPR1[27:16]), the internal match counter will increase one.
                        When the internal counter reaches the value to (CMPMATCNT +1), the CMPF1 bit will be set.</description>
            <name>CMPCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Compare Channel Selection
                        000 = Channel 0 conversion result is selected to be compared.
                        001 = Channel 1 conversion result is selected to be compared.
                        010 = Channel 2 conversion result is selected to be compared.
                        011 = Channel 3 conversion result is selected to be compared.
                        100 = Channel 4 conversion result is selected to be compared.
                        101 = Channel 5 conversion result is selected to be compared.
                        110 = Channel 6 conversion result is selected to be compared.
                        111 = Channel 7 conversion result is selected to be compared.</description>
            <name>CMPCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Compare Match Count
                        When the specified A/D channel analog conversion result matches the compare condition defined by CMPCOND[2], the internal match counter will increase 1. When the internal counter reaches the value to (CMPMATCNT +1), the CMPF1 bit will be set.</description>
            <name>CMPMATCNT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Comparison Data
                        The 12 bits data is used to compare with conversion result of specified channel. Software can use it to monitor the external analog input pin voltage transition in scan mode without imposing a load on software.
                        The following description is only supported in Low Density.
                        When DMOF bit is set to 0, ADC comparator compares CMPD with conversion result with unsigned format. CMPD should be filled in unsigned format.
                        When DMOF bit is set to 1, ADC comparator compares CMPD with conversion result with 2's complement format. CMPD should be filled in 2's complement format.</description>
            <name>CMPD</name>
          </field>
        </fields>
        <name>ADCMPR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>A/D Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A/D Conversion End Flag
                        A status flag that indicates the end of A/D conversion.
                        ADF is set to 1 at these two conditions:
                        When A/D conversion ends in single mode
                        When A/D conversion ends on all specified channels in scan mode.
                        This flag can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ADF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Flag
                        When the selected channel A/D conversion result meets the setting conditions of ADCMPR0 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
                        1 = Conversion result in ADDR meets ADCMPR0 setting
                        0 = Conversion result in ADDR does not meet ADCMPR0 setting</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CMPF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Compare Flag
                        When the selected channel A/D conversion result meets the setting conditions of ADCMPR1 then this bit will be set to 1. And it can be cleared by writing 1 to itself.
                        1 = Conversion result in ADDR meets ADCMPR1 setting
                        0 = Conversion result in ADDR does not meet ADCMPR1 setting</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CMPF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BUSY/IDLE
                        1 = A/D converter is busy at conversion.
                        0 = A/D converter is in idle state.
                        This bit is mirror of as ADST bit in ADCR.
                        It is read only.</description>
            <name>BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Current Conversion Channel
                        This filed reflects current conversion channel when BUSY=1. When BUSY=0, it shows the next channel will be converted.
                        It is read only.</description>
            <name>CHANNEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data Valid flag
                        It is a mirror of VALID bit in ADDRx
                        It is read only.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>VALID</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Over Run flag
                        It is a mirror of OVERRUN bit in ADDRx
                        It is read only.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>OVERRUN</name>
          </field>
        </fields>
        <name>ADSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>A/D Calibration Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Self Calibration Enable
                        1 = Enable self calibration
                        0 = Disable self calibration
                        Software can set this bit to 1 enables A/D converter to do self calibration function. It needs 127 ADC clocks to complete calibration. This bit must be kept at 1 after CALDONE asserted. Clearing this bit will disable self calibration function.</description>
            <name>CALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Calibration is Done 
                        1 = A/D converter self calibration is done
                        0 = A/D converter has not been calibrated or calibration is in progress if CALEN bit is set.
                        When 0 is written to CALEN bit, CALDONE bit is cleared by hardware immediately. It is a read only bit.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CALDONE</name>
          </field>
        </fields>
        <name>ADCALR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>New description for register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>ADC PDMA current transfer data register
                        When PDMA transferring, read this register can monitor current PDMA transfer data. This is a read only register.</description>
            <name>AD_PDMA</name>
          </field>
        </fields>
        <name>ADPDMA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1C</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40180000</baseAddress>
    <description>Registers group</description>
    <groupName>CAN</groupName>
    <interrupts></interrupts>
    <name>CAN</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Init Initialization
                        1 = Initialization is started.
                        0 = Normal Operation.</description>
            <name>Init</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Module Interrupt Enable
                        1 = Enabled.
                        0 = Disabled.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status Change Interrupt Enable
                        1 = Enabled - An interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
                        0 = Disabled - No Status Change Interrupt will be generated.</description>
            <name>SIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Error Interrupt Enable
                        1 = Enabled - A change in the bits BOff or EWarn in the Status Register will generate an interrupt.
                        0 = Disabled - No Error Status Interrupt will be generated.</description>
            <name>EIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Disable Automatic Re-transmission 
                        1 = Automatic Retransmission disabled.
                        0 = Automatic Retransmission of disturbed messages enabled.</description>
            <name>DAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Configuration Change Enable
                        1 = Write access to the Bit Timing Register (CAN_BTIME &amp; CAN_BRP) allowed. (while Init bit =1).
                        0 = No write access to the Bit Timing Register.</description>
            <name>CCE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Test Mode Enable
                        1 = Test Mode.
                        0 = Normal Operation.</description>
            <name>Test</name>
          </field>
        </fields>
        <name>CAN_CON</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Last Error Code (Type of the last error to occur on the CAN bus)
                        The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus. This field will be cleared to '0' when a message has been transferred (reception or transmission) without error. The unused code '7' may be written by the CPU to check for updates. Table 5-17 describes the error codes.</description>
            <name>LEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitted a Message Successfully
                        1 = Since this bit was last reset by the CPU, a message has been successfully (error free and acknowledged by at least one other node) transmitted.
                        0 = Since this bit was reset by the CPU, no message has been successfully transmitted. This bit is never reset by the CAN Core.</description>
            <name>TxOK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received a Message Successfully
                        1 = A message has been successfully received since this bit was last reset by the CPU (independent of the result of acceptance filtering).
                        0 = No message has been successfully received since this bit was last reset by the CPU. This bit is never reset by the CAN Core.</description>
            <name>RxOK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Error Passive (Read Only)
                        1 = The CAN Core is in the error passive state as defined in the CAN Specification.
                        0 = The CAN Core is error active.</description>
            <name>EPass</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Error Warning Status (Read Only)
                        1 = At least one of the error counters in the EML has reached the error warning limit of 96.
                        0 = Both error counters are below the error warning limit of 96.</description>
            <name>EWarn</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Busoff Status (Read Only) 
                        1 = The CAN module is in busoff state.
                        0 = The CAN module is not in busoff state.</description>
            <name>BOff</name>
          </field>
        </fields>
        <name>CAN_STATUS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Error Counter</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit Error Counter
                        Actual state of the Transmit Error Counter. Values between 0 and 255.</description>
            <name>TEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Receive Error Counter
                        Actual state of the Receive Error Counter. Values between 0 and 127.</description>
            <name>REC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Error Passive
                        1 = The Receive Error Counter has reached the error passive level as defined in the CAN Specification.
                        0 = The Receive Error Counter is below the error passive level.</description>
            <name>RP</name>
          </field>
        </fields>
        <name>CAN_ERR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Bit Timing Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Baud Rate Prescaler 
                        0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are [0...63]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
            <name>BRP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>(Re)Synchronization Jump Width
                        0x0-0x3: Valid programmed values are [0 ... 3]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
            <name>SJW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Time Segment before the sample Point Minus Sync_seg
                        0x01-0x0F: valid values for TSeg1 are [1 ... 15]. The actual interpretation by the hardware of this value is such that one more than the value programmed is used.</description>
            <name>TSeg1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Time Segment After sample Point 
                        0x0-0x7: Valid values for TSeg2 are [0 ... 7]. The actual interpretation by the hardware of this value is such that one more than the value programmed here is used.</description>
            <name>TSeg2</name>
          </field>
        </fields>
        <name>CAN_BTIME</name>
        <resetMask>0xFFFFDCFE</resetMask>
        <resetValue>0x2301</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Identifier Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Interrupt Identifier (Indicates the source of the interrupt. Ref. Table 5-18)
                        If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt with the highest priority, disregarding their chronological order. An interrupt remains pending until the application software has cleared it. If IntId is different from 0x0000 and IE is set, the IRQ interrupt signal to the EIC is active. The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is reset) or until IE is reset.
                        The Status Interrupt has the highest priority. Among the message interrupts, the Message Object' s interrupt priority decreases with increasing message number.
                        A message interrupt is cleared by clearing the Message Object's IntPnd bit. The Status Interrupt is cleared by reading the Status Register.</description>
            <name>IntId</name>
          </field>
        </fields>
        <name>CAN_IIDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Test Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reserved
                        There are reserved bits.
                        These bits are always read as '0' and must always be written with '0'.</description>
            <name>Res</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Basic Mode
                        1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
                        0 = Basic Mode disabled.</description>
            <name>Basic</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Silent Mode
                        1 = The module is in Silent Mode.
                        0 = Normal operation.</description>
            <name>Silent</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loop Back Mode
                        1 = Loop Back Mode is enabled.
                        0 = Loop Back Mode is disabled.</description>
            <name>LBack</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Tx[1:0]: Control of CAN_TX pin
                        00 = Reset value, CAN_TX is controlled by the CAN Core
                        01 = Sample Point can be monitored at CAN_TX pin
                        10 = CAN_TX pin drives a dominant ('0') value.
                        11 = CAN_TX pin drives a recessive ('1') value.</description>
            <name>Tx</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the actual value of CAN_RX Pin (Read Only)
                        1 = The CAN bus is recessive (CAN_RX = '1').
                        0 = The CAN bus is dominant (CAN_RX = '0').</description>
            <name>Rx</name>
          </field>
        </fields>
        <name>CAN_TEST</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>BRP Extension Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>BRPE: Baud Rate Prescaler Extension
                        0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023. The actual interpretation by the hardware is that one more than the value programmed by BRPE (MSBs) and BTIME (LSBs) is used.</description>
            <name>BRPE</name>
          </field>
        </fields>
        <name>CAN_BRPE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>IF1 Command Request Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Message Number
                        0x01-0x20: Valid Message Number, the Message Object in the Message
                        RAM is selected for data transfer.
                        0x00: Not a valid Message Number, interpreted as 0x20.
                        0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.</description>
            <name>MessageNumber</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Busy Flag
                        1 = Writing to the IF1 Command Request Register is in progress. This bit can only be read by the software.
                        0 = Read/write action has finished.</description>
            <name>Busy</name>
          </field>
        </fields>
        <name>CAN_IF1_CREQ</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>IF1 Command Mask Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Data Bytes [7:4]
                        Direction = Write 
                        1 = Transfer Data Bytes [7:4] to Message Object.
                        0 = Data Bytes [7:4] unchanged.
                        Direction = Read
                        1 = Transfer Data Bytes [7:4] to IF1 Message Buffer Register.
                        0 = Data Bytes [7:4] unchanged.</description>
            <name>DAT_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Data Bytes [3:0]
                        Direction = Write
                        1 = Transfer Data Bytes [3:0] to Message Object 
                        0 = Data Bytes [3:0] unchanged.
                        Direction = Read
                        1 = Transfer Data Bytes [3:0] to IF1 Message Buffer Register.
                        0 = Data Bytes [3:0] unchanged.</description>
            <name>DAT_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Transmission Request Bit  when Direction = Write
                        1 = Set TxRqst bit.
                        0 = TxRqst bit unchanged.
                        Note: If a transmission is requested by programming bit TxRqst/NewDat in the IF1 Command Mask Register, bit TxRqst in the IF2 Message Control Register will be ignored.
                        Access New Data Bit when Direction = Read
                        1 = Clear NewDat bit in the Message Object 
                        0 = NewDat bit remains unchanged.
                        Note : A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IF1 Message Control Register always reflect the status before resetting these bits.</description>
            <name>TxRqstOrNewDat</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Interrupt Pending Bit
                        Direction = Write
                        When writing to a Message Object, this bit is ignored.
                        Direction = Read
                        1 = Clear IntPnd bit in the Message Object.
                        0 = IntPnd bit remains unchanged.</description>
            <name>ClrIntPnd</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control Access Control Bits
                        Direction = Write
                        1 = Transfer Control Bits to Message Object.
                        0 = Control Bits unchanged
                        Direction = Read
                        1 = Transfer Control Bits to IF1 Message Buffer Register.
                        0 = Control Bits unchanged.</description>
            <name>Control</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Arbitration Bits
                        Direction = Write
                        1 = Transfer Identifier + Dir + Xtd + MsgVal to Message Object 
                        0 = Arbitration bits unchanged.
                        Direction = Read
                        1 = Transfer Identifier + Dir + Xtd + MsgVal to IF1 Message Buffer Register.
                        0 = Arbitration bits unchanged.</description>
            <name>Arb</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Mask Bits
                        Direction = Write
                        1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
                        0: = Mask bits unchanged.
                        Direction = Read
                        1 = Transfer Identifier Mask + MDir + MXtd to IF1 Message Buffer Register.
                        0 = Mask bits unchanged.</description>
            <name>Mask</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write / Read
                        1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
                        0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.</description>
            <name>WROrRD</name>
          </field>
        </fields>
        <name>CAN_IF1_CMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>IF1 Mask 1 Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Identifier Mask 15-0
                        1 = The corresponding identifier bit is used for acceptance filtering.
                        0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.</description>
            <name>Msk_0_15</name>
          </field>
        </fields>
        <name>CAN_IF1_MASK1</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>IF1 Mask 2 Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>Identifier Mask 28-16
                        1 = The corresponding identifier bit is used for acceptance filtering.
                        0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.</description>
            <name>Msk_16_28</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask Message Direction
                        1 = The message direction bit (Dir) is used for acceptance filtering.
                        0 = The message direction bit (Dir) has no effect on the acceptance filtering.            </description>
            <name>MDir</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask Extended Identifier
                        1 = The extended identifier bit (IDE) is used for acceptance filtering.
                        0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
                        Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered.</description>
            <name>MXtd</name>
          </field>
        </fields>
        <name>CAN_IF1_MASK2</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>IF1 Arbitration 1 Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Message Identifier 15-0
                        ID28 - ID0, 29-bit Identifier ("Extended Frame").
                        ID28 - ID18, 11-bit Identifier ("Standard Frame") </description>
            <name>ID_0_15</name>
          </field>
        </fields>
        <name>CAN_IF1_ARB1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>IF1 Arbitration 2 Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>Message Identifier 28-16
                        ID28 - ID0, 29-bit Identifier ("Extended Frame").
                        ID28 - ID18, 11-bit Identifier ("Standard Frame")</description>
            <name>ID_16_28</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Message Direction
                        1 = Direction is transmit
                        On TxRqst, the respective Message Object is transmitted as a Data Frame. On reception of a Remote Frame with matching identifier, the TxRqst bit of this Message Object is set (if RmtEn = one).
                        0 = Direction is receive
                        On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted. On reception of a Data Frame with matching identifier, that message is stored in this Message Object.</description>
            <name>Dir</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Extended Identifier
                        1 = The 29-bit ("extended") Identifier will be used for this Message Object.
                        0 = The 11-bit ("standard") Identifier will be used for this Message Object.</description>
            <name>Xtd</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Message Valid
                        1 = The Message Object is configured and should be considered by the Message Handler.
                        0 = The Message Object is ignored by the Message Handler.
                        Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN Control Register. This bit must also be reset before the identifier Id28-0, the control bits Xtd, Dir, or the Data Length Code DLC3-0  are modified,  or if the Messages  Object  is no longer required.</description>
            <name>MsgVal</name>
          </field>
        </fields>
        <name>CAN_IF1_ARB2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>IF1 Message Control Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Length Code
                        0-8: Data Frame has 0-8 data bytes.
                        9-15: Data Frame has 8 data bytes
                        Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
                        Data 0: 1st data byte of a CAN Data Frame
                        Data 1: 2nd data byte of a CAN Data Frame
                        Data 2: 3rd data byte of a CAN Data Frame
                        Data 3: 4th data byte of a CAN Data Frame
                        Data 4: 5th data byte of a CAN Data Frame
                        Data 5: 6th data byte of a CAN Data Frame
                        Data 6: 7th data byte of a CAN Data Frame
                        Data 7 : 8th data byte of a CAN Data Frame
                        Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last. When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object. If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.</description>
            <name>DLC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Buffer
                        1 = Single Message Object or last Message Object of a FIFO Buffer.
                        0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
                        Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer. For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one. </description>
            <name>EoB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Request
                        1 = The transmission of this Message Object is requested and is not yet done.
                        0 = This Message Object is not waiting for transmission.</description>
            <name>TxRqst</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Remote Enable
                        1 = At the reception of a Remote Frame, TxRqst is set.
                        0 = At the reception of a Remote Frame, TxRqst is left unchanged.</description>
            <name>RmtEn</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Interrupt Enable
                        1 = IntPnd will be set after a successful reception of a frame.
                        0 = IntPnd will be left unchanged after a successful reception of a frame.</description>
            <name>RxIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Interrupt Enable
                        1 = IntPnd will be set after a successful transmission of a frame.
                        0 = IntPnd will be left unchanged after the successful transmission of a frame.</description>
            <name>TxIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Use Acceptance Mask
                        1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
                        0 = Mask ignored.
                        Note: If the UMask bit is set to one, the Message Object's mask bits have  to  be  programmed  during  initialization  of  the  Message Object before MsgVal is set to one.</description>
            <name>UMask</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pending
                        1 = This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
                        0 = This message object is not the source of an interrupt.</description>
            <name>IntPnd</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Message Lost (only valid for Message Objects with direction = receive)
                        1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
                        0 = No message lost since last time this bit was reset by the CPU.</description>
            <name>MsgLst</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>New Data
                        1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
                        0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.</description>
            <name>NewDat</name>
          </field>
        </fields>
        <name>CAN_IF1_MCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>IF1 Data A1 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 0
                        1st data byte of a CAN Data Frame</description>
            <name>Data0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 1
                        2nd data byte of a CAN Data Frame</description>
            <name>Data1</name>
          </field>
        </fields>
        <name>CAN_IF1_DAT_A1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>IF1 Data A2 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 2
                        1st data byte of a CAN Data Frame</description>
            <name>Data2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 3
                        2nd data byte of a CAN Data Frame</description>
            <name>Data3</name>
          </field>
        </fields>
        <name>CAN_IF1_DAT_A2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>IF1 Data B1 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 4
                        1st data byte of a CAN Data Frame</description>
            <name>Data4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 5
                        2nd data byte of a CAN Data Frame</description>
            <name>Data5</name>
          </field>
        </fields>
        <name>CAN_IF1_DAT_B1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>IF1 Data B2 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 6
                        1st data byte of a CAN Data Frame</description>
            <name>Data6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 7
                        2nd data byte of a CAN Data Frame</description>
            <name>Data7</name>
          </field>
        </fields>
        <name>CAN_IF1_DAT_B2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>IF2 Command Request Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Message Number
                        0x01-0x20: Valid Message Number, the Message Object in the Message
                        RAM is selected for data transfer.
                        0x00: Not a valid Message Number, interpreted as 0x20.
                        0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.</description>
            <name>MessageNumber</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Busy Flag
                        1 = Writing to the IF2 Command Request Register is in progress. This bit can only be read by the software.
                        0 = Read/write action has finished.</description>
            <name>Busy</name>
          </field>
        </fields>
        <name>CAN_IF2_CREQ</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>IF2 Command Mask Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Data Bytes [7:4]
                        Direction = Write 
                        1 = Transfer Data Bytes [7:4] to Message Object.
                        0 = Data Bytes [7:4] unchanged.
                        Direction = Read
                        1 = Transfer Data Bytes [7:4] to IF2 Message Buffer Register.
                        0 = Data Bytes [7:4] unchanged.</description>
            <name>DAT_B</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Data Bytes [3:0]
                        Direction = Write
                        1 = Transfer Data Bytes [3:0] to Message Object 
                        0 = Data Bytes [3:0] unchanged.
                        Direction = Read
                        1 = Transfer Data Bytes [3:0] to IF2 Message Buffer Register.
                        0 = Data Bytes [3:0] unchanged.</description>
            <name>DAT_A</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Transmission Request Bit  when Direction = Write
                        1 = Set TxRqst bit.
                        0 = TxRqst bit unchanged.
                        Note: If a transmission is requested by programming bit TxRqst/NewDat in the IF2 Command Mask Register, bit TxRqst in the IF2 Message Control Register will be ignored.
                        Access New Data Bit when Direction = Read
                        1 = Clear NewDat bit in the Message Object 
                        0 = NewDat bit remains unchanged.
                        Note : A read access to a Message Object can be combined with the reset of the control bits IntPnd and NewDat. The values of these bits transferred to the IF2 Message Control Register always reflect the status before resetting these bits.</description>
            <name>TxRqstOrNewDat</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Interrupt Pending Bit
                        Direction = Write
                        When writing to a Message Object, this bit is ignored.
                        Direction = Read
                        1 = Clear IntPnd bit in the Message Object.
                        0 = IntPnd bit remains unchanged.</description>
            <name>ClrIntPnd</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Control Access Control Bits
                        Direction = Write
                        1 = Transfer Control Bits to Message Object.
                        0 = Control Bits unchanged
                        Direction = Read
                        1 = Transfer Control Bits to IF2 Message Buffer Register.
                        0 = Control Bits unchanged.</description>
            <name>Control</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Arbitration Bits
                        Direction = Write
                        1 = Transfer Identifier + Dir + Xtd + MsgVal to Message Object 
                        0 = Arbitration bits unchanged.
                        Direction = Read
                        1 = Transfer Identifier + Dir + Xtd + MsgVal to IF2 Message Buffer Register.
                        0 = Arbitration bits unchanged.</description>
            <name>Arb</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Access Mask Bits
                        Direction = Write
                        1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
                        0: = Mask bits unchanged.
                        Direction = Read
                        1 = Transfer Identifier Mask + MDir + MXtd to IF2 Message Buffer Register.
                        0 = Mask bits unchanged.</description>
            <name>Mask</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write / Read
                        1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object addressed by the Command Request Register.
                        0 = Read: Transfer data from the Message Object addressed by the Command Request Register into the selected Message Buffer Registers.</description>
            <name>WROrRD</name>
          </field>
        </fields>
        <name>CAN_IF2_CMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x88</addressOffset>
        <description>IF2 Mask 1 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Identifier Mask 15-0
                        1 = The corresponding identifier bit is used for acceptance filtering.
                        0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.</description>
            <name>Msk_0_15</name>
          </field>
        </fields>
        <name>CAN_IF2_MASK1</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8C</addressOffset>
        <description>IF2 Mask 2 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>Identifier Mask 28-16
                        1 = The corresponding identifier bit is used for acceptance filtering.
                        0 = The corresponding bit in the identifier of the message object cannot inhibit the match in the acceptance filtering.</description>
            <name>Msk_16_28</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask Message Direction
                        1 = The message direction bit (Dir) is used for acceptance filtering.
                        0 = The message direction bit (Dir) has no effect on the acceptance filtering.            </description>
            <name>MDir</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Mask Extended Identifier
                        1 = The extended identifier bit (IDE) is used for acceptance filtering.
                        0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
                        Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of received Data Frames are written into bits ID28 to ID18. For acceptance filtering, only these bits together with mask bits Msk28 to Msk18 are considered.</description>
            <name>MXtd</name>
          </field>
        </fields>
        <name>CAN_IF2_MASK2</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>IF2 Arbitration 1 Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Message Identifier 15-0
                        ID28 - ID0, 29-bit Identifier ("Extended Frame").
                        ID28 - ID18, 11-bit Identifier ("Standard Frame") </description>
            <name>ID_0_15</name>
          </field>
        </fields>
        <name>CAN_IF2_ARB1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>IF2 Arbitration 2 Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xD</bitWidth>
            <description>Message Identifier 28-16
                        ID28 - ID0, 29-bit Identifier ("Extended Frame").
                        ID28 - ID18, 11-bit Identifier ("Standard Frame")</description>
            <name>ID_16_28</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Message Direction
                        1 = Direction is transmit
                        On TxRqst, the respective Message Object is transmitted as a Data Frame. On reception of a Remote Frame with matching identifier, the TxRqst bit of this Message Object is set (if RmtEn = one).
                        0 = Direction is receive
                        On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted. On reception of a Data Frame with matching identifier, that message is stored in this Message Object.</description>
            <name>Dir</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Extended Identifier
                        1 = The 29-bit ("extended") Identifier will be used for this Message Object.
                        0 = The 11-bit ("standard") Identifier will be used for this Message Object.</description>
            <name>Xtd</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Message Valid
                        1 = The Message Object is configured and should be considered by the Message Handler.
                        0 = The Message Object is ignored by the Message Handler.
                        Note: The application software must reset the MsgVal bit of all unused Messages Objects during the initialization before it resets bit Init in the CAN Control Register. This bit must also be reset before the identifier Id28-0, the control bits Xtd, Dir, or the Data Length Code DLC3-0  are modified,  or if the Messages  Object  is no longer required.</description>
            <name>MsgVal</name>
          </field>
        </fields>
        <name>CAN_IF2_ARB2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x98</addressOffset>
        <description>IF2 Message Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Data Length Code
                        0-8: Data Frame has 0-8 data bytes.
                        9-15: Data Frame has 8 data bytes
                        Note: The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message.
                        Data 0: 1st data byte of a CAN Data Frame
                        Data 1: 2nd data byte of a CAN Data Frame
                        Data 2: 3rd data byte of a CAN Data Frame
                        Data 3: 4th data byte of a CAN Data Frame
                        Data 4: 5th data byte of a CAN Data Frame
                        Data 5: 6th data byte of a CAN Data Frame
                        Data 6: 7th data byte of a CAN Data Frame
                        Data 7 : 8th data byte of a CAN Data Frame
                        Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core during a reception while the Data 7 byte is the last. When the Message Handler stores a Data Frame, it will write all the eight data bytes into a Message Object. If the Data Length Code is less than 8, the remaining bytes of the Message Object will be overwritten by unspecified values.</description>
            <name>DLC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Buffer
                        1 = Single Message Object or last Message Object of a FIFO Buffer.
                        0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO Buffer.
                        Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO Buffer. For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one. </description>
            <name>EoB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Request
                        1 = The transmission of this Message Object is requested and is not yet done.
                        0 = This Message Object is not waiting for transmission.</description>
            <name>TxRqst</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Remote Enable
                        1 = At the reception of a Remote Frame, TxRqst is set.
                        0 = At the reception of a Remote Frame, TxRqst is left unchanged.</description>
            <name>RmtEn</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Interrupt Enable
                        1 = IntPnd will be set after a successful reception of a frame.
                        0 = IntPnd will be left unchanged after a successful reception of a frame.</description>
            <name>RxIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Interrupt Enable
                        1 = IntPnd will be set after a successful transmission of a frame.
                        0 = IntPnd will be left unchanged after the successful transmission of a frame.</description>
            <name>TxIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Use Acceptance Mask
                        1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
                        0 = Mask ignored.
                        Note: If the UMask bit is set to one, the Message Object's mask bits have  to  be  programmed  during  initialization  of  the  Message Object before MsgVal is set to one.</description>
            <name>UMask</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pending
                        1 = This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
                        0 = This message object is not the source of an interrupt.</description>
            <name>IntPnd</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Message Lost (only valid for Message Objects with direction = receive)
                        1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU has lost a message.
                        0 = No message lost since last time this bit was reset by the CPU.</description>
            <name>MsgLst</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>New Data
                        1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
                        0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the application software.</description>
            <name>NewDat</name>
          </field>
        </fields>
        <name>CAN_IF2_MCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9C</addressOffset>
        <description>IF2 Data A1 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 0
                        1st data byte of a CAN Data Frame</description>
            <name>Data0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 1
                        2nd data byte of a CAN Data Frame</description>
            <name>Data1</name>
          </field>
        </fields>
        <name>CAN_IF2_DAT_A1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA0</addressOffset>
        <description>IF2 Data A2 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 2
                        1st data byte of a CAN Data Frame</description>
            <name>Data2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 3
                        2nd data byte of a CAN Data Frame</description>
            <name>Data3</name>
          </field>
        </fields>
        <name>CAN_IF2_DAT_A2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>IF2 Data B1 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 4
                        1st data byte of a CAN Data Frame</description>
            <name>Data4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 5
                        2nd data byte of a CAN Data Frame</description>
            <name>Data5</name>
          </field>
        </fields>
        <name>CAN_IF2_DAT_B1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA8</addressOffset>
        <description>IF2 Data B2 Registers</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 6
                        1st data byte of a CAN Data Frame</description>
            <name>Data6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Data byte 7
                        2nd data byte of a CAN Data Frame</description>
            <name>Data7</name>
          </field>
        </fields>
        <name>CAN_IF2_DAT_B2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x100</addressOffset>
        <description>Transmission Request Registers 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmission Request Bits 1-16 (of all Message Objects)
                        1 = The transmission of this Message Object is requested and is not yet done.
                        0 = This Message Object is not waiting for transmission.
                        These bits are read only.</description>
            <name>TxRqst1_16</name>
          </field>
        </fields>
        <name>CAN_TXREQ1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x104</addressOffset>
        <description>Transmission Request Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmission Request Bits 17-32 (of all Message Objects)
                        1 = The transmission of this Message Object is requested and is not yet done.
                        0 = This Message Object is not waiting for transmission.
                        These bits are read only.</description>
            <name>TxRqst17_32</name>
          </field>
        </fields>
        <name>CAN_TXREQ2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x120</addressOffset>
        <description>New Data Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>New Data Bits 1-16 (of all Message Objects)
                        1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
                        0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.</description>
            <name>NewData1_16</name>
          </field>
        </fields>
        <name>CAN_NDAT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x124</addressOffset>
        <description>New Data Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>New Data Bits 17-32 (of all Message Objects)
                        1 = The Message Handler or the application software has written new data into the data portion of this Message Object.
                        0 = No new data has been written into the data portion of this Message Object by the Message Handler since the last time this flag was cleared by the application software.</description>
            <name>NewData17_32</name>
          </field>
        </fields>
        <name>CAN_NDAT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x140</addressOffset>
        <description>Interrupt Pending Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Interrupt Pending Bits 1-16 (of all Message Objects)
                        1 = This message object is the source of an interrupt.
                        0 = This message object is not the source of an interrupt.</description>
            <name>IntPnd1_16</name>
          </field>
        </fields>
        <name>CAN_IPND1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x144</addressOffset>
        <description>Interrupt Pending Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Interrupt Pending Bits 17-32 (of all Message Objects)
                        1 = This message object is the source of an interrupt.
                        0 = This message object is not the source of an interrupt.</description>
            <name>IntPnd17_32</name>
          </field>
        </fields>
        <name>CAN_IPND2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x160</addressOffset>
        <description>Message Valid Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Message Valid Bits 1-16 (of all Message Objects) (Read Only)
                        1 = This Message Object is configured and should be considered by the Message Handler.
                        0 = This Message Object is ignored by the Message Handler.
                        Ex. CAN_MVLD1[0] means Message object No.1 is valid or not. If CAN_MVLD1[0] is set, message object No.1 is configured.</description>
            <name>MsgVal1_16</name>
          </field>
        </fields>
        <name>CAN_MVLD1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x164</addressOffset>
        <description>Message Valid Register 2</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Message Valid Bits 17-32 (of all Message Objects) (Read Only)
                        1 = This Message Object is configured and should be considered by the Message Handler.
                        0 = This Message Object is ignored by the Message Handler.
                        Ex. CAN_MVLD1[0] means Message object No.1 is valid or not. If CAN_MVLD1[0] is set, message object No.1 is configured.</description>
            <name>MsgVal17_32</name>
          </field>
        </fields>
        <name>CAN_MVLD2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x168</addressOffset>
        <description>Wake Up Function Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake Up Enable
                        1 = The wake-up function is enable.
                        0 = The wake-up function is disable.
                        Note: User can wake-up system when there is a falling edge in the CAN_Rx pin..</description>
            <name>WAKUP_EN</name>
          </field>
        </fields>
        <name>CAN_WU_EN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x16C</addressOffset>
        <description>Wake Up Function Status</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake Up Status 
                        1 = Wake-up event is occurred.
                        0 = No wake-up event is occurred.
                        Note: The bit can be written '0' to clear.</description>
            <name>WAKUP_STS</name>
          </field>
        </fields>
        <name>CAN_WU_STATUS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000200</baseAddress>
    <description>Registers group</description>
    <groupName>CLK</groupName>
    <interrupts></interrupts>
    <name>CLK</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>System Power Down Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External 4~24 MHz Crystal Enable (write-protection bit)
                        The bit default value is set by flash controller user configuration register config0 [26:24]. When the default clock source is from external 4~24 MHz crystal, this bit is set to 1 automatically
                        1 = Enable external 4~24 MHz crystal 
                        0 = Disable external 4~24 MHz crystal</description>
            <name>XTL12M_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>External 32.768 KHz Crystal Enable (write-protection bit)
                        1 = Enable external 32.768 kHz Crystal (Normal operation)
                        0 = Disable external 32.768 kHz Crystal</description>
            <name>XTL32K_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Internal 22.1184MHz Oscillator Enable (write-protection bit)
                        1 = Enable 22.1184MHz Oscillation 
                        0 = Disable 22.1184MHz Oscillation </description>
            <name>OSC22M_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Internal 10KHz Oscillator Enable (write-protection bit)
                        1 = Enable 10KHz Oscillation 
                        0 = Disable 10KHz Oscillation </description>
            <name>OSC10K_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the wake up delay counter (write-protection bit)
                        When the chip wakes up from power down mode, the clock control will delay certain clock cycles to wait system clock stable.
                        The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz crystal, and 256 clock cycles when chip work at internal 22.1184 MHz oscillator.
                        1 = Enable clock cycles delay
                        0 = Disable clock cycles delay</description>
            <name>PD_WU_DLY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Power down mode wake up Interrupt enable (write-protection bit)
                        0 = Disable
                        1 = Enable.
                        The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.</description>
            <name>PD_WU_INT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Power down mode wake up interrupt status
                        Set by "power down wake up", it indicates that resume from power down mode 
                        The flag is set if the GPIO, USB, UART, WDT, CAN, ACMP, BOD or RTC wakeup occurred 
                        Write 1 to clear the bit 
                        Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1. </description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>PD_WU_STS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System power down enable bit (write-protection bit)
                        When CPU sets this bit "1" the chip power down mode is enabled, and chip power-down behavior will depends on the PD_WAIT_CPU bit.
                        (a) If the PD_WAIT_CPU is "0", then the chip enters power down mode immediately after the PWR_DOWN_EN bit set.
                        (b) if the PD_WAIT_CPU is "1", then the chip keeps active till the CPU sleep mode is also active and then the chip enters power down mode.
                        When chip wakes up from power down mode, this bit is auto cleared. Users need to set this bit again for next power down.
                        When in power down mode, external 4~24 MHz crystal and the internal 22.1184 MHz oscillator will be disabled in this mode, but the external 32 kHz crystal and internal 10 kHz oscillator are not controlled by power down mode.
                        When in power down mode, the PLL and system clock are disabled, and ignored the clock source selection. The clocks of peripheral are not controlled by power down mode, if the peripheral clock source is from 32 kHz crystal or the 10 kHz oscillator.
                        1 = Chip enter the power down mode instant or wait CPU sleep command WFI.
                        0 = Chip operate in normal mode or CPU in idle mode (sleep mode) because of WFI command.</description>
            <name>PWR_DOWN_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit control the power down entry condition (write-protection bit)
                        1 = Chip enter power down mode when the both PWR_DOWN_EN bit is set to 1 and CPU run WFI instruction.
                        0 = Chip entry power down mode when the PWR_DOWN_EN bit is set to 1.</description>
            <name>PD_WAIT_CPU</name>
          </field>
        </fields>
        <name>PWRCON</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0x10</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>AHB Devices Clock Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Clock Enable Control.
                        1 = Enable the PDMA engine clock.
                        0 = Disable the PDMA engine clock.</description>
            <name>PDMA_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash ISP Controller Clock Enable Control.
                        1 = Enable the Flash ISP engine clock.
                        0 = Disable the Flash ISP engine clock.</description>
            <name>ISP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI Controller Clock Enable Control (Low Density Only)
                        1 = Enable the EBI engine clock.
                        0 = Disable the EBI engine clock.</description>
            <name>EBI_EN</name>
          </field>
        </fields>
        <name>AHBCLK</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0xD</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>APB Devices Clock Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watch Dog Timer Clock Enable (write-protection bit)
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        The bit default value is set by flash controller. User configuration register config0 bit[31]
                        1 = Enable Watchdog Timer Clock
                        0 = Disable Watchdog Timer Clock</description>
            <name>WDT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-Time-Clock APB interface Clock Enable. 
                        This bit is used to control the RTC APB clock only, The RTC engine clock source is from the 32.768KHz crystal.
                        1 = Enable RTC Clock
                        0 = Disable RTC Clock</description>
            <name>RTC_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer0 Clock Enable
                        1 = Enable Timer0 Clock
                        0 = Disable Timer0 Clock</description>
            <name>TMR0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer1 Clock Enable 
                        1 = Enable Timer1 Clock
                        0 = Disable Timer1 Clock</description>
            <name>TMR1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer2 Clock Enable 
                        1 = Enable Timer2 Clock
                        0 = Disable Timer2 Clock</description>
            <name>TMR2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer3 Clock Enable 
                        1 = Enable Timer3 Clock
                        0 = Disable Timer3 Clock</description>
            <name>TMR3_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Frequency Divider Output Clock Enable
                        1 = Enable FDIV Clock
                        0 = Disable FDIV Clock</description>
            <name>FDIV_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C0 Clock Enable . 
                        1 = Enable I2C0 Clock
                        0 = Disable I2C0 Clock</description>
            <name>I2C0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C1 Clock Enable. 
                        1 = Enable I2C1 Clock
                        0 = Disable I2C1 Clock</description>
            <name>I2C1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 Clock Enable. 
                        1 = Enable SPI0 Clock
                        0 = Disable SPI0 Clock</description>
            <name>SPI0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 Clock Enable. 
                        1 = Enable SPI1 Clock
                        0 = Disable SPI1 Clock</description>
            <name>SPI1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI2 Clock Enable. (Medium Density Only)
                        1 = Enable SPI2 Clock
                        0 = Disable SPI2 Clock</description>
            <name>SPI2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI3 Clock Enable. (Medium Density Only)
                        1 = Enable SPI3 Clock
                        0 = Disable SPI3 Clock</description>
            <name>SPI3_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART0 Clock Enable.
                        1 = Enable UART0 clock
                        0 = Disable UART0 clock</description>
            <name>UART0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART1 Clock Enable.
                        1 = Enable UART1 clock
                        0 = Disable UART1 clock</description>
            <name>UART1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART2 Clock Enable.(Medium Density Only)
                        1 = Enable UART2 clock
                        0 = Disable UART2 clock</description>
            <name>UART2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_01 Clock Enable.
                        1 = Enable PWM01 clock
                        0 = Disable PWM01 clock</description>
            <name>PWM01_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_23 Clock Enable.
                        1 = Enable PWM23 clock
                        0 = Disable PWM23 clock</description>
            <name>PWM23_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_45 Clock Enable.(Medium Density Only)
                        1 = Enable PWM45 clock
                        0 = Disable PWM45 clock</description>
            <name>PWM45_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM_67 Clock Enable.(Medium Density Only)
                        1 = Enable PWM67 clock
                        0 = Disable PWM67 clock</description>
            <name>PWM67_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CAN Bus Controller-0 Clock Enable
                        1 = Enable CAN0 clock
                        0 = Disable CAN0 clock</description>
            <name>CAN0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USB 2.0 FS Device Controller Clock Enable
                        1 = Enable USB clock
                        0 = Disable USB clock</description>
            <name>USBD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog-Digital-Converter (ADC) Clock Enable.
                        1 = Enable ADC clock
                        0 = Disable ADC clock</description>
            <name>ADC_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2S Clock Enable
                        1 = Enable I2S Clock
                        0 = Disable I2S Clock</description>
            <name>I2S_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Comparator Clock Enable.
                        1 = Enable the Analog Comparator Clock
                        0 = Disable the Analog Comparator Clock</description>
            <name>ACMP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PS2 Clock Enable.
                        1 = Enable PS2 clock
                        0 = Disable PS2 clock</description>
            <name>PS2_EN</name>
          </field>
        </fields>
        <name>APBCLK</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Clock status monitor Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>XTL12M clock source stable flag
                        1 = XTL12M clock is stable
                        0 = XTL12M clock is not stable or disabled
                        This is read only bit</description>
            <name>XTL12M_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>XTL32K clock source stable flag
                        1 = XTL32K clock is stable
                        0 = XTL32K clock is not stable or disabled
                        This is read only bit</description>
            <name>XTL32K_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL clock source stable flag
                        1 = PLL clock is stable
                        0 = PLL clock is not stable or disabled
                        This is read only bit</description>
            <name>PLL_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>OSC10K clock source stable flag
                        1 = OSC10K clock is stable
                        0 = OSC10K clock is not stable or disabled
                        This is read only bit</description>
            <name>OSC10K_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>OSC22M clock source stable flag
                        1 = OSC22M clock is stable
                        0 = OSC22M clock is not stable or disabled
                        This is read only bit</description>
            <name>OSC22M_STB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock switching fail flag
                        1 = Clock switching failure
                        0 = Clock switching success
                        This bit is updated when software switches system clock source. If switch target clock is stable, this bit will be set to 1'b0. If switch target clock is not stable, this bit will be set to 1'b1.
                        Write 1 to clear the bit to zero</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLK_SW_FAIL</name>
          </field>
        </fields>
        <name>CLKSTATUS</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Clock Source Select Control Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>HCLK clock source select (write-protection bits)
                        Note:
                        1. Before clock switching, the related clock sources (both pre-select and new-select) must be turn on
                        2. The 3-bit default value is reloaded from the value of CFOSC (Config0[26:24]) in user configuration register of Flash controller by any reset. Therefore the default value is either 000b or 111b.
                        3. These bits are protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        000 = Clock source from external 4~24 MHz crystal clock
                        001 = Clock source from external 32.768 kHz crystal clock
                        010 = Clock source from PLL clock
                        011 = Clock source from internal 10 kHz oscillator clock
                        111 = Clock source from internal 22.1184 MHz oscillator clock
                        Others = reserved</description>
            <name>HCLK_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Cortex_M0 SysTick clock source select (write-protection bits)
                        If SYST_CSR[2]=0, SysTick uses listed clock source below
                        These bits are protected bit. It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        000 = clock source from 4~24 MHz crystal clock 
                        001 = Clock source from external 32.768 kHz crystal clock
                        010 = clock source from 12MHz crystal clock / 2
                        011 = clock source from HCLK / 2
                        1xx = Clock source from internal 22.1184 MHz oscillator clock / 2</description>
            <name>STCLK_S</name>
          </field>
        </fields>
        <name>CLKSEL0</name>
        <resetMask>0xFFFFFFF8</resetMask>
        <resetValue>0xFFFFFFF8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Clock Source Select Control Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Watchdog Timer clock source select (write-protection bits)
                        These bits are protected bit, program this need to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Reserved
                        10 = Clock source from HCLK/2048 clock.
                        11 = Clock source from internal 10 kHz oscillator clock.</description>
            <name>WDT_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>ADC clock source select
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = clock source from PLL clock
                        1x = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>ADC_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER0 clock source select.
                        000 = Clock source from external 4~24 MHz crystal clock.
                        001 = Clock source from external 32.768 kHz crystal clock.
                        010 = Clock source from HCLK.
                        011 = Clock source from external trigger.
                        1xx = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>TMR0_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER1 clock source select.
                        000 = Clock source from external 4~24 MHz crystal clock.
                        001 = Clock source from external 32.768 kHz crystal clock.
                        010 = Clock source from HCLK.
                        011 = Clock source from external trigger.
                        1xx = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>TMR1_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER2 clock source select.
                        000 = Clock source from external 4~24 MHz crystal clock.
                        001 = Clock source from external 32.768 kHz crystal clock.
                        010 = Clock source from HCLK.
                        011 = Clock source from external trigger.
                        1xx = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>TMR2_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>TIMER3 clock source select.
                        000 = Clock source from external 4~24 MHz crystal clock.
                        001 = Clock source from external 32.768 kHz crystal clock.
                        010 = Clock source from HCLK.
                        011 = Clock source from external trigger.
                        1xx = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>TMR3_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>UART clock source select.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from PLL clock.
                        1x = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>UART_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CAN clock source select
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from PLL clock.
                        1x = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>CAN_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM0 and PWM1 clock source select
                        PWM0 and PWM1 uses the same Engine clock source, both of them use the same prescaler.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from external 32.768 kHz crystal clock.
                        10 = Clock source from HCLK.
                        11 = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>PWM01_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM2 and PWM3 clock source select
                        PWM2 and PWM3 uses the same Engine clock source, both of them use the same prescaler.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from external 32.768 kHz crystal clock.
                        10 = Clock source from HCLK.
                        11 = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>PWM23_S</name>
          </field>
        </fields>
        <name>CLKSEL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Clock Divider Number Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>HCLK clock divide number from HCLK clock source
                        The HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1)</description>
            <name>HCLK_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>USB clock divide number from PLL clock
                        The USB clock frequency = (PLL frequency ) / (USB_N + 1)</description>
            <name>USB_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>UART clock divide number from UART clock source
                        The UART clock frequency = (UART clock source frequency ) / (UART_N + 1)</description>
            <name>UART_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>CAN clock divide number from CAN clock source
                        The CAN clock frequency = (CAN clock source frequency ) / (CAN_N + 1)
                        Which CAN_N = 16 * CAN_N_H + CAN_N_L</description>
            <name>CAN_N_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>ADC clock divide number from ADC clock source
                        The ADC clock frequency = (ADC engine clock source frequency ) / (ADC_N + 1)</description>
            <name>ADC_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>CAN clock divide number from CAN clock source (Low Density Only)
                        The CAN clock frequency = (CAN clock source frequency ) / (CAN_N + 1)
                        Which CAN_N = 16 * CAN_N_H + CAN_N_L</description>
            <name>CAN_N_H</name>
          </field>
        </fields>
        <name>CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Clock Source Select Control Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>I2S clock source select.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from PLL clock.
                        10 = Clock source from HCLK.
                        11 = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>I2S_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock Divider Clock Source Select.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from external 32.768 kHz crystal clock.
                        10 = Clock source from HCLK.
                        11 = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>FRQDIV_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM4 and PWM5 Clock Source Select.(Medium Density Only)
                        PWM4 and PWM5 used the same Engine clock source, both of them use the same prescaler.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from external 32.768 kHz crystal clock.
                        10 = Clock source from HCLK.
                        11 = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>PWM45_S</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PWM6 and PWM7 Clock Source Select.(Medium Density Only)
                        PWM6 and PWM7 used the same Engine clock source, both of them use the same prescaler.
                        00 = Clock source from external 4~24 MHz crystal clock.
                        01 = Clock source from external 32.768 kHz crystal clock.
                        10 = Clock source from HCLK.
                        11 = Clock source from internal 22.1184 MHz oscillator clock.</description>
            <name>PWM67_S</name>
          </field>
        </fields>
        <name>CLKSEL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PLL Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>PLL Feedback Divider Control Pins
                        Refer to the formulas below the table.
                        FOUT = FIN x NF/NR x 1/NO
                        Constrain:
                        1. 3.2MHz &lt; FIN &lt; 150MHz
                        2. 800KHz &lt; FIN/(2xNR) &lt; 8MHz
                        3. 100MHz &lt; FCO = FINxNF/NR &lt; 200MHz
                        , 120M &lt; FCO is preferred.
                        Symbol	Description	
                        FOUT	Output Clock Frequency	
                        FIN	Input (Reference) Clock Frequency	
                        NR	Input Divider (IN_DV + 2)	
                        NF	Feedback Divider (FB_DV + 2)	
                        NO	OUT_DV = "00":NO = 1
                        OUT_DV = "01":NO = 2
                        OUT_DV = "10":NO = 2
                        OUT_DV = "11":NO = 4	</description>
            <name>FB_DV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>PLL Input Divider Control Pins
                        Refer to the formulas below the table.
                        (Table is the same as FB_DV).</description>
            <name>IN_DV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PLL Output Divider Control Pins 
                        Refer to the formulas below the table.
                        (Table is the same as FB_DV).</description>
            <name>OUT_DV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Power Down Mode. 
                        If set the IDLE bit "1" in PWRCON register, the PLL will enter power down mode too
                        0 = PLL is in normal mode 
                        1 = PLL is in power-down mode(default)</description>
            <name>PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Bypass Control
                        0 = PLL is in normal mode (default)
                        1 = PLL clock output is same as clock input (XTALin)</description>
            <name>BP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL OE (FOUT enable) pin Control
                        0 = PLL FOUT enable
                        1 = PLL FOUT is fixed low</description>
            <name>OE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL Source Clock Select
                        1 = PLL source clock from 22.1184 MHz oscillator
                        0 = PLL source clock from 4~24 MHz crystal</description>
            <name>PLL_SRC</name>
          </field>
        </fields>
        <name>PLLCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5C22E</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Frequency Divider Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider Output Frequency Selection Bits
                        The formula of output frequency is
                        Fout = Fin/(2^(N+1)),
                        Fin is the input clock frequency.
                        Fout is the frequency of divider output clock.
                        N is the 4-bit value of FSEL[3:0].</description>
            <name>FSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Frequency Divider Enable Bit
                        0 = Disable Frequency Divider
                        1 = Enable Frequency Divider</description>
            <name>DIVIDER_EN</name>
          </field>
        </fields>
        <name>FRQDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x400D0000</baseAddress>
    <description>Registers group</description>
    <groupName>CMP</groupName>
    <interrupts></interrupts>
    <name>CMP</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Comparator0 Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator0 Enable
                        1 = Enable
                        0 = Disable
                        Comparator0 output needs wait 10 us stable time after CMP0EN is set</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator0 Interrupt Enable
                        1 = Enable comparator0 interrupt function
                        0 = Disable comparator0 interrupt function
                        Interrupt is generated if CMP0IE bit is set to 1 after comparator0 conversion finished.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CMP0 Hysterisis Enable
                        1 = Enable comparator0 Hysterisis function; the typical range is 20mV.
                        0 = Disable comparator0 Hysterisis function (Default).</description>
            <name>HYSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator0 negative input select
                        1 = The internal comparator reference voltage (Vref=1.2V) is selected as the negative comparator input
                        0 = The comparator0 reference pin CPN0 is selected as the negative comparator input</description>
            <name>CN0</name>
          </field>
        </fields>
        <name>CMP0CR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Comparator1 Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator1 Enable
                        1 = Enable
                        0 = Disable
                        Comparator1 output needs wait 10 us stable time after CMP1EN is set</description>
            <name>EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator1 Interrupt Enable
                        1 = Enable Comparator1 interrupt function
                        0 = Disable Comparator1 interrupt function
                        Interrupt is generated if CMP1IE bit is set to 1 after comparator1 conversion finished.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator1 Hysterisis Enable
                        1 = Enable comparator1 Hysterisis function; the typical range is 20mV.
                        0 = Disable comparator1 Hysterisis function (Default).</description>
            <name>HYSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator1 negative input select
                        1 = The internal comparator reference voltage (Vref=1.2V) is selected as the negative comparator input
                        0 = The comparator1 reference pin CPN1 is selected as the negative comparator input</description>
            <name>CN1</name>
          </field>
        </fields>
        <name>CMP1CR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Comparator Channel Selection Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator0 Flag
                        This bit is set by hardware whenever the comparator0 output changes state. This will cause an interrupt if CMP0IE set.
                        Write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CMPF0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator1 Flag
                        This bit is set by hardware whenever the comparator1 output changes state. This will cause an interrupt if CMP1IE set.
                        Write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CMPF1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator0 Output
                        Synchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (CMP0EN = 0).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CO0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator1 Output
                        Synchronized to the APB clock to allow reading by software. Cleared when the comparator is disabled (CMP1EN = 0).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CO1</name>
          </field>
        </fields>
        <name>CMPSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x8</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50010000</baseAddress>
    <description>Registers group</description>
    <groupName>EBI</groupName>
    <interrupts></interrupts>
    <name>EBI</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>External Bus Interface General Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI Enable
                        This bit is the functional enable bit for EBI. 
                        1: EBI function is enabled
                        0: EBI function is disabled</description>
            <name>ExtEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI data width 16 bit
                        This bit defines if the data bus is 8-bit or 16-bit. 
                        1: EBI data width is 16 bit
                        0: EBI data width is 8 bit</description>
            <name>ExtBW16</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>External Output Clock Divider
                        The frequency of EBI output clock is controlled by MCLKDIV as follows table:
                        MCLKDIV	Output clock (MCLK)	
                        000	HCLK/1	
                        001	HCLK/2	
                        010	HCLK/4	
                        011	HCLK/8	
                        100	HCLK/16	
                        101	HCLK/32	
                        
                        11X	default	
                        
                        Notice: Default value of output clock is HCLK/1</description>
            <name>MCLKDIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Expand Time of ALE
                        The ALE width (tALE) to latch the address can be controlled by ExttALE.
                        tALE = (ExttALE+1)*MCLK</description>
            <name>ExttALE</name>
          </field>
        </fields>
        <name>EBICON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>External Bus Interface Timing Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>EBI Data Access Time
                        ExttACC define data access time (tACC).
                        tACC = (ExttACC+1)*MCLK</description>
            <name>ExttACC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>EBI Data Access Hold Time
                        ExttAHD define data access hold time (tAHD).
                        tAHD = (ExttAHD+1)*MCLK</description>
            <name>ExttAHD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Idle State Cycle After Write
                        When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not zero.
                        Idle state cycle = (ExtIW2X)*MCLK</description>
            <name>ExtIW2X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Idle State Cycle Between Read-Read
                        When read action is finish and next action is going to read, idle state is inserted and nCS return to high if ExtIR2R is not zero.
                        Idle state cycle = (ExtIR2R)*MCLK</description>
            <name>ExtIR2R</name>
          </field>
        </fields>
        <name>EXTIME</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1C</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x5000C000</baseAddress>
    <description>Registers group</description>
    <groupName>FMC</groupName>
    <interrupts></interrupts>
    <name>FMC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>ISP Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP Enable
                        ISP function enable bit. Set this bit to enable ISP function.
                        1 = Enable ISP function
                        0 = Disable ISP function</description>
            <name>ISPEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Boot Select 
                        Set/clear this bit to select next booting from LDROM/APROM, respectively. This bit also functions as chip booting status flag, which can be used to check where chip booted from. This bit is initiated with the inversed value of CBS in Config0 after power-on reset; It keeps the same value at other reset.
                        1 = boot from LDROM
                        0 = boot from APROM</description>
            <name>BS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Config-bits Update by ISP
                        LDROM update enable bit. 
                        1 = Enable ISP can update config-bits.
                        0 = Disable ISP can update config-bits.</description>
            <name>CFGUEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LDROM Update Enable
                        LDROM update enable bit. 
                        1 = LDROM can be updated when the MCU runs in APROM.
                        0 = LDROM can not be updated</description>
            <name>LDUEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP Fail Flag
                        This bit is set by hardware when a triggered ISP meets any of the following conditions:
                        (1) APROM writes to itself.
                        (2) LDROM writes to itself. 
                        (3) CONFIG is erased/programmed if CFGUEN is set to 0.
                        (4) Destination address is illegal, such as over an available range.
                        Write 1 to clear.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISPFF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash Program Time
                        PT[2]	PT[1]	PT[0]	Program Time (us)	
                        0	0	0	40	
                        0	0	1	45	
                        0	1	0	50	
                        0	1	1	55	
                        1	0	0	20	
                        1	0	1	25	
                        1	1	0	30	
                        1	1	1	35	</description>
            <name>PT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash Erase Time
                        ET[2]	ET[1]	ET[0]	Erase Time (ms)	
                        0	0	0	20 (default)	
                        0	0	1	25	
                        0	1	0	30	
                        0	1	1	35	
                        1	0	0	3	
                        1	0	1	5	
                        1	1	0	10	
                        1	1	1	15	</description>
            <name>ET</name>
          </field>
        </fields>
        <name>ISPCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>ISP Address Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>ISP Address 
                        NuMicro(TM) NUC100 Series equips with a maximum 32Kx32 embedded flash, it supports word program only. ISPARD[1:0] must be kept 00b for ISP operation.</description>
            <name>ISPADR</name>
          </field>
        </fields>
        <name>ISPADR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>ISP Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>ISP Data 
                        Write data to this register before ISP program operation
                        Read data from this register after ISP read operation</description>
            <name>ISPDAT</name>
          </field>
        </fields>
        <name>ISPDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>ISP Command Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>ISP Command 
                        ISP command table is showed below:
                        Operation Mode	FOEN	FCEN	FCTRL[3:0]	
                        Read	0	0	0	0	0	0	
                        Program	1	0	0	0	0	1	
                        Page Erase	1	0	0	0	1	0	</description>
            <name>FCTRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP Command 
                        ISP command table is showed below:
                        Operation Mode	FOEN	FCEN	FCTRL[3:0]	
                        Read	0	0	0	0	0	0	
                        Program	1	0	0	0	0	1	
                        Page Erase	1	0	0	0	1	0	</description>
            <name>FCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP Command 
                        ISP command table is showed below:
                        Operation Mode	FOEN	FCEN	FCTRL[3:0]	
                        Read	0	0	0	0	0	0	
                        Program	1	0	0	0	0	1	
                        Page Erase	1	0	0	0	1	0	</description>
            <name>FOEN</name>
          </field>
        </fields>
        <name>ISPCMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>ISP Trigger Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ISP start trigger
                        Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when ISP operation is finished.
                        1 = ISP is on going
                        0 = ISP is operation is finished</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>ISPGO</name>
          </field>
        </fields>
        <name>ISPTRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Flash Base Address Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Flash Base Address
                        This register indicates data flash start address. It is a read only register.
                        For 128kB flash memory device, the data flash size is defined by user configuration, register content is loaded from Config1 when chip power on but for 64/32kB device, it is fixed at 0x01_f000 </description>
            <name>DFBADR</name>
          </field>
        </fields>
        <name>DFBADR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Flash Access Time Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash Power Save Enable
                        If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function. 
                        1 = Enable flash power saving
                        0 = Disable flash power saving</description>
            <name>FPSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Flash Access Time Window Select
                        These bits are used to decide flash sense amplifier active duration.
                        
                        
                        
                        FATS	Access Time window (ns)	
                        000	40	
                        001	50	
                        010	60	
                        011	70	
                        100	80	
                        101	90	
                        110	100	
                        111	reserved	</description>
            <name>FATS</name>
          </field>
        </fields>
        <name>FATCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000000</baseAddress>
    <description>Registers group</description>
    <groupName>GCR</groupName>
    <interrupts></interrupts>
    <name>GCR</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Part Device Identification Number Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Part Device Identification Number
                        This register reflects device part number code. S/W can read this register to identify which device is used.</description>
            <name>PDID</name>
          </field>
        </fields>
        <name>PDID</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>System Reset Source Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) module or bit CHIP_RST (IPRSTC1[0]) to indicate the previous reset source
                        1= The Power-On Reset (POR) or CHIP_RST had issued the reset signal to reset the system.
                        0= No reset from POR or CHIP_RS
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_POR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_RESET flag is set by the "reset signal" from the /RESET pin to indicate the previous reset source.
                        1 = The Pin /RESET had issued the reset signal to reset the system.
                        0 = No reset from /RESET pin
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_RESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The The RSTS_WDT flag is set by the "reset signal" from the watchdog timer to indicate the previous reset source.
                        1 = The watchdog timer had issued the reset signal to reset the system.
                        0 = No reset from watchdog timer
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_WDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_LVR flag is set by the "reset signal" from the Low-Voltage-Reset controller to indicate the previous reset source.
                        1 = The LVR controller had issued the reset signal to reset the system.
                        0 = No reset from LVR
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_LVR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_BOD flag is set by the "reset signal" from the Brown-Out-Detector controller to indicate the previous reset source.
                        1 = The BOD had issued the reset signal to reset the system.
                        0 = No reset from BOD
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_SYS flag is set by the "reset signal" from the Cortex_M0 kernel to indicate the previous reset source.
                        1 = The Cortex_M0 had issued the reset signal to reset the system by software writing 1 to bit SYSRESTREQ(AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C) in system control registers of Cortex_M0 kernel.
                        0 = No reset from Cortex_M0
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_SYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset Cortex-M0 CPU kernel and Flash memory controller (FMC).
                        1 = The Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST to 1
                        0 = No reset from CPU
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RSTS_CPU</name>
          </field>
        </fields>
        <name>RSTSRC</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>IP Reset Control Resister1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CHIP one shot reset (write-protection bit)
                        Setting this bit will reset the whole chip, including CPU kernel and all peripherals, and this bit will automatically return to 0 after the 2 clock cycles.
                        The CHIP_RST is same as the POR reset, all the chip controllers is reset and the chip setting from flash are also reload. About the difference between CHIP_RST and SYSRESETREQ, please refer to section 5.2.2 of TRM.
                        This bit is the protected bit. It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        1 = CHIP one shot reset
                        0 = CHIP normal operation</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CHIP_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CPU kernel one shot reset (write-protection bit)
                        Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit will automatically return to 0 after the 2 clock cycles
                        This bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        1 = CPU one shot reset
                        0 = CPU normal operation</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CPU_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Reset (write-protection bit in NUC100/NUC120/NUC130/NUC140 Low Density and NUC101)
                        Setting this bit to 1 will generate a reset signal to the PDMA. User need to set this bit to 0 to release from reset state
                        This bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100
                        1 = PDMA controller reset
                        0 = PDMA controller normal operation</description>
            <name>PDMA_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI Controller Reset (write-protection bit in NUC100/NUC120/NUC130/NUC140 Low Density 64-pin package)
                        Set this bit to 1 will generate a reset signal to the EBI. User need to set this bit to 0 to release from the reset state.
                        This bit is the protected bit, It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        1 = EBI controller reset
                        0 = EBI controller normal operation</description>
            <name>EBI_RST</name>
          </field>
        </fields>
        <name>IPRSTC1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>IP Reset Control Resister 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO controller Reset
                        1 = GPIO controller reset
                        0 = GPIO controller normal operation</description>
            <name>GPIO_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer0 controller Reset
                        1 = Timer0 controller reset
                        0 = Timer0 controller normal operation</description>
            <name>TMR0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer1 controller Reset
                        1 = Timer1 controller reset
                        0 = Timer1 controller normal operation</description>
            <name>TMR1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer2 controller Reset
                        1 = Timer2 controller reset
                        0 = Timer2 controller normal operation</description>
            <name>TMR2_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer3 controller Reset
                        1 = Timer3 controller reset
                        0 = Timer3 controller normal operation</description>
            <name>TMR3_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C0 controller Reset
                        1 = I2C0 controller reset
                        0 = I2C0 controller normal operation</description>
            <name>I2C0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C1 controller Reset
                        1 = I2C1 controller reset
                        0 = I2C1 controller normal operation</description>
            <name>I2C1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 controller Reset
                        1 = SPI0 controller reset
                        0 = SPI0 controller normal operation</description>
            <name>SPI0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 controller Reset
                        1 = SPI1 controller reset
                        0 = SPI1 controller normal operation</description>
            <name>SPI1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI2 controller Reset (Medium Density Only)
                        1 = SPI2 controller reset
                        0 = SPI2 controller normal operation</description>
            <name>SPI2_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI3 controller Reset (Medium Density Only)
                        1 = SPI3 controller reset
                        0 = SPI3 controller normal operation</description>
            <name>SPI3_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART0 controller Reset
                        1 = UART0 controller reset
                        0 = UART0 controller normal operation</description>
            <name>UART0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART1 controller Reset
                        1 = UART1 controller reset
                        0 = UART1 controller normal operation</description>
            <name>UART1_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART2 controller Reset (Medium Density Only)
                        1 = UART2 controller reset
                        0 = UART2 controller normal operation</description>
            <name>UART2_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM03 controller Reset
                        1 = PWM03 controller reset
                        0 = PWM03 controller normal operation</description>
            <name>PWM03_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PWM47 controller Reset (Medium Density Only)
                        1 = PWM47 controller reset
                        0 = PWM47 controller normal operation</description>
            <name>PWM47_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog Comparator Controller Reset
                        1 = Analog Comparator controller reset
                        0 = Analog Comparator controller normal operation</description>
            <name>ACMP_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PS2 Controller Reset
                        1 = PS2 controller reset
                        0 = PS2 controller normal operation</description>
            <name>PS2_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CAN0 Controller Reset
                        1 = CAN0 controller reset
                        0 = CAN0 controller normal operation</description>
            <name>CAN0_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USB Device Controller Reset
                        1 = USB device controller reset
                        0 = USB devide controller normal operation</description>
            <name>USBD_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>ADC Controller Reset
                        1 = ADC controller reset
                        0 = ADC controller normal operation</description>
            <name>ADC_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2S Controller Reset
                        1 = I2S controller reset
                        0 = I2S controller normal operation</description>
            <name>I2S_RST</name>
          </field>
        </fields>
        <name>IPRSTC2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Brown Out Detector Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector Enable
                        The default value is set by flash controller user configuration register config0 bit[23].
                        1 = Brown Out Detector function is enabled
                        0 = Brown Out Detector function is disabled
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.</description>
            <name>BOD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Brown Out Detector Threshold Voltage Selection
                        The default value is set by flash controller user configuration register config0 bit[22:21].
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.
                        BOV_VL[1]	BOV_VL[0]	Brown out voltage	
                        1	1	4.5V	
                        1	0	3.8V	
                        0	1	2.7V	
                        0	0	2.2V	</description>
            <name>BOD_VL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Reset 
                        1 = Enable the Brown Out "RESET" function.
                        While the Brown Out Detector function is enabled (BOD_EN high) and BOD reset function is enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is lower than the threshold (BOD_OUT high).
                        0 = Enable the Brown Out "INTERRUPT" function
                        While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN low), BOD will assert an interrupt if BOD_OUT is high. BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
                        The default value is set by flash controller user configuration register config0 bit[20].
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.</description>
            <name>BOD_RSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector Interrupt Flag
                        1 = When Brown Out Detector detects the VDD is dropped down through the voltage of BOD_VL setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and the brown out interrupt is requested if brown out interrupt is enabled.
                        0 = Brown Out Detector does not detect any voltage draft at VDD down through or up through the voltage of BOD_VL setting.
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BOD_INTF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector Low power Mode
                        1 = Enable the BOD low power mode
                        0 = BOD operate in normal mode (default)
                        The BOD consumes about 100uA in normal mode, the low power mode can reduce the current to about 1/10 but slow the BOD response.
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.</description>
            <name>BOD_LPM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Brown Out Detector output status
                        1 = Brown Out Detector output status is 1. It means the detected voltage is lower than BOD_VL setting. If the BOD_EN is 0, BOD function disabled , this bit always responds 0
                        0 = Brown Out Detector output status is 0. It means the detected voltage is higher than BOD_VL setting or BOD_EN is 0</description>
            <name>BOD_OUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Low Voltage Reset Enable
                        The LVR function reset the chip when the input power voltage is lower than LVR circuit setting. LVR function is enabled in default.
                        1 = Enabled Low Voltage Reset function. After enabling the bit, the LVR function will be active with 100uS delay for LVR output stable (default)
                        0 = Disabled Low Voltage Reset function
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100</description>
            <name>LVR_EN</name>
          </field>
        </fields>
        <name>BODCR</name>
        <resetMask>0xFFFFFFF0</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Temperature Sensor Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Temperature sensor Enable
                        This bit is used to enable/disable temperature sensor function.
                        1 = Enabled temperature sensor function
                        0 = Disabled temperature sensor function (default)
                        After this bit is set to 1, the value of temperature can get from ADC conversion result by ADC channel selecting channel 7 and alternative multiplexer channel selecting temperature sensor. Detail ADC conversion function please reference ADC function chapter.</description>
            <name>VTEMP_EN</name>
          </field>
        </fields>
        <name>TEMPCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Power-On-Reset Controller Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>The register is used for the Power-On-Reset enable control
                        When power on, the POR circuit generates a reset signal to reset the whole chip function, but noise on the power may cause the POR active again. User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by writing 0x5AA5 to this field.
                        The POR function will be active again when this field is set to another value or chip is reset by other reset source, including: /RESET, Watch dog, LVR reset, BOD reset, ICE reset command and the software-chip reset function
                        This bit is the protected bit. It means programming this needs to write "59h", "16h", "88h" to address 0x5000_0100 to disable register protection. Reference the register REGWRPROT at address GCR_BA+0x100.</description>
            <name>POR_DIS_CODE</name>
          </field>
        </fields>
        <name>PORCR</name>
        <resetMask>0xFFFFFF00</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIOA multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.0 Pin Function Selection
                        1 = The ADC0 (Analog-to-Digital converter channel 0) function is selected to the pin PA.0
                        0 = The GPIOA[0] is selected to the pin PA.0</description>
            <name>GPA_MFP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.1 Pin Function Selection
                        The pin function depends on GPA_MFP1 and EBI_HB_EN[4] (ALT_MFP[20]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[4]	EBI_EN 	GPA_MFP[1]	PA.1 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	ADC1 (ADC)	
                        0 	1 	1 	ADC1 (ADC)	
                        1 	1 	1 	AD12 (EBI AD bus bit 12)	</description>
            <name>GPA_MFP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.2 Pin Function Selection
                        The pin function depends on GPA_MFP2 and EBI_HB_EN[3] (ALT_MFP[19]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[3]	EBI_EN 	GPA_MFP[2]	PA.2 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	ADC2 (ADC)	
                        0 	1 	1 	ADC2 (ADC)	
                        1 	1 	1 	AD11 (EBI AD bus bit 11)	</description>
            <name>GPA_MFP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.3 Pin Function Selection
                        The pin function depends on GPA_MFP3 and EBI_HB_EN[2] (ALT_MFP[18]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[2]	EBI_EN 	GPA_MFP[3]	PA.3 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	ADC3 (ADC)	
                        0 	1 	1 	ADC3 (ADC)	
                        1 	1 	1 	AD10 (EBI AD bus bit 10)	</description>
            <name>GPA_MFP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.4 Pin Function Selection
                        The pin function depends on GPA_MFP4 and EBI_HB_EN[1] (ALT_MFP[17]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[1]	EBI_EN 	GPA_MFP[4]	PA.4 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	ADC4 (ADC)	
                        0 	1 	1 	ADC4 (ADC)	
                        1 	1 	1 	AD9 (EBI AD bus bit 9)	</description>
            <name>GPA_MFP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.5 Pin Function Selection
                        The pin function depends on GPA_MFP5 and EBI_HB_EN[0] (ALT_MFP[16]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[0]	EBI_EN 	GPA_MFP[5]	PA.5 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	ADC5 (ADC)	
                        0 	1 	1 	ADC5 (ADC)	
                        1 	1 	1 	AD8 (EBI AD bus bit 8)	</description>
            <name>GPA_MFP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.6 Pin Function Selection
                        The pin function depends on GPA_MFP6 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPA_MFP[6]	PA.6 function 	
                        x 	0 	GPIO 	
                        0 	1 	ADC6 (ADC)	
                        1 	1 	AD7 (EBI AD bus bit 7)	</description>
            <name>GPA_MFP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.7 Pin Function Selection
                        The pin function depends on GPA_MFP7 and PA7_S21 (ALT_MFP[2]) and EBI_EN (ALT_MFP[11]).
                        EBI_EN	PA7_S21	GPA_MFP[7]	PA.7 function 	
                        x 	x 	0 	GPIO 	
                        0 	0 	1 	ADC7 (ADC)	
                        0 	1 	1 	SPISS21 (SPI2)	
                        1 	x 	1 	AD6 (EBI AD bus bit 6)	</description>
            <name>GPA_MFP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.8 Pin Function Selection
                        1 = The I2C0 SDA function is selected to the pin PA.8
                        0 = The GPIOA[8] is selected to the pin PA.8</description>
            <name>GPA_MFP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.9 Pin Function Selection
                        1 = The I2C0 SCL function is selected to the pin PA.9
                        0 = The GPIOA[9] is selected to the pin PA.9</description>
            <name>GPA_MFP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.10 Pin Function Selection
                        The pin function depends on GPA_MFP10 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPA_MFP[10]	PA.10 function 	
                        x 	0 	GPIO 	
                        0 	1 	SDA1 (I2C)	
                        1 	1 	nWR (EBI)	</description>
            <name>GPA_MFP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.11 Pin Function Selection
                        The pin function depends on GPA_MFP11 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPA_MFP[11]	PA.11 function 	
                        x 	0 	GPIO 	
                        0 	1 	SCL1 (I2C)	
                        1 	1 	nRD (EBI)	</description>
            <name>GPA_MFP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.12 Pin Function Selection
                        The pin function depends on GPA_MFP12 and EBI_HB_EN[5] (ALT_MFP[21]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[5]	EBI_EN 	GPA_MFP[12]	PA.12 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	PWM0 (PWM)	
                        0 	1 	1 	PWM0 (PWM)	
                        1 	1 	1 	AD13 (EBI AD bus bit 13)	</description>
            <name>GPA_MFP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.13 Pin Function Selection
                        The pin function depends on GPA_MFP13 and EBI_HB_EN[6] (ALT_MFP[22]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[6]	EBI_EN 	GPA_MFP[13]	PA.13 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	PWM1 (PWM)	
                        0 	1 	1 	PWM1 (PWM)	
                        1 	1 	1 	AD14 (EBI AD bus bit 14)	</description>
            <name>GPA_MFP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.14 Pin Function Selection
                        The pin function depends on GPA_MFP14 and EBI_HB_EN[7] (ALT_MFP[23]) and EBI_EN (ALT_MFP[11]).
                        EBI_HB_EN[7]	EBI_EN 	GPA_MFP[14]	PA.14 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	PWM2 (PWM)	
                        0 	1 	1 	PWM2 (PWM)	
                        1 	1 	1 	AD15 (EBI AD bus bit 15)	</description>
            <name>GPA_MFP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PA.14 Pin Function Selection
                        The pin function depends on GPA_MFP15 and PA15_I2SMCLK (ALT_MFP[9]).
                        PA15_I2SMCLK	GPA_MFP[15]	PA.15 function 	
                        x 	0 	GPIO 	
                        0 	1 	PWM3 (PWM) 	
                        1 	1 	I2SMCLK (I2S)	</description>
            <name>GPA_MFP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>1 = Enable GPIOA[15:0] I/O input Schmitt Trigger function
                        0 = Disable GPIOA[15:0] I/O input Schmitt Trigger function</description>
            <name>GPA_TYPEn</name>
          </field>
        </fields>
        <name>GPA_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>GPIOB multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.0 Pin Function Selection
                        1 = The UART0 RXD function is selected to the pin PB.0
                        0 = The GPIOB[0] is selected to the pin PB.0</description>
            <name>GPB_MFP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.1 Pin Function Selection
                        1 = The UART0 TXD function is selected to the pin PB.1
                        0 = The GPIOB[1] is selected to the pin PB.1</description>
            <name>GPB_MFP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.2 Pin Function Selection
                        The pin function depends on GPB_MFP2 and EBI_nWRL_EN (ALT_MFP[13]) and EBI_EN (ALT_MFP[11]).
                        EBI_nWRL_EN 	EBI_EN 	GPB_MFP[2]	PB.2 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	RTS0 (UART0)	
                        0 	1 	1 	RTS0 (UART0)	
                        1 	1 	1 	nWRL (EBI write low byte enable)	</description>
            <name>GPB_MFP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.3 Pin Function Selection
                        The pin function depends on GPB_MFP3 and EBI_nWRH_EN (ALT_MFP[14]) and EBI_EN (ALT_MFP[11]).
                        EBI_nWRH_EN 	EBI_EN 	GPB_MFP[3]	PB.3 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	CTS0 (UART0)	
                        0 	1 	1 	CTS0 (UART0)	
                        1 	1 	1 	nWRH (EBI write high byte enable)	</description>
            <name>GPB_MFP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.4 Pin Function Selection
                        1 = The UART1 RXD function is selected to the pin PB.4
                        0 = The GPIOB[4] is selected to the pin PB.4</description>
            <name>GPB_MFP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.5 Pin Function Selection
                        1 = The UART1 TXD function is selected to the pin PB.5
                        0 = The GPIOB[5] is selected to the pin PB.5</description>
            <name>GPB_MFP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.6 Pin Function Selection
                        The pin function depends on GPB_MFP6 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPB_MFP[6]	PB.6 function 	
                        x 	0 	GPIO 	
                        0 	1 	TRS1 (UART1)	
                        1 	1 	ALE (EBI)	</description>
            <name>GPB_MFP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.7 Pin Function Selection
                        The pin function depends on GPB_MFP7 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPB_MFP[7]	PB.7 function 	
                        x 	0 	GPIO 	
                        0 	1 	CTS1 (UART1)	
                        1 	1 	nCS (EBI)	</description>
            <name>GPB_MFP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.8 Pin Function Selection
                        1 = The TM0 (Timer/Counter external trigger clock input) function is selected to the pin PB.8
                        0 = The GPIOB[8] is selected to the pin PB.8</description>
            <name>GPB_MFP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.9 Pin Function Selection
                        The pin function depends on GPB_MFP9 and PB9_S11 (ALT_MFP[1]).
                        PB9_S11	GPB_MFP[9]	PB.9 function 	
                        x 	0 	GPIO 	
                        0 	1 	TM1 	
                        1 	1 	SPISS11 (SPI1)	</description>
            <name>GPB_MFP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.10 Pin Function Selection
                        The pin function depends on GPB_MFP10 and PB10_S01 (ALT_MFP[0]).
                        PB10_S01	GPB_MFP[10]	PB.10 function 	
                        x 	0 	GPIO 	
                        0 	1 	TM2 	
                        1 	1 	SPISS01 (SPI0)	</description>
            <name>GPB_MFP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.11 Pin Function Selection
                        The pin function depends on GPB_MFP11 and PB11_PWM4 (ALT_MFP[4]).
                        PB11_PWM4	GPB_MFP[11]	PB.11 function 	
                        x 	0 	GPIO 	
                        0 	1 	TM3 	
                        1 	1 	PWM4 (PWM)	</description>
            <name>GPB_MFP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.12 Pin Function Selection
                        The pin function depends on GPB_MFP12 and PB12_CLKO (ALT_MFP[10]) and EBI_EN (ALT_MFP[11]).
                        EBI_EN	PB12_CLKO	GPB_MFP[12]	PB.12 function 	
                        x 	x 	0 	GPIO 	
                        0 	0 	1 	CPO0(CMP) 	
                        0 	1 	1 	CLKO (Clock Driver output)	
                        1 	x 	1 	AD0(EBI AD bus bit 0) 	</description>
            <name>GPB_MFP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.13 Pin Function Selection
                        The pin function depends on GPB_MFP13 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPB_MFP[13]	PB.13 function 	
                        x 	0 	GPIO 	
                        0 	1 	CPO1 (CMP)	
                        1 	1 	AD1 (EBI AD bus bit 1)	</description>
            <name>GPB_MFP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.14 Pin Function Selection
                        The pin function depends on GPB_MFP14 and PB14_S31 (ALT_MFP[3]).
                        PB14_S31	GPB_MFP[14]	PB.14 function 	
                        x 	0 	GPIO 	
                        0 	1 	/INT0 	
                        1 	1 	SPISS31 (SPI3)	</description>
            <name>GPB_MFP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PB.15 Pin Function Selection
                        1 = The External Interrupt INT1 function is selected to the pin PB.15
                        0 = The GPIOB[15] is selected to the pin PB.15</description>
            <name>GPB_MFP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>1 = Enable GPIOB[15:0] I/O input Schmitt Trigger function
                        0 = Disable GPIOB[15:0] I/O input Schmitt Trigger function</description>
            <name>GPB_TYPEn</name>
          </field>
        </fields>
        <name>GPB_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>GPIOC multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.0 Pin Function Selection
                        Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
                        PC0_I2SLRCLK	GPC_MFP[0]	PC.0 function 	
                        x 	0 	GPIO 	
                        0 	1 	SPISS00(SPI0) 	
                        1 	1 	I2SLRCLK (I2S)	</description>
            <name>SPI0_SS0_I2SLRCLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.1 Pin Function Selection
                        Bits PC1_I2SBCLK (ALT_MFP[6]) and GPC_MFP[1] determine the PC.1 function.
                        PC1_I2SBCLK	GPC_MFP[1]	PC.1 function 	
                        x 	0 	GPIO 	
                        0 	1 	SPICLK0 (SPI0) 	
                        1 	1 	I2SBLK (I2S)	</description>
            <name>SPI0_CLK_I2SBCLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.2 Pin Function Selection
                        Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
                        PC2_I2SDI	GPC_MFP[2]	PC.2 function 	
                        x 	0 	GPIO 	
                        0 	1 	MISO00 (SPI0) 	
                        1 	1 	I2SDI (I2S)	</description>
            <name>SPI0_MISO0_I2SDI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.3 Pin Function Selection
                        Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
                        PC3_I2SDO	GPC_MFP[3]	PC.3 function 	
                        x 	0 	GPIO 	
                        0 	1 	MOSI00 (SPI0) 	
                        1 	1 	I2SDO (I2S)	</description>
            <name>SPI0_MOSI0_I2SDO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.4 Pin Function Selection
                        1 = The SPI0 MISO1 (master input, slave output pin-1) function is selected to the pin PC.4
                        0 = The GPIOC[4] is selected to the pin PC.4</description>
            <name>SPI0_MISO1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.5 Pin Function Selection
                        1 = The SPI0 MOSI1 (master output, slave input pin-1) function is selected to the pin PC.5
                        0 = The GPIOC[5] is selected to the pin PC.5</description>
            <name>SPI0_MOSI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.6 Pin Function Selection
                        The pin function depends on GPC_MFP6 and EBI_EN (ALT_MFP[11]).
                        EBI_EN	GPC_MFP[6]	PC.6 function 	
                        x 	0 	GPIO 	
                        0 	1 	CPP0 (CMP) 	
                        1 	1 	AD4 (EBI AD bus bit 4)	</description>
            <name>CPP0_AD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.7 Pin Function Selection
                        The pin function depends on GPC_MFP7 and EBI_EN (ALT_MFP[11]).
                        EBI_EN	GPC_MFP[7]	PC.7 function 	
                        x 	0 	GPIO 	
                        0 	1 	CPN0 (CMP) 	
                        1 	1 	AD5 (EBI AD bus bit 5)	</description>
            <name>CPN0_AD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.8 Pin Function Selection
                        The pin function depends on GPC_MFP8 and EBI_MCLK_EN (ALT_MFP[12]) and EBI_EN (ALT_MFP[11]).
                        EBI_MCLK_EN 	EBI_EN 	GPC_MFP[8]	PC.8 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	SPISS10 (SPI1) 	
                        0 	1 	1 	SPISS10 (SPI1) 	
                        1 	1 	1 	MCLK (EBI Clock output)	</description>
            <name>SPI1_SS0_MCLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.9 Pin Function Selection
                        1 = The SPI1 SPICLK function is selected to the pin PC.9
                        0 = The GPIOC[9] is selected to the pin PC.9</description>
            <name>SPI1_CLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.10 Pin Function Selection
                        1 = The SPI1 MISO0 (master input, slave output pin-0) function is selected to the pin PC.10
                        0 = The GPIOC[10] is selected to the pin PC.10</description>
            <name>SPI1_MISO0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.11 Pin Function Selection
                        1 = The SPI1 MOSI0 (master output, slave input pin-0) function is selected to the pin PC.11
                        0 = The GPIOC[11] is selected to the pin PC.11</description>
            <name>SPI1_MOSI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.12 Pin Function Selection
                        1 = The SPI1 MISO1 (master input, slave output pin-1) function is selected to the pin PC.12
                        0 = The GPIOC[12] is selected to the pin PC.12</description>
            <name>SPI1_MISO1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.13 Pin Function Selection
                        1 = The SPI1 MOSI1 (master output, slave input pin-1) function is selected to the pin PC.13
                        0 = The GPIOC[13] is selected to the pin PC.13</description>
            <name>SPI1_MOSI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.14 Pin Function Selection
                        The pin function depends on GPC_MFP14 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPC_MFP[14]	PC.14 function 	
                        x 	0 	GPIO 	
                        0 	1 	CPP1 (CMP)	
                        1 	1 	AD2 (EBI AD bus bit 2)	</description>
            <name>CPP1_AD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PC.15 Pin Function Selection
                        The pin function depends on GPC_MFP15 and EBI_EN (ALT_MFP[11]).
                        EBI_EN 	GPC_MFP[15]	PC.15 function 	
                        x 	0 	GPIO 	
                        0 	1 	CPN1 (CMP)	
                        1 	1 	AD3 (EBI AD bus bit 3)	</description>
            <name>CPP1_AD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>1 = Enable GPIOC[15:0] I/O input Schmitt Trigger function
                        0 = Disable GPIOC[15:0] I/O input Schmitt Trigger function</description>
            <name>SCHMITT</name>
          </field>
        </fields>
        <name>GPC_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>GPIOD multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.0 Pin Function Selection (Medium Density Only)
                        1 = The SPI2 SS20 function is selected to the pin PD.0
                        0 = The GPIOD[0] is selected to the pin PD.0</description>
            <name>GPD_MFP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.1 Pin Function Selection
                        For NUC100/NUC120/NUC130/NUC140 Medium Density
                        1 = The SPI2 SPICLK function is selected to the pin PD.1
                        0 = The GPIOD[1] is selected to the pin PD.1
                        For NUC100/NUC120/NUC130/NUC140 Low Density and NUC101 LQFP48 package
                        Reserved
                        For NUC101 QFN36 package
                        1 = The SPI0 SS01 function is selected to the pin PD.1
                        0 = The GPIOD[1] is selected to the pin PD.1</description>
            <name>GPD_MFP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.2 Pin Function Selection
                        For NUC100/NUC120/NUC130/NUC140 Medium Density
                        1 = The SPI2 MISO0 (master input, slave output pin-0) function is selected to the pin PD.2
                        0 = The GPIOD[2] is selected to the pin PD.2
                        For NUC100/NUC120/NUC130/NUC140 Low Density and NUC101 LQFP48 package
                        Reserved
                        For NUC101 QFN36 package
                        1 = The SPI0 MISO1 (master input, slave output pin-1) function is selected to the pin PD.2
                        0 = The GPIOD[2] is selected to the pin PD.2</description>
            <name>GPD_MFP2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.3 Pin Function Selection
                        For NUC100/NUC120/NUC130/NUC140 Medium Density
                        1 = The SPI2 MOSI0 (master output, slave input pin-0) function is selected to the pin GPD3
                        0 = The GPIOD[3] is selected to the pin PD.3
                        For NUC100/NUC120/NUC130/NUC140 Low Density and NUC101 LQFP48 package
                        Reserved
                        For NUC101 QFN36 package
                        1 = The SPI0 MOSI1 (master output, slave input pin-1) function is selected to the pin PD.3
                        0 = The GPIOD[3] is selected to the pin PD.3</description>
            <name>GPD_MFP3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.4 Pin Function Selection (Medium Density Only)
                        1 = The SPI2 MISO1 (master input, slave output pin-1) function is selected to the pin PD.4
                        0 = The GPIOD[4]is selected to the pin PD.4</description>
            <name>GPD_MFP4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.5 Pin Function Selection (Medium Density Only)
                        1 = The SPI2 MOSI1 (master output, slave input pin-1) function is selected to the pin PD.5
                        0 = The GPIOD[5] is selected to the pin PD.5</description>
            <name>GPD_MFP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.6 Pin Function Selection (Medium Density Only)
                        1 = The CAN0 RX function is selected to the pin PD.6
                        0 = The GPIOD[6] is selected to the pin PD.6</description>
            <name>GPD_MFP6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.7 Pin Function Selection (Medium Density Only)
                        1 = The CAN0 TX function is selected to the pin PD.7
                        0 = The GPIOD[7] is selected to the pin PD.7</description>
            <name>GPD_MFP7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.8 Pin Function Selection (Medium Density Only)
                        1 = The SPI3 SS30 function is selected to the pin PD8
                        0 = The GPIOD[8] is selected to the pin PD8</description>
            <name>GPD_MFP8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.9 Pin Function Selection (Medium Density Only)
                        1 = The SPI3 SPICLK function is selected to the pin PD.9
                        0 = The GPIOD-9 is selected to the pin PD.9</description>
            <name>GPD_MFP9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.10 Pin Function Selection (Medium Density Only)
                        1 = The SPI3 MISO0 (master input, slave output pin-0) function is selected to the pin PD.10
                        0 = The GPIOD[10] is selected to the pin PD.10</description>
            <name>GPD_MFP10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.11 Pin Function Selection (Medium Density Only)
                        1 = The SPI3 MOSI0 (master output, slave input pin-0) function is selected to the pin PD.11
                        0 = The GPIOD[11] is selected to the pin PD.11</description>
            <name>GPD_MFP11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.12 Pin Function Selection (Medium Density Only)
                        1 = The SPI3 MISO1 (master input, slave output pin-1) function is selected to the pin PD.12
                        0 = The GPIOD[12] is selected to the pin PD.12</description>
            <name>GPD_MFP12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.13 Pin Function Selection (Medium Density Only)
                        1 = The SPI3 MOSI1 (master output, slave input pin-1) function is selected to the pin PD.13
                        0 = The GPIOD[13] is selected to the pin PD.13</description>
            <name>GPD_MFP13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.14 Pin Function Selection (Medium Density Only)
                        1 = The UART2 RXD function is selected to the pin PD.14
                        0 = The GPIOD[14] selected to the pin PD.14</description>
            <name>GPD_MFP14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PD.15 Pin Function Selection (Medium Density Only)
                        1 = The UART2 TXD function is selected to the pin PD.15
                        0 = The GPIOD[15] selected to the pin PD.15</description>
            <name>GPD_MFP15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>1 = Enable GPIOD[15:0] I/O input Schmitt Trigger function
                        0 = Disable GPIOD[15:0] I/O input Schmitt Trigger function</description>
            <name>GPD_TYPEn</name>
          </field>
        </fields>
        <name>GPD_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>GPIOE multiple function and input type control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PE.0 Pin Function Selection (Medium Density Only)
                        1 = The PWM6 function is selected to the pin PE.0
                        0 = The GPIOE[0] is selected to the pin PE.0</description>
            <name>GPE_MFP0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PE.1 Pin Function Selection (Medium Density Only)
                        1 = The PWM7 function is selected to the pin PE.1
                        0 = The GPIOE[1] is selected to the pin PE.1</description>
            <name>GPE_MFP1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PE.5 Pin Function Selection (Medium Density Only)
                        1 = The PWM5 function is selected to the pin PE.5
                        0 = The GPIOE[5] is selected to the pin PE.5</description>
            <name>GPE_MFP5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>1 = Enable GPIOE[15:0] I/O input Schmitt Trigger function
                        0 = Disable GPIOE[15:0] I/O input Schmitt Trigger function
                        Note: In this field, Low Density only has GPE_TYPE5 bit</description>
            <name>GPE_TYPEn</name>
          </field>
        </fields>
        <name>GPE_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Alternative Multiple Function Pin Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PB10_S01 and GPB_MFP10 determine the PB.10 function.
                        PB10_S01	GPB_MFP[10]	PB.10 function 	
                        x 	0 	GPIO 	
                        0 	1 	TM2 	
                        1 	1 	SPISS01 (SPI0)	</description>
            <name>PB10_S01</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PB9_S11 and GPB_MFP9 determine the PB.9 function.
                        PB9_S11	GPB_MFP[9]	PB.9 function 	
                        x 	0 	GPIO 	
                        0 	1 	TM1 	
                        1 	1 	SPISS11 (SPI1)	</description>
            <name>PB9_S11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PA7_S21, PA_MFP7 and EBI_EN (ALT_MFP[11])determine the PA.7 function.
                        EBI_EN	PA7_S21	GPA_MFP[7]	PA.7 function 	
                        x 	x 	0 	GPIO 	
                        0 	0 	1 	ADC7 (ADC)	
                        0 	1 	1 	SPISS21 (SPI2)	
                        1 	x 	1 	AD6 (EBI AD bus bit 6)	</description>
            <name>PA7_S21</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PB14_S31 and GPB_MFP14 determine the GPB14 function.
                        PB14_S31	GPB_MFP[14]	PB.14 function 	
                        x 	0 	GPIO 	
                        0 	1 	/INT0 	
                        1 	1 	SPISS31 (SPI3)	</description>
            <name>PB14_S31</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PB11_PWM4 and GPB_MFP[11] determine the PB.11 function.
                        PB11_PWM4	GPB_MFP[11]	PB.11 function 	
                        x 	0 	GPIO 	
                        0 	1 	TM3 	
                        1 	1 	PWM4 (PWM)	</description>
            <name>PB11_PWM4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PC0_I2SLRCLK and GPC_MFP[0] determine the PC.0 function.
                        PC0_I2SLRCLK	GPC_MFP[0]	PC.0 function 	
                        x 	0 	GPIO 	
                        0 	1 	SPISS00(SPI0) 	
                        1 	1 	I2SLRCLK (I2S)	</description>
            <name>PC0_I2SLRCLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PC1_I2SBCLK and GPC_MFP[1] determine the PC.1 function.
                        PC1_I2SBCLK	GPC_MFP[1]	PC.1 function 	
                        x 	0 	GPIO 	
                        0 	1 	SPICLK0 (SPI0) 	
                        1 	1 	I2SBLK (I2S)	</description>
            <name>PC1_I2SBCLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PC2_I2SDI and GPC_MFP[2] determine the PC.2 function.
                        PC2_I2SDI	GPC_MFP[2]	PC.2 function 	
                        x 	0 	GPIO 	
                        0 	1 	MISO00 (SPI0) 	
                        1 	1 	I2SDI (I2S)	</description>
            <name>PC2_I2SDI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PC3_I2SDO and GPC_MFP[3] determine the PC.3 function.
                        PC3_I2SDO	GPC_MFP[3]	PC.3 function 	
                        x 	0 	GPIO 	
                        0 	1 	MOSI00 (SPI0) 	
                        1 	1 	I2SDO (I2S)	</description>
            <name>PC3_I2SDO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PA15_I2SMCLK and GPA_MFP[15] determine the PA.15 function.
                        PA15_I2SMCLK	GPA_MFP[15]	PA.15 function 	
                        x 	0 	GPIO 	
                        0 	1 	PWM3 (PWM) 	
                        1 	1 	I2SMCLK (I2S)	</description>
            <name>PA15_I2SMCLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits PB12_CLKO and GPB_MFP[12] determine the PB.12 function.
                        EBI_EN 	PB12_CLKO 	GPB_MFP[12]	PB.12 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	CPO0 (CMP)	
                        0 	1 	1 	CLKO (Clock Driver output)	
                        1 	1 	1 	AD0 (EBI AD bus bit 0)	</description>
            <name>PB12_CLKO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>EBI_EN is use to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), it need additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI function(AD[15:8], MCLK)</description>
            <name>EBI_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits EBI_MCLK_EN, EBI_EN and GPC_MFP[8] determine the PC.8 function.
                        EBI_MCLK_EN 	EBI_EN 	GPC_MFP[8]	PC.8 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	SPISS10 (SPI1) 	
                        0 	1 	1 	SPISS10 (SPI1) 	
                        1 	1 	1 	MCLK (EBI Clock output)	</description>
            <name>EBI_MCLK_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits EBI_nWRL_EN, EBI_EN and GPB_MFP[2] determine the PB.2 function.
                        EBI_nWRL_EN 	EBI_EN 	GPB_MFP[2]	PB.2 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	RTS0 (UART0)	
                        0 	1 	1 	RTS0 (UART0)	
                        1 	1 	1 	nWRL (EBI write low byte enable)	</description>
            <name>EBI_nWRL_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bits EBI_nWRH_EN, EBI_EN and GPB_MFP[3] determine the PB.3 function
                        EBI_nWRH_EN 	EBI_EN 	GPB_MFP[3]	PB.3 function 	
                        x 	x 	0 	GPIO 	
                        x 	0 	1 	CTS0 (UART0)	
                        0 	1 	1 	CTS0 (UART0)	
                        1 	1 	1 	nWRH (EBI write high byte enable)	</description>
            <name>EBI_nWRH_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>EBI_HB_EN is use to switch GPIO function to EBI address/data bus high byte (AD[15:8]), EBI_HB_EN, EBI_EN and corresponding GPx_MFP[y] determine the Px.y function.</description>
            <name>EBI_HB_EN</name>
          </field>
        </fields>
        <name>ALT_MFP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>Register Write Protect Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Register Write Protection Disable Index (Read only)
                        1 = Write-Protection is disabled for writing protected registers
                        0 = Write-Protection is enabled for writing protected registers. Any write to the protected register is ignored.
                        The Protected registers are:
                        IPRST1: address 0x5000_0008
                        BODCR: address 0x5000_0018
                        PORCR: address 0x5000_0024
                        PWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear)
                        APBCLK bit[0]: address 0x5000_0208 (bit[0] is watchdog timer clock enable)
                        CLK_SEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source select)
                        CLK_SEL1 bit[1:0]: address 0x5000_0214 (for watch dog clock source select)
                        ISPCON: address 0x5000_C000 (Flash ISP Control register)
                        WTCR: address 0x4000_4000
                        FATCON: address 0x5000_C018</description>
            <name>REGPROTDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Register Write-Protection Code (Write only)
                        Some write-protected registers have to be disabled the protected function by writing the sequence value "59h", "16h", "88h" to this field. After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protected registers can be normal write.</description>
            <name>REGWRPROT</name>
          </field>
        </fields>
        <name>REGWRPROT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004000</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPA</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD15</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>GPIOx Pin[n] OFF digital input path Enable
                        Each of these bits is used to control if the input path of corresponding GPIO pin is disabled. If input is analog signal, users can OFF digital input path to avoid creepage
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT15</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK15</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN15</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN15</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD15</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN15</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Interrupt Trigger Source Indicator</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC15</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004040</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPB</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD15</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>GPIOx Pin[n] OFF digital input path Enable
                        Each of these bits is used to control if the input path of corresponding GPIO pin is disabled. If input is analog signal, users can OFF digital input path to avoid creepage
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT15</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK15</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN15</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN15</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD15</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN15</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Interrupt Trigger Source Indicator</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC15</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004080</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD15</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>GPIOx Pin[n] OFF digital input path Enable
                        Each of these bits is used to control if the input path of corresponding GPIO pin is disabled. If input is analog signal, users can OFF digital input path to avoid creepage
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT15</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK15</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN15</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN15</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD15</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN15</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Interrupt Trigger Source Indicator</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC15</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x500040C0</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPD</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD15</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>GPIOx Pin[n] OFF digital input path Enable
                        Each of these bits is used to control if the input path of corresponding GPIO pin is disabled. If input is analog signal, users can OFF digital input path to avoid creepage
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT15</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK15</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN15</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN15</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD15</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN15</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Interrupt Trigger Source Indicator</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC15</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x24</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004100</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO</groupName>
    <interrupts></interrupts>
    <name>GPE</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>GPIOX I/O Pin[n] Mode Control 
                        Determine each I/O type of GPIOx pins
                        00 = GPIO port [n] pin is in INPUT mode.
                        01 = GPIO port [n] pin is in OUTPUT mode.
                        10 = GPIO port [n] pin is in Open-Drain mode.
                        11 = GPIO port [n] pin is in Quasi-bidirectional mode.</description>
            <name>PMD15</name>
          </field>
        </fields>
        <name>PMD</name>
        <resetMask>0x0</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin OFF Digital Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>GPIOx Pin[n] OFF digital input path Enable
                        Each of these bits is used to control if the input path of corresponding GPIO pin is disabled. If input is analog signal, users can OFF digital input path to avoid creepage
                        1 = Disable IO digital input path (digital input tied to low)
                        0 = Enable IO digital input path</description>
            <name>OFFD</name>
          </field>
        </fields>
        <name>OFFD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Data Output Value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOx Pin[n] Output Value
                        Each of these bits control the status of a GPIO pin when the GPIO pin is configures as output, open-drain and quasi-mode.
                        1 = GPIO port [A/B/C/D/E] Pin[n] will drive High if the GPIO pin is configures as output, open-drain and quasi-mode.
                        0 = GPIO port [A/B/C/D/E] Pin[n] will drive Low if the GPIO pin is configures as output, open-drain and quasi-mode.</description>
            <name>DOUT15</name>
          </field>
        </fields>
        <name>DOUT</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Data Output Write Mask</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Data Output Write Mask
                        These bits are used to protect the corresponding register of GPIOx_DOUT bit[n]. When set the DMASK bit[n] to"1", the corresponding GPIOx_DOUTn bit is protected. The write signal is masked, write data to the protect bit is ignored
                        1 = The corresponding GPIOx_DOUT[n] bit is protected
                        0 = The corresponding GPIOx_DOUT[n] bit can be updated</description>
            <name>DMASK15</name>
          </field>
        </fields>
        <name>DMASK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin Value</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Pin Values
                        Each bit of the register reflects the actual status of the respective GPIO pin If bit is 1, it indicates the corresponding pin status is high, else the pin status is low</description>
            <name>PIN15</name>
          </field>
        </fields>
        <name>PIN</name>
        <resetMask>0xFFFF0000</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port De-bounce Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Input Signal De-bounce Enable
                        DBEN[n]used to enable the de-bounce function for each corresponding bit. If the input signal pulse width can't be sampled by continuous two de-bounce sample cycle The input signal transition is seen as the signal bounce and will not trigger the interrupt. The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle is controlled by DBNCECON[3:0]
                        The DBEN[n] is used for "edge-trigger" interrupt only, and ignored for "level trigger" interrupt
                        1 = The bit[n] de-bounce function is enabled
                        0 = The bit[n] de-bounce function is disabled
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>DBEN15</name>
          </field>
        </fields>
        <name>DBEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Interrupt Mode Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Edge or Level Detection Interrupt Control
                        IMD[n] is used to control the interrupt is by level trigger or by edge trigger. If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce. If the interrupt is by level trigger, the input source is sampled by one HCLK clock and generates the interrup.
                        1 = Level trigger interrupt
                        0 = Edge trigger interrupt
                        If set pin as the level trigger interrupt, then only one level can be set on the registers GPIOx_IEN. If set both the level to trigger interrupt, the setting is ignored and no interrupt will occur
                        The de-bounce function is valid for edge triggered interrupt. If the interrupt mode is level triggered, the de-bounce enable bit is ignored.</description>
            <name>IMD15</name>
          </field>
        </fields>
        <name>IMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Interrupt Enable</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Falling Edge or Input Level Low
                        IF_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IF_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate the interrupt.
                        1 = Enable the PIN[n] state low-level or high-to-low change interrupt 
                        0 = Disable the PIN[n] state low-level or high-to-low change interrupt</description>
            <name>IF_EN15</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Enable by Input Rising Edge or Input Level High
                        IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n]. Set bit to 1 also enable the pin wakeup function
                        When set the IR_EN[n] bit to 1:
                        If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the interrupt.
                        If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate the interrupt.
                        1 = Enable the PIN[n] level-high or low-to-high interrupt 
                        0 = Disable the PIN[n] level-high or low-to-high interrupt.</description>
            <name>IR_EN15</name>
          </field>
        </fields>
        <name>IEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Interrupt Trigger Source Indicator</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC11</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Port [A/B/C/D/E] Interrupt Trigger Source Indicator
                        Read :
                        1 = Indicates GPIOx[n] generate an interrupt
                        0 = No interrupt at GPIOx[n]
                        Write :
                        1= Clear the correspond pending interrupt
                        0= No action</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>ISRC15</name>
          </field>
        </fields>
        <name>ISRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x4</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004180</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_GCR</groupName>
    <interrupts></interrupts>
    <name>GPIO</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>External Interrupt De-bounce Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>De-bounce sampling cycle selection
                        DBCLKSEL	Description	
                        0	Sample interrupt input once per 1 clocks	
                        1	Sample interrupt input once per 2 clocks	
                        2	Sample interrupt input once per 4 clocks	
                        3	Sample interrupt input once per 8 clocks	
                        4	Sample interrupt input once per 16 clocks	
                        5	Sample interrupt input once per 32 clocks	
                        6	Sample interrupt input once per 64 clocks	
                        7	Sample interrupt input once per 128 clocks	
                        8	Sample interrupt input once per 256 clocks	
                        9	Sample interrupt input once per 2*256 clocks	
                        10	Sample interrupt input once per 4*256clocks	
                        11	Sample interrupt input once per 8*256 clocks	
                        12	Sample interrupt input once per 16*256 clocks	
                        13	Sample interrupt input once per 32*256 clocks	
                        14	Sample interrupt input once per 64*256 clocks	
                        15	Sample interrupt input once per 128*256 clocks	</description>
            <name>DBCLKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>De-bounce counter clock source select
                        1 = De-bounce counter clock source is the internal 10 KHz clock
                        0 = De-bounce counter clock source is the HCLK</description>
            <name>DBCLKSRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt clock On mode
                        Set this bit to 0 will disable the interrupt generate circuit clock, if the pin[n] interrupt is disabled
                        1 = Interrupt generated circuit clock always enable
                        0 = Disable the clock if the GPIOA/B/C/D/E[n] interrupt is disabled</description>
            <name>ICLK_ON</name>
          </field>
        </fields>
        <name>DBNCECON</name>
        <resetMask>0xFFFFFFDF</resetMask>
        <resetValue>0x20</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x40</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004200</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GPA_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x40</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004240</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GPB_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x40</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004280</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GPC_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x40</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x500042C0</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GPD_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x40</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004300</baseAddress>
    <description>Registers group</description>
    <groupName>GPIO_BITS</groupName>
    <interrupts></interrupts>
    <name>GPE_BITS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>GPIO Port Pin I/O Bit Output Control</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIOxx I/O Pin Bit Output Control
                        Set this bit can control one GPIO pin output value
                        1 = Set corresponding GPIO bit to high
                        0 = Set corresponding GPIO bit to low
                        For example: write GPIOx0_DOUT will reflect the written value to bit GPIOx_DOUT[0], read GPIOx0_DOUT will return the valur of GPIOx_PIN[0].</description>
            <name>DOUT</name>
          </field>
        </fields>
        <name>DOUT15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40020000</baseAddress>
    <description>Registers group</description>
    <groupName>I2C</groupName>
    <interrupts></interrupts>
    <name>I2C0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I2C Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert Acknowledge Control Bit
                        When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.</description>
            <name>AA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C Interrupt Flag
                        When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>SI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C STOP Control Bit
                        In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
            <name>STO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C START Control Bit
                        Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
            <name>STA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C Controller Enable Bit
                        1 = Enable
                        0 = Disable
                        Set to enable I2C serial function block. When ENSI=1 the I2C serial function enables. The multi-function pin function of SDA and SCL must set to I2C function first.</description>
            <name>ENSI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Interrupt
                        1 = Enable I2C interrupt
                        0 = Disable I2C interrupt</description>
            <name>EI</name>
          </field>
        </fields>
        <name>I2CON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>I2C Slave Address Register0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I2C Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Data Register
                        Bit[7:0] is located with the 8-bit transferred data of I2C serial port. </description>
            <name>I2CDAT</name>
          </field>
        </fields>
        <name>I2CDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>I2C Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Status Register 
                        The status register of I2C:
                        The three least significant bits are always 0. The five most significant bits contain the status code. There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is requested. All other I2CSTATUS values correspond to defined I2C states. When each of these states is entered, a status interrupt is requested (SI = 1). A valid status code is present in I2CSTATUS one machine cycle after SI is set by hardware and is still present one machine cycle after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
            <name>I2CSTATUS</name>
          </field>
        </fields>
        <name>I2CSTATUS</name>
        <resetMask>0xFFFFFF07</resetMask>
        <resetValue>0xF8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>I2C Clock Divided Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Clock Divided Register
                        The I2C clock rate bits: Data Baud Rate of I2C = system clock /(4x(I2CLK+1)).</description>
            <name>I2CLK</name>
          </field>
        </fields>
        <name>I2CLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>I2C Time-Out Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Flag
                        1 = Time-Out falg is set by H/W. It can interrupt CPU.
                        0 = S/W can clear the flag.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out counter input clock is divided by 4
                        1 = Enable
                        0 = Disable
                        When Enable, The time-Out period is extend 4 times.</description>
            <name>DIV4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-out counter is enabled/disable
                        1 = Enable
                        0 = Disable
                        When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.</description>
            <name>ENTI</name>
          </field>
        </fields>
        <name>I2CTOC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>I2C Slave address Register1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>I2C Slave address Register2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I2C Slave address Register3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I2C Slave Address Mask Register0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I2C Slave Address Mask Register1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>I2C Slave Address Mask Register2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I2C Slave Address Mask Register3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40120000</baseAddress>
    <description>Registers group</description>
    <groupName>I2C</groupName>
    <interrupts></interrupts>
    <name>I2C1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I2C Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Assert Acknowledge Control Bit
                        When AA=1 prior to address or data received, an acknowledged (low level to SDA) will be returned during the acknowledge clock pulse on the SCL line when 1.) A slave is acknowledging the address sent from master, 2.) The receiver devices are acknowledging the data sent by transmitter. When AA=0 prior to address or data received, a Not acknowledged (high level to SDA) will be returned during the acknowledge clock pulse on the SCL line.</description>
            <name>AA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C Interrupt Flag
                        When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and if bit EI (I2CON [7]) is set, the I2C interrupt is requested. SI must be cleared by software. Clear SI is by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>SI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C STOP Control Bit
                        In master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the bus condition if a STOP condition is detected this bit will be cleared by hardware automatically. In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode. This means it is NO LONGER in the slave receiver mode to receive data from the master transmit device.</description>
            <name>STO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C START Control Bit
                        Setting STA to logic 1 to enter master mode, the I2C hardware sends a START or repeat START condition to bus when the bus is free.</description>
            <name>STA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C Controller Enable Bit
                        1 = Enable
                        0 = Disable
                        Set to enable I2C serial function block. When ENSI=1 the I2C serial function enables. The multi-function pin function of SDA and SCL must set to I2C function first.</description>
            <name>ENSI</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Interrupt
                        1 = Enable I2C interrupt
                        0 = Disable I2C interrupt</description>
            <name>EI</name>
          </field>
        </fields>
        <name>I2CON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>I2C Slave Address Register0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I2C Data Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Data Register
                        Bit[7:0] is located with the 8-bit transferred data of I2C serial port. </description>
            <name>I2CDAT</name>
          </field>
        </fields>
        <name>I2CDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>I2C Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Status Register 
                        The status register of I2C:
                        The three least significant bits are always 0. The five most significant bits contain the status code. There are 26 possible status codes. When I2STATUS contains F8H, no serial interrupt is requested. All other I2CSTATUS values correspond to defined I2C states. When each of these states is entered, a status interrupt is requested (SI = 1). A valid status code is present in I2CSTATUS one machine cycle after SI is set by hardware and is still present one machine cycle after SI has been reset by software. In addition, states 00H stands for a Bus Error. A Bus Error occurs when a START or STOP condition is present at an illegal position in the formation frame. Example of illegal position are during the serial transfer of an address byte, a data byte or an acknowledge bit.</description>
            <name>I2CSTATUS</name>
          </field>
        </fields>
        <name>I2CSTATUS</name>
        <resetMask>0xFFFFFF07</resetMask>
        <resetValue>0xF8</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>I2C Clock Divided Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C Clock Divided Register
                        The I2C clock rate bits: Data Baud Rate of I2C = system clock /(4x(I2CLK+1)).</description>
            <name>I2CLK</name>
          </field>
        </fields>
        <name>I2CLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>I2C Time-Out Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Flag
                        1 = Time-Out falg is set by H/W. It can interrupt CPU.
                        0 = S/W can clear the flag.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out counter input clock is divided by 4
                        1 = Enable
                        0 = Disable
                        When Enable, The time-Out period is extend 4 times.</description>
            <name>DIV4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-out counter is enabled/disable
                        1 = Enable
                        0 = Disable
                        When Enable, the 14 bit time-out counter will start counting when SI is clear. Setting flag SI to high will reset counter and re-start up counting after SI is cleared.</description>
            <name>ENTI</name>
          </field>
        </fields>
        <name>I2CTOC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>I2C Slave address Register1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>I2C Slave address Register2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I2C Slave address Register3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>General Call Function
                        0 = Disable General Call Function.
                        1 = Enable General Call Function.</description>
            <name>GC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address register
                        The content of this register is irrelevant when I2C is in master mode. In the slave mode, the seven most significant bits must be loaded with the MCU's own address. The I2C hardware will react if either of the address is matched.</description>
            <name>I2CADDR</name>
          </field>
        </fields>
        <name>I2CADDR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I2C Slave Address Mask Register0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I2C Slave Address Mask Register1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>I2C Slave Address Mask Register2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>I2C Slave Address Mask Register3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>I2C Address Mask register
                        1 = Mask enable (the received corresponding address bit is don't care.)
                        0 = Mask disable (the received corresponding register bit should be exact the same as address register.) 
                        I2C bus controllers support multiple address recognition with four address mask reg. When the bit in the address mask register is set to one, it means the received corresponding address bit is don't-care. If the bit is set to zero, that means the received corresponding register bit should be exact the same as address register.</description>
            <name>I2CADM</name>
          </field>
        </fields>
        <name>I2CADM3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x18</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x401A0000</baseAddress>
    <description>Registers group</description>
    <groupName>I2S</groupName>
    <interrupts></interrupts>
    <name>I2S</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I2S Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable I2S Controller
                        1 = Enable
                        0 = Disable</description>
            <name>I2SEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Enable
                        1 = Enable data transmit
                        0 = Disable data transmit</description>
            <name>TXEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Enable
                        1 = Enable data receive
                        0 = Disable data receive</description>
            <name>RXEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Mute Enable
                        1 = Transmit channel zero
                        0 = Transmit data is shifted from buffer</description>
            <name>MUTE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Width
                        00 = data is 8 bit
                        01 = data is 16 bit
                        10 = data is 24 bit
                        11 = data is 32 bit</description>
            <name>WORDWIDTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monaural Data
                        1 = Data is monaural format
                        0 = Data is stereo format</description>
            <name>MONO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Format
                        1 = MSB justified data format
                        0 = I2S data format</description>
            <name>FORMAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Mode
                        I2S can operate as master or slave. For master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from NuMicro(TM) NUC100 series to Audio CODEC chip. In slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are received from outer Audio CODEC chip.
                        1 = Slave mode
                        0 = Master mode</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Transmit FIFO Threshold Level
                        If remain data word (32 bits) in transmit FIFO is the same or less than threshold level then TXTHI flag is set.
                        000 = 0 word data in transmit FIFO
                        001 = 1 word data in transmit FIFO
                        010 = 2 words data in transmit FIFO
                        011 = 3 words data in transmit FIFO
                        100 = 4 word data in transmit FIFO
                        101 = 5 word data in transmit FIFO
                        110 = 6 word data in transmit FIFO
                        111 = 7 word data in transmit FIFO</description>
            <name>TXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Receive FIFO Threshold Level
                        When received data word(s) in buffer is equal or higher than threshold level then RXTHI flag is set.
                        000 = 1 word data in receive FIFO
                        001 = 2 word data in receive FIFO
                        010 = 3 word data in receive FIFO
                        011 = 4 word data in receive FIFO
                        100 = 5 word data in receive FIFO
                        101 = 6 word data in receive FIFO
                        110 = 7 word data in receive FIFO
                        111 = 8 word data in receive FIFO</description>
            <name>RXTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Clock Enable
                        If NuMicro(TM) NUC100 series external crystal clock is frequency 2*N*256fs then software can program MCLK_DIV[2:0] in I2S_CLKDIV register to get 256fs clock to audio codec chip.
                        1 = Enable master clock
                        0 = Disable master clock</description>
            <name>MCLKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Right channel zero cross detect enable
                        If this bit is set to 1, when left channel data sign bit change or next shift data bits are all zero then RZCF flag in I2S_STATUS register is set to 1.
                        1 = Enable right channel zero cross detect
                        0 = Disable right channel zero cross detect</description>
            <name>RCHZCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Left channel zero cross detect enable
                        If this bit is set to 1, when left channel data sign bit change or next shift data bits are all zero then LZCF flag in I2S_STATUS register is set to 1.
                        1 = Enable left channel zero cross detect
                        0 = Disable left channel zero cross detect</description>
            <name>LCHZCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Transmit FIFO
                        Write 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TXFIFO_LEVEL[3:0] returns to zero and transmit FIFO becomes empty but data in transmit FIFO is not changed.
                        This bit is clear by hardware automatically, read it return zero.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CLR_TXFIFO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Receive FIFO
                        Write 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RXFIFO_LEVEL[3:0] returns to zero and receive FIFO becomes empty.
                        This bit is clear by hardware automatically, read it return zero.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CLR_RXFIFO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Transmit DMA
                        When TX DMA is enabled, I2S requests DMA to transfer data from SRAM to transmit FIFO if FIFO is not full.
                        1 = Enable TX DMA
                        0 = Disable TX DMA</description>
            <name>TXDMA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Receive DMA
                        When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is not empty.
                        1 = Enable RX DMA
                        0 = Disable RX DMA</description>
            <name>RXDMA</name>
          </field>
        </fields>
        <name>I2S_CON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>I2S Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master Clock Divider
                        If chip external crystal frequency is (2xMCLK_DIV)*256fs then software can program these bits to generate 256fs clock frequency to audio codec chip. If MCLK_DIV is set to 0, MCLK is the same as external clock input.
                        For example, sampling rate is 24 kHz and chip external crystal clock is 12.288 MHz, set MCLK_DIV=1.
                        F_MCLK = F_I2SCLK/(2x(MCLK_DIV)) (When MCLK_DIV is &gt;= 1 )
                        F_MCLK = F_I2SCLK (When MCLK_DIV is set to 0 )</description>
            <name>MCLK_DIV</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Bit Clock Divider
                        If I2S operates in master mode, bit clock is provided by NuMicro(TM) NUC100 series. Software can program these bits to generate sampling rate clock frequency.
                        F_BCLK = F_I2SCLK /(2x(BCLK_DIV + 1))</description>
            <name>BCLK_DIV</name>
          </field>
        </fields>
        <name>I2S_CLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I2S Interrupt Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO underflow interrupt enable
                        If software read receive FIFO when it is empty then RXUDF flag in I2SSTATUS register is set to 1.
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>RXUDFIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO overflow interrupt enable
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>RXOVFIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO threshold level interrupt
                        When data word in receive FIFO is equal or higher then RXTH[2:0] and the RXTHI bit is set to 1. If RXTHIE bit is enabled, interrupt occur.
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>RXTHIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO underflow interrupt enable
                        Interrupt occurs if this bit is set to 1 and transmit FIFO underflow flag is set to 1.
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>TXUDFIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO overflow interrupt enable
                        Interrupt occurs if this bit is set to 1 and transmit FIFO overflow flag is set to 1.
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>TXOVFIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO threshold level interrupt enable
                        Interrupt occurs if this bit is set to 1 and data words in transmit FIFO is less than TXTH[2:0].
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>TXTHIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Right channel zero cross interrupt enable
                        Interrupt occurs if this bit is set to 1 and right channel zero cross.
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>RZCIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Left channel zero cross interrupt enable
                        Interrupt occurs if this bit is set to 1 and left channel zero cross.
                        1 = Enable interrupt
                        0 = Disable interrupt</description>
            <name>LZCIE</name>
          </field>
        </fields>
        <name>I2S_IE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>I2S Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2S Interrupt flag
                        1 = I2S interrupt
                        0 = No I2S interrup
                        It is wire-OR of I2STXINT and I2SRXINT bits.
                        This bit is read only.</description>
            <name>I2SINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2S receive interrupt
                        1 = Receive interrupt
                        0 = No receive interrupt
                        This bit is read only</description>
            <name>I2SRXINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2S transmit interrupt
                        1 = Transmit interrupt
                        0 = No transmit interrupt
                        This bit is read only</description>
            <name>I2STXINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Right channel
                        This bit indicate current transmit data is belong to right channel.
                        1 = Right channel
                        0 = Left channel
                        This bit is read only.</description>
            <name>RIGHT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO underflow flag
                        Read receive FIFO when it is empty, this bit set to 1 indicate underflow occur.
                        1 = Underflow occur
                        0 = No underflow occur
                        Write 1 to clear this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RXUDF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO overflow flag
                        When receive FIFO is full and receive hardware attempt write to data into receive FIFO then this bit is set to 1, data in 1st buffer is overwrote.
                        1 = Overflow occur
                        0 = No overflow occur
                        Write 1 to clear this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RXOVF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO threshold flag
                        When data word(s) in receive FIFO is equal or higher than threshold value set in RXTH[2:0] the RXTHF bit becomes to 1. It keeps at 1 till RXFIFO_LEVEL[3:0] less than RXTH[1:0] after software read RXFIFO register.
                        1 = Data word(s) in FIFO is equal or higher than threshold level
                        0 = Data word(s) in FIFO is lower than threshold level
                        This bit is read only.</description>
            <name>RXTHF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO full
                        This bit reflect data words number in receive FIFO is 8.
                        1 = Full
                        0 = Not full
                        This bit is read only.</description>
            <name>RXFULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive FIFO empty
                        This bit reflects data words number in receive FIFO is zero.
                        1 = Empty
                        0 = Not empty
                        This bit is read only.</description>
            <name>RXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO underflow flag
                        When transmit FIFO is empty and shift logic hardware read data from data FIFO causes this set to 1.
                        1 = Underflow
                        0 = No underflow
                        Software can write 1 to clear this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TXUDF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO overflow flag
                        Write data to transmit FIFO when it is full and this bit set to 1.
                        1 = Overflow
                        0 = No overflow
                        Software can write 1 to clear this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TXOVF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO threshold flag
                        When data word(s) in transmit FIFO is equal or lower than threshold value set in TXTH[2:0] the TXTHF bit becomes to 1. It keeps at 1 till TXFIFO_LEVEL[3:0] is higher than TXTH[1:0] after software write TXFIFO register.
                        1 = Data word(s) in FIFO is equal or lower than threshold level
                        0 = Data word(s) in FIFO is higher than threshold level 
                        This bit is read only.</description>
            <name>TXTHF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO full
                        This bit reflect data word number in transmit FIFO is 8.
                        1 = Full
                        0 = Not full
                        This bit is read only.</description>
            <name>TXFULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit FIFO empty
                        This bit reflect data word number in transmit FIFO is zero.
                        1 = Empty
                        0 = Not empty
                        This bit is read only.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Busy
                        This bit is clear to 0 when all data in transmit FIFO and shift buffer is shifted out. And set to 1 when 1st data is load to shift buffer.
                        1 = Transmit shift buffer is busy
                        0 = Transmit shift buffer is empty
                        This bit is read only.</description>
            <name>TXBUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Right channel zero cross flag
                        It indicates right channel next sample data sign bit is changed or all data bits are zero.
                        1 = Right channel zero cross is detected
                        0 = No zero cross
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RZCF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Left channel zero cross flag
                        It indicates left channel next sample data sign bit is changed or all data bits are zero.
                        1 = Left channel zero cross is detected
                        0 = No zero cross
                        Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>LZCF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Receive FIFO level
                        These bits indicate word number in receive FIFO.
                        0000 = No data
                        0001 = 1 word in receive FIFO
                        0010 = 2 word in receive FIFO
                        0011 = 3 word in receive FIFO
                        0100 = 4 word in receive FIFO
                        0101 = 5 word in receive FIFO
                        0110 = 6 word in receive FIFO
                        0111 = 7 word in receive FIFO
                        1000 = 8 word in receive FIFO</description>
            <name>RX_LEVEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Transmit FIFO level
                        These bits indicate word number in Transmit FIFO.
                        0000 = No data
                        0001 = 1 word in Transmit FIFO
                        0010 = 2 word in Transmit FIFO
                        0011 = 3 word in Transmit FIFO
                        0100 = 4 word in Transmit FIFO
                        0101 = 5 word in Transmit FIFO
                        0110 = 6 word in Transmit FIFO
                        0111 = 7 word in Transmit FIFO
                        1000 = 8 word in Transmit FIFO</description>
            <name>TX_LEVEL</name>
          </field>
        </fields>
        <name>I2S_STATUS</name>
        <resetMask>0xFFEBEFFF</resetMask>
        <resetValue>0x141000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>I2S Transmit FIFO Register</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Transmit FIFO register
                        I2S contains 8 words (8x32 bit) data buffer for data transmit. Write data to this register to prepare data for transmit. The remain word number is indicated by TX_LEVEL[3:0] in I2S_STATUS.</description>
            <name>TXFIFO</name>
          </field>
        </fields>
        <name>I2S_TXFIFO</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>I2S Receive FIFO Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Receive FIFO register
                        I2S contains 8 words (8x32 bit) data buffer for data receive. Read this register to get data in FIFO. The remaining data word number is indicated by RX_LEVEL[3:0] in I2S_STATUS register.</description>
            <name>RXFIFO</name>
          </field>
        </fields>
        <name>I2S_RXFIFO</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x88</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000300</baseAddress>
    <description>Registers group</description>
    <groupName>INT</groupName>
    <interrupts></interrupts>
    <name>INT</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>MCU IRQ0 (BOD) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: BOD_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ0_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>MCU IRQ1 (WDG) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: WDG_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ1_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>MCU IRQ2 (EINT0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: EINT0 - external interrupt 0 from PB.14</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ2_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>MCU IRQ3 (EINT1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: EINT1 - external interrupt 1 from PB.15</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ3_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>MCU IRQ4 (GPA/B) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: GPB_INT
                        Bit0: GPA_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ4_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>MCU IRQ5 (GPC/D/E) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: GPE_INT
                        Bit1: GPD_INT
                        Bit0: GPC_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ5_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>MCU IRQ6 (PWMA) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit3: PWM3_INT
                        Bit2: PWM2_INT
                        Bit1: PWM1_INT
                        Bit0: PWM0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ6_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>MCU IRQ7 (PWMB) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit3: PWM7_INT
                        Bit2: PWM6_INT
                        Bit1: PWM5_INT
                        Bit0: PWM4_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ7_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x20</addressOffset>
        <description>MCU IRQ8 (TMR0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: TMR0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ8_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>MCU IRQ9 (TMR1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: TMR1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ9_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>MCU IRQ10 (TMR2) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: TMR2_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ10_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>MCU IRQ11 (TMR3) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: TMR3_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ11_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x30</addressOffset>
        <description>MCU IRQ12 (URT0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: URT0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ12_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>MCU IRQ13 (URT1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: URT1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ13_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x38</addressOffset>
        <description>MCU IRQ14 (SPI0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: SPI0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ14_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3C</addressOffset>
        <description>MCU IRQ15 (SPI1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: SPI1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ15_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x40</addressOffset>
        <description>MCU IRQ16 (SPI2) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: SPI2_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ16_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x44</addressOffset>
        <description>MCU IRQ17 (SPI3) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: SPI3_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ17_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>MCU IRQ18 (I2C0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: I2C0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ18_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4C</addressOffset>
        <description>MCU IRQ19 (I2C1) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: I2C1_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ19_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x50</addressOffset>
        <description>MCU IRQ20 (CAN0) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: CAN0_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ20_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x54</addressOffset>
        <description>MCU IRQ21 (Reserved) interrupt source identity</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Reserved</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ21_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x58</addressOffset>
        <description>MCU IRQ22 (Reserved) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Reserved</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ22_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x5C</addressOffset>
        <description>MCU IRQ23 (USBD) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: USBD_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ23_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x60</addressOffset>
        <description>MCU IRQ24 (PS2) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: PS2_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ24_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x64</addressOffset>
        <description>MCU IRQ25 (ACMP) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0 
                        Bit0: ACMP_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ25_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x68</addressOffset>
        <description>MCU IRQ26 (PDMA) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: PDMA_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ26_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x6C</addressOffset>
        <description>MCU IRQ27 (Reserved) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: I2S_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ27_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x70</addressOffset>
        <description>MCU IRQ28 (PWRWU) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: PWRWU_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ28_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x74</addressOffset>
        <description>MCU IRQ29 (ADC) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: ADC_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ29_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x78</addressOffset>
        <description>MCU IRQ30 (Reserved) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Reserved</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ30_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x7C</addressOffset>
        <description>MCU IRQ31 (RTC) interrupt source identify</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Bit2: 0
                        Bit1: 0
                        Bit0: RTC_INT</description>
            <name>INT_SRC</name>
          </field>
        </fields>
        <name>IRQ31_SRC</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>NMI source interrupt select control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>The NMI interrupt to Cortex-M0 can be selected from one of the peripheral interrupt by setting NMI_SEL.</description>
            <name>NMI_SEL</name>
          </field>
        </fields>
        <name>NMI_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x84</addressOffset>
        <description>MCU IRQ Number identify register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>MCU IRQ Source Register 
                        The MCU_IRQ collect all the interrupts from the peripherals and generate the synchronous interrupt to MCU Cortex-M0. There are two modes to generate interrupt to MCU Cortex-M0, the normal mode and test mode.
                        The MCU_IRQ collect all interrupt from each peripheral and synchronize them then interrupt the Cortex-M0.
                        When the MCU_IRQ[n] is "0": Set MCU_IRQ[n] "1" will generate a interrupt to Cortex_M0 NVIC[n].
                        When the MCU_IRQ[n] is "1" (mean a interrupt is assert) set "1" to the MCU_bit[n] will clear the interrupt. 
                        Set MCU_IRQ[n] "0": no any effect</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>MCU_IRQ</name>
          </field>
        </fields>
        <name>MCU_IRQ</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008000</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008100</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008200</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008300</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008400</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA4</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008500</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA5</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008600</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA6</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008700</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA7</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x28</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008800</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA</groupName>
    <interrupts></interrupts>
    <name>PDMA8</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Control and Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Channel Enable
                        Setting this bit to 1 enables PDMA's operation. If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
                        Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.</description>
            <name>PDMACEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Engine Reset
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the internal state machine and pointers. The contents of control register will not be cleared. This bit will auto clear after few clock cycles.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SW_RST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>PDMA Mode Select
                        00 = Memory to Memory mode (Memory-to-Memory).
                        01 = IP to Memory mode (APB-to-Memory).
                        10 = Memory to IP mode (Memory-to-APB).</description>
            <name>MODE_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Source Address Direction Select
                        00 = Transfer Source address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Source address is fixed (This feature can be used when data where transferred from a single source to multiple destinations).
                        11 = Reserved.</description>
            <name>SAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Transfer Destination Address Direction Select
                        00 = Transfer Destination address is incremented successively.
                        01 = Reserved.
                        10 = Transfer Destination address is fixed (This feature can be used when data where transferred from multiple sources to a single destination).
                        11 = Reserved.</description>
            <name>DAD_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Peripheral transfer Width Select
                        00 = One word (32 bits) is transferred for every PDMA operation.
                        01 = One byte (8 bits) is transferred for every PDMA operation.
                        10 = One half-word (16 bits) is transferred for every PDMA operation.
                        11 = Reserved.
                        Note: This field is meaningful only when MODE_SEL is IP to Memory mode (APB-to-Memory) or Memory to IP mode (Memory-to-APB).</description>
            <name>APB_TWS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trig_EN
                        0 = No effect.
                        1 = Enable PDMA data read or write transfer.
                        Note: When PDMA transfer completed, this bit will be cleared automatically.
                        If the bus error occurs, all PDMA transfer will be stopped. Software must reset all PDMA channel, and then trigger again.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>TRIG_EN</name>
          </field>
        </fields>
        <name>PDMA_CSRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Transfer Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Source Address Register
                        This field indicates a 32-bit source address of PDMA.
                        Note : The source address must be word alignment</description>
            <name>PDMA_SAR</name>
          </field>
        </fields>
        <name>PDMA_SARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Transfer Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Transfer Destination Address Register
                        This field indicates a 32-bit destination address of PDMA.
                        Note : The destination address must be word alignment</description>
            <name>PDMA_DAR</name>
          </field>
        </fields>
        <name>PDMA_DARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Transfer Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Transfer Byte Count Register
                        This field indicates a 16-bit transfer byte count of PDMA.it must be word alignment.</description>
            <name>PDMA_BCR</name>
          </field>
        </fields>
        <name>PDMA_BCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Internal Buffer Pointer Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA Internal Buffer Pointer Register (Read Only)
                        This field indicates the internal buffer pointer.</description>
            <name>PDMA_POINT</name>
          </field>
        </fields>
        <name>PDMA_POINTx</name>
        <resetMask>0xFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>PDMA Current Source Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Source Address Register (Read Only)
                        This field indicates the source address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CSAR</name>
          </field>
        </fields>
        <name>PDMA_CSARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>PDMA Current Destination Address Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Current Destination Address Register (Read Only)
                        This field indicates the destination address where the PDMA transfer is just occurring.</description>
            <name>PDMA_CDAR</name>
          </field>
        </fields>
        <name>PDMA_CDARx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x1C</addressOffset>
        <description>PDMA Current Byte Count Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>PDMA Current Byte Count Register (Read Only)
                        This field indicates the current remained byte count of PDMA.
                        Note : SW_RST will clear this register value.</description>
            <name>PDMA_CBCR</name>
          </field>
        </fields>
        <name>PDMA_CBCRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>PDMA Interrupt Enable Control Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Enable
                        0 = Disable target abort interrupt generation during PDMA transfer.
                        1 = Enable target abort interrupt generation during PDMA transfer.</description>
            <name>TABORT_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Transfer Done Interrupt Enable
                        0 = Disable interrupt generator during PDMA transfer done.
                        1 = Enable interrupt generator during PDMA transfer done.</description>
            <name>BLKD_IE</name>
          </field>
        </fields>
        <name>PDMA_IERx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>PDMA Interrupt Status Register CHx</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Read/Write Target Abort Interrupt Flag
                        0 = No bus ERROR response received.
                        1 = Bus ERROR response received. 
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TABORT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Block Transfer Done Interrupt Flag
                        This bit indicates that PDMA has finished all transfer.
                        0 = Not finished yet.
                        1 = Done.
                        NOTE: Software can write 1 to clear this bit to zero.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BLKD_IF</name>
          </field>
        </fields>
        <name>PDMA_ISRx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>PDMA Shared Buffer FIFO 0 Register CHx</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>PDMA Shared Buffer FIFO 0 (Read Only)
                        Each channel has its own 1 word internal buffer. </description>
            <name>PDMA_SBUF0</name>
          </field>
        </fields>
        <name>PDMA_SBUF0_cx</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x14</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50008F00</baseAddress>
    <description>Registers group</description>
    <groupName>PDMA_GCR</groupName>
    <interrupts></interrupts>
    <name>PDMA_GCR</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PDMA Global Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 0 Clock Enable Control
                        0 = Disable
                        1 = Enable</description>
            <name>CLK0_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 1 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 2 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 3 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK3_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 4 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK4_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 5 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK5_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 6 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK6_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 7 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK7_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PDMA Controller Channel 8 Clock Enable Control(Medium Density Only)
                        0 = Disable
                        1 = Enable</description>
            <name>CLK8_EN</name>
          </field>
        </fields>
        <name>PDMA_GCRCSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PDMA Service Selection Control Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI0 RX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI0 RX. Software can change the channel RX setting by SPI0_RXSEL
                        4'b0000: CH0
                        4'b0001: CH1
                        4'b0010: CH2
                        4'b0011: CH3 
                        4'b0100: CH4 
                        4'b0101: CH5
                        4'b0110: CH6
                        4'b0111: CH7
                        4'b1000: CH8
                        Others : Reserved
                        Note : Ex : SPI0_RXSEL = 4'b0110, that means SPI0_RX is connected to PDMA_CH6(Low Density should set as 4'b0000 for PDMA channel 0 only)</description>
            <name>SPI0_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI0 TX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI0 TX. Software can configure the TX channel setting by SPI0_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI0_TXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI1 RX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI1 RX. Software can configure the RX channel setting by SPI1_RXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI1_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI1 TX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI1 TX. Software can configure the TX channel setting by SPI1_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI1_TXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI2 RX Selection (Medium Density Only)
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI2 RX. Software can configure the RX channel setting by SPI2_RXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI2_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI2 TX Selection (Medium Density Only)
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI2 TX. Software can configure the TX channel setting by SPI2_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI2_TXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI3 RX Selection (Medium Density Only)
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI3 RX. Software can configure the RX channel setting by SPI3_RXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI3_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA SPI3 TX Selection (Medium Density Only)
                        This filed defines which PDMA channel is connected to the on-chip peripheral SPI3 TX. Software can configure the TX channel setting by SPI3_TXSEL. The channel configuration is the same as SPI0_RXSEL field. Please refer to the explanation of SPI0_RXSEL.</description>
            <name>SPI3_TXSEL</name>
          </field>
        </fields>
        <name>PDSSR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PDMA Service Selection Control Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>This filed defines which PDMA channel is connected to the on-chip peripheral UART0 RX. Software can change the channel RX setting by UART0_RXSEL
                        4'b0000: CH0
                        4'b0001: CH1
                        4'b0010: CH2
                        4'b0011: CH3 
                        4'b0100: CH4 
                        4'b0101: CH5
                        4'b0110: CH6
                        4'b0111: CH7
                        4'b1000: CH8
                        Others : Reserved
                        Note : Ex : UART0_RXSEL = 4'b0110, that means UART0_RX is connected to PDMA_CH6(Low Density should set as 4'b0000 for PDMA channel 0 only)</description>
            <name>UART0_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA UART0 TX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral UART0 TX. Software can configure the TX channel setting by UART0_TXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
            <name>UART0_TXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA UART1 RX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral UART1 RX. Software can configure the RX channel setting by UART1_RXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
            <name>UART1_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA UART1 TX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral UART1 TX. Software can configure the TX channel setting by UART1_TXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
            <name>UART1_TXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA ADC RX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral ADC RX. Software can configure the RX channel setting by ADC_RXSEL. The channel configuration is the same as UART0_RXSEL field. Please refer to the explanation of UART0_RXSEL</description>
            <name>ADC_RXSEL</name>
          </field>
        </fields>
        <name>PDSSR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>PDMA Global Interrupt Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 0
                        This bit is the Interrupt pin status of PDMA channel0.
                        Note: This bit is read only</description>
            <name>INTR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 1 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel1.
                        Note: This bit is read only</description>
            <name>INTR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 2 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel2.
                        Note: This bit is read only</description>
            <name>INTR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 3 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel3.
                        Note: This bit is read only</description>
            <name>INTR3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 4 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel4.
                        Note: This bit is read only</description>
            <name>INTR4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 5 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel5.
                        Note: This bit is read only</description>
            <name>INTR5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 6 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel 6.
                        Note: This bit is read only</description>
            <name>INTR6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 7 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel 7.
                        Note: This bit is read only</description>
            <name>INTR7</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status of Channel 4 (Medium Density Only)
                        This bit is the Interrupt pin status of PDMA channel 8.
                        Note: This bit is read only</description>
            <name>INTR8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Pin Status
                        This bit is the Interrupt pin status of PDMA controller.
                        Note: This bit is read only</description>
            <name>INTR</name>
          </field>
        </fields>
        <name>PDMA_GCRISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>PDMA Service Selection Control Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA I2S RX Selection
                        
                        This filed defines which PDMA channel is connected to the on-chip peripheral I2S RX. Software can change the channel RX setting by I2S_RXSEL
                        4'b0000: CH0
                        4'b0001: CH1
                        4'b0010: CH2
                        4'b0011: CH3 
                        4'b0100: CH4 
                        4'b0101: CH5
                        4'b0110: CH6
                        4'b0111: CH7
                        4'b1000: CH8
                        Others : Reserved
                        Note : Ex : I2S_RXSEL = 4'b0110, that means I2S_RX is connected to PDMA_CH6(Low Density should set as 4'b0000 for PDMA channel 0 only)</description>
            <name>I2S_RXSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>PDMA I2S TX Selection
                        This filed defines which PDMA channel is connected to the on-chip peripheral I2S TX. Software can configure the TX channel setting by I2S_TXSEL. The channel configuration is the same as I2S_RXSEL field. Please refer to the explanation of I2S_RXSEL.</description>
            <name>I2S_TXSEL</name>
          </field>
        </fields>
        <name>PDSSR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x20</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40100000</baseAddress>
    <description>Registers group</description>
    <groupName>PS2D</groupName>
    <interrupts></interrupts>
    <name>PS2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>PS2 Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable PS2 Device
                        Enable PS2 device controller
                        1 = Enable
                        0 = Disable</description>
            <name>PS2EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Transmit Interrupt
                        1 = Enable data transmit complete interrupt
                        0 = Disable data transmit complete interrupt</description>
            <name>TXINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable Receive Interrupt
                        1 = Enable data receive complete interrupt
                        0 = Disable data receive complete interrupt</description>
            <name>RXINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Transmit Data FIFO Depth
                        There is 16 bytes buffer for data transmit. S/W can define the FIFO depth from 1 to 16 bytes depends on application. 
                        0 = 1 byte
                        1 = 2 bytes
                        ...
                        14 = 15 bytes
                        15 = 16 bytes</description>
            <name>TXFIFO_DEPTH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Acknowledge Enable
                        1 = If parity error or stop bit is not received correctly, acknowledge bit will not be sent to host at 12th clock
                        0 = Always send acknowledge to host at 12th clock for host to device communication.</description>
            <name>ACK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear TX FIFO 
                        Write 1 to this bit to terminate device to host transmission. The TXEMPTY bit in PS2STATUS bit will be set to 1 and pointer BYTEIDEX is reset to 0 regardless there is residue data in buffer or not. The buffer content is not been cleared.
                        1 = Clear FIFO 
                        0 = Not active</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CLRFIFO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Software Override PS2 CLK/DATA Pin State
                        1 = PS2CLK and PS2DATA pins are controlled by S/W
                        0 = PS2CLK and PS2DATA pins are controlled by internal state machine.</description>
            <name>OVERRIDE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Force PS2CLK Line
                        It forces PS2CLK line high or low regardless of the internal state of the device controller if OVERRIDE is set to high.
                        1 = Force PS2DATA line high
                        0 = Force PS2DATA line low</description>
            <name>FPS2CLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Force PS2DATA Line
                        It forces PS2DATA high or low regardless of the internal state of the device controller if OVERRIDE is set to high.
                        1 = Force PS2DATA high
                        0 = Force PS2DATA low</description>
            <name>FPS2DAT</name>
          </field>
        </fields>
        <name>PS2CON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>PS2 Transmit DATA Register 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Transmit data
                        Write data to this register starts device to host communication if bus is in IDLE state. S/W must enable PS2EN before writing data to TX buffer.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>PS2TXDATA0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>PS2 Transmit DATA Register 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Transmit data
                        Write data to this register starts device to host communication if bus is in IDLE state. S/W must enable PS2EN before writing data to TX buffer.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>PS2TXDATA1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>PS2 Transmit DATA Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Transmit data
                        Write data to this register starts device to host communication if bus is in IDLE state. S/W must enable PS2EN before writing data to TX buffer.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>PS2TXDATA2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>PS2 Transmit DATA Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Transmit data
                        Write data to this register starts device to host communication if bus is in IDLE state. S/W must enable PS2EN before writing data to TX buffer.</description>
            <name>TXDATA</name>
          </field>
        </fields>
        <name>PS2TXDATA3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>PS2 Receive DATA Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Received Data 
                        For host to device communication, after acknowledge bit is sent, the received data is copied from receive shift register to PS2RXDATA register. CPU must read this register before next byte reception complete, otherwise the data will be overwritten and RXOVF bit in PS2STATUS[6] will be set to 1.</description>
            <name>PS2RXDATA</name>
          </field>
        </fields>
        <name>PS2RXDATA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>PS2 Status Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CLK Pin State
                        This bit reflects the status of the PS2CLK line after synchronizing.</description>
            <name>PS2CLK</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>DATA Pin State
                        This bit reflects the status of the PS2DATA line after synchronizing and sampling.</description>
            <name>PS2DATA</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Frame Error
                        For host to device communication, if STOP bit (logic 1) is not received it is a frame error. If frame error occurs, DATA line may keep at low state after 12th clock. At this moment, S/w overrides PS2CLK to send clock till PS2DATA release to high state. After that, device sends a "Resend" command to host.
                        1 = Frame error occur
                        0 = No frame error
                        Write 1 to clear this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Parity
                        This bit reflects the parity bit for the last received data byte (odd parity).
                        Read only bit.</description>
            <name>RXPARITY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Busy
                        This bit indicates that the PS2 device is currently receiving data.
                        0 = Idle.
                        1 = Currently receiving data.
                        Read only bit.</description>
            <name>RXBUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Busy
                        This bit indicates that the PS2 device is currently sending data.
                        0 = Idle.
                        1 = Currently sending data.
                        Read only bit.</description>
            <name>TXBUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RX Buffer Overwrite
                        1 = Data in PS2RXDATA register is overwritten by new coming data.
                        0 = No overwrite
                        Write 1 to clear this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RXOVF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX FIFO Empty
                        When S/W writes any data to PS2TXDATA0-3 the TXEMPTY bit is cleared to 0 immediately if PS2EN is enabled. When transmitted data byte number is equal to FIFODEPTH then TXEMPTY bit is clear to 1.
                        1 = FIFO is empty
                        0 = There is data to be transmitted
                        Read only bit.</description>
            <name>TXEMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Byte Index 
                        It indicates which data byte in transmit data shift register. When all data in FIFO is transmitted and it will be cleared to 0.
                        It is a read only bit.
                        BYTEIDX	DATA Transmit	BYTEIDX	DATA Transmit	
                        0000	TXDATA0[7:0]	1000	TXDATA2[7:0]	
                        0001	TXDATA0[15:8]	1001	TXDATA2[15:8]	
                        0010	TXDATA0[23:16]	1010	TXDATA2[23:16]	
                        0011	TXDATA0[31:24]	1011	TXDATA2[31:24]	
                        0100	TXDATA1[7:0]	1100	TXDATA3[7:0]	
                        0101	TXDATA1[15:8]	1101	TXDATA3[15:8]	
                        0110	TXDATA1[23:16]	1110	TXDATA3[23:16]	
                        0111	TXDATA1[31:24]	1111	TXDATA3[31:24]	</description>
            <name>BYTEIDX</name>
          </field>
        </fields>
        <name>PS2STATUS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x83</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>PS2 Interrupt Identification Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Interrupt
                        This bit is set to 1 when acknowledge bit is sent for Host to device communication. Interrupt occurs if RXINTEN bit is set to 1.
                        1 = Receive interrupt occurs
                        0 = No interrupt
                        Write 1 to clear this bit to 0.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RXINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Interrupt 
                        This bit is set to 1 after STOP bit is transmitted. Interrupt occur if TXINTEN bit is set to 1.
                        1 = Transmit interrupt occurs
                        0 = No interrupt
                        Write 1 to clear this bit to 0.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TXINT</name>
          </field>
        </fields>
        <name>PS2INTID</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40008000</baseAddress>
    <description>Registers group</description>
    <groupName>RTC</groupName>
    <interrupts></interrupts>
    <name>RTC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>RTC Initiation Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC Active Status (Read only), 
                        0: RTC is at reset state
                        1: RTC is at normal active state.</description>
            <name>Active</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>RTC Initiation 
                        When chip is power on, RTC timer counter is at unknown state because RTC timer counter reset is individual with chip reset; user has to write a number (0x a5eb1357) to INIR to reset RTC controller to initialize RTC controller.</description>
            <name>INIR</name>
          </field>
        </fields>
        <name>INIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>RTC Access Enable Register</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>RTC Register Access Enable Password (Write only)
                        0xA965 = Enable RTC access 
                        Others = Disable RTC access </description>
            <name>AER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC Register Access Enable Flag (Read only)
                        1 = RTC register read/write enable
                        0 = RTC register read/write disable
                        This bit will be set after AER[15:0] register is load a 0xA965, and be clear automatically 512 RTC clock or AER[15:0] is not 0xA965.Register\AER.ENF	1	0	
                        INIR	R/W	R/W	
                        AER	R/W	R/W	
                        FCR	R/W	-	
                        TLR	R/W	R	
                        CLR	R/W	R	
                        TSSR	R/W	R/W	
                        DWR	R/W	R	
                        TAR	R/W	-	
                        CAR	R/W	-	
                        LIR	R	R	
                        RIER	R/W	R/W	
                        RIIR	R/C	R/C	
                        TTR	R/W	-	</description>
            <name>ENF</name>
          </field>
        </fields>
        <name>AER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>RTC Frequency Compensation Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Fraction Part
                        Formula = (fraction part of detected value) x 60
                        Note: Digit in FCR must be expressed as hexadecimal number. Refer to 5.8.4.4 for the examples.</description>
            <name>FRACTION</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Integer Part
                        Integer part of detected value	FCR[11:8]	Integer part of detected value	FCR[11:8]	
                        32776	1111	32768	0111	
                        32775	1110	32767	0110	
                        32774	1101	32766	0101	
                        32773	1100	32765	0100	
                        32772	1011	32764	0011	
                        32771	1010	32763	0010	
                        32770	1001	32762	0001	
                        32769	1000	32761	0000	</description>
            <name>INTEGER</name>
          </field>
        </fields>
        <name>FCR</name>
        <resetMask>0xFFFFF8FF</resetMask>
        <resetValue>0x700</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Time Loading Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1 Sec Time Digit (0~9)</description>
            <name>_1SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>10 Sec Time Digit (0~5)</description>
            <name>_10SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1 Min Time Digit (0~9)</description>
            <name>_1MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>10 Min Time Digit (0~5)</description>
            <name>_10MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1 Hour Time Digit (0~9)</description>
            <name>_1HR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>10 Hour Time Digit (0~2)</description>
            <name>_10HR</name>
          </field>
        </fields>
        <name>TLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Calendar Loading Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1-Day Calendar Digit (0~9)</description>
            <name>_1DAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>10-Day Calendar Digit (0~3)</description>
            <name>_10DAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1-Month Calendar Digit (0~9)</description>
            <name>_1MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>10-Month Calendar Digit (0~1)</description>
            <name>_10MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1-Year Calendar Digit (0~9)</description>
            <name>_1YEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>10-Year Calendar Digit (0~9)</description>
            <name>_10YEAR</name>
          </field>
        </fields>
        <name>CLR</name>
        <resetMask>0xFFFAFEFE</resetMask>
        <resetValue>0x50101</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Time Scale Selection Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>24-Hour / 12-Hour Time Scale Selection
                        It indicate that TLR and TAR are in 24-hour time mode or 12-hour time mode
                        1 = select 24-hour time scale
                        0 = select 12-hour time scale with AM and PM indication
                        24-hour time scale	12-hour time scale	24-hour time scale	12-hour time scale
                        (PM time + 20)	
                        00	12(AM12)	12	32(PM12)	
                        01	01(AM01)	13	21(PM01)	
                        02	02(AM02)	14	22(PM02)	
                        03	03(AM03)	15	23(PM03)	
                        04	04(AM04)	16	24(PM04)	
                        05	05(AM05)	17	25(PM05)	
                        06	06(AM06)	18	26(PM06)	
                        07	07(AM07)	19	27(PM07)	
                        08	08(AM08)	20	28(PM08)	
                        09	09(AM09)	21	29(PM09)	
                        10	10(AM10)	22	30(PM10)	
                        11	11(AM11)	23	31(PM11)	</description>
            <name>_24H_12H</name>
          </field>
        </fields>
        <name>TSSR</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Day of the Week Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Day of the Week Register 
                        Value	Day of the Week	
                        0	Sunday	
                        1	Monday	
                        2	Tuesday	
                        3	Wednesday	
                        4	Thursday	
                        5	Friday	
                        6	Saturday	</description>
            <name>DWR</name>
          </field>
        </fields>
        <name>DWR</name>
        <resetMask>0xFFFFFFF9</resetMask>
        <resetValue>0x6</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Time Alarm Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1 Sec Time Digit of Alarm Setting (0~9)</description>
            <name>_1SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>10 Sec Time Digit of Alarm Setting (0~5)</description>
            <name>_10SEC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1 Min Time Digit of Alarm Setting (0~9)</description>
            <name>_1MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>10 Min Time Digit of Alarm Setting (0~5)</description>
            <name>_10MIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1 Hour Time Digit of Alarm Setting (0~9)</description>
            <name>_1HR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>10 Hour Time Digit of Alarm Setting (0~2)</description>
            <name>_10HR</name>
          </field>
        </fields>
        <name>TAR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Calendar Alarm Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1-Day Calendar Digit of Alarm Setting (0~9)</description>
            <name>_1DAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>10-Day Calendar Digit of Alarm Setting (0~3)</description>
            <name>_10DAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1-Month Calendar Digit of Alarm Setting (0~9)</description>
            <name>_1MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>10-Month Calendar Digit of Alarm Setting (0~1)</description>
            <name>_10MON</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>1-Year Calendar Digit of Alarm Setting (0~9)</description>
            <name>_1YEAR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>10-Year Calendar Digit of Alarm Setting (0~9)</description>
            <name>_10YEAR</name>
          </field>
        </fields>
        <name>CAR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>RTC Leap year Indicator Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Leap Year Indication REGISTER (Real only).
                        1 = It indicate that this year is leap year
                        0 = It indicate that this year is not a leap year</description>
            <name>LIR</name>
          </field>
        </fields>
        <name>LIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>RTC Interrupt Enable Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Alarm Interrupt Enable
                        1 = RTC Alarm Interrupt is enabled
                        0 = RTC Alarm Interrupt is disabled</description>
            <name>AIER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Tick Interrupt Enable
                        1 = RTC Time Tick Interrupt is enabled
                        0 = RTC Time Tick Interrupt is disabled</description>
            <name>TIER</name>
          </field>
        </fields>
        <name>RIER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>RTC Interrupt Indicator Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC Alarm Interrupt Flag
                        When RTC Alarm Interrupt is enabled (RIER.AIER=1), RTC controller will set AIF to high once the RTC real time counters TLR and CLR reach the alarm setting time registers TAR and CAR. This bit is software clear by writing 1 to it.
                        1 = Indicates RTC Alarm Interrupt is requested if RIER.AIER=1.
                        0 = Indicates RTC Alarm Interrupt condition never occurred.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>AIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC Time Tick Interrupt Flag
                        When RTC Time Tick Interrupt is enabled (RIER.TIER=1), RTC controller will set TIF to high periodically in the period selected by TTR[2:0]. This bit is software clear by writing 1 to it.
                        1 = Indicates RTC Time Tick Interrupt is requested if RIER.TIER=1.
                        0 = Indicates RTC Time Tick Interrupt condition never occurred.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>RIIR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>RTC Time Tick Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Time Tick Register
                        The RTC time tick period for Periodic Time Tick Interrupt request.
                        TTR[2:0]	Time tick (second)	
                        0	1	
                        1	1/2	
                        2	1/4	
                        3	1/8	
                        4	1/16	
                        5	1/32	
                        6	1/64	
                        7	1/128	
                        
                        Note: This register can be read back after the RTC register access enable bit ENF(AER[16]) is active.</description>
            <name>TTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTC Timer Wakeup CPU Function Enable Bit
                        If TWKE is set before CPU is in power-down mode, when a RTC Time Tick occurs, CPU will be wakened up by RTC controller.
                        1 = Enable the Wakeup function that CPU can be waken up from power-down mode by Time Tick.
                        0 = Disable Wakeup CPU function by Time Tick.
                        Note: 
                        1. Tick timer setting follows TTR[2:0] description. 
                        2. The CPU can also be wakeup by alarm match occur.</description>
            <name>TWKE</name>
          </field>
        </fields>
        <name>TTR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x10</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0xE000E000</baseAddress>
    <description>Registers group</description>
    <groupName>SCS</groupName>
    <interrupts></interrupts>
    <name>SCS</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SysTick Control and Status</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 : the counter will operate in a multi-shot manner.
                        0 : the counter is disabled</description>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 : counting down to 0 will cause the SysTick exception to be pended. Clearing the SysTick Current Value register by a register write in software will not cause SysTick to be pended.
                        0 : counting down to 0 does not cause the SysTick exception to be pended. Software can use COUNTFLAG to determine if a count to zero has occurred.</description>
            <name>TICKINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 : core clock used for SysTick.
                        0 : clock source is (optional) external reference clock</description>
            <name>CLKSRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Returns 1 if timer counted to 0 since last time this register was read.
                        COUNTFLAG is set by a count transition from 1 to 0.
                        COUNTFLAG is cleared on read or by a write to the Current Value register.</description>
            <name>COUNTFLAG</name>
            <readAction>modify</readAction>
          </field>
        </fields>
        <name>SYST_CSR</name>
        <resetMask>0xFFFFFFFB</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SysTick Reload value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Value to load into the Current Value register when the counter reaches 0.</description>
            <name>RELOAD</name>
          </field>
        </fields>
        <name>SYST_RVR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>SysTick Current value</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Current counter value. This is the value of the counter at the time it is sampled. The counter does not provide read-modify-write protection. The register is write-clear. A software write of any value will clear the register to 0. Unsupported bits RAZ (see SysTick Reload Value register).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>CURRENT</name>
          </field>
        </fields>
        <name>SYST_CVR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>IRQ0 ~ IRQ31 Set-Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Enable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). 
                        Writing 1 will enable the associated interrupt.
                        Writing 0 has no effect.
                        The register reads back with the current enable state.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SETENA</name>
          </field>
        </fields>
        <name>NVIC_ISER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>IRQ0 ~ IRQ31 Clear-Enable Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Disable one or more interrupts within a group of 32. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47). 
                        Writing 1 will disable the associated interrupt.
                        Writing 0 has no effect.
                        The register reads back with the current enable state.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRENA</name>
          </field>
        </fields>
        <name>NVIC_ICER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>IRQ0 ~ IRQ31 Set-Pending Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 to a bit pends the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).
                        Writing 0 has no effect.
                        The register reads back with the current pending state.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SETPEND</name>
          </field>
        </fields>
        <name>NVIC_ISPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x280</addressOffset>
        <description>IRQ0 ~ IRQ31 Clear-Pending Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Writing 1 to a bit un-pends the associated interrupt under software control. Each bit represents an interrupt number from IRQ0 ~ IRQ31 (Vector number from 16 ~ 47).
                        Writing 0 has no effect.
                        The register reads back with the current pending state.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRPEND</name>
          </field>
        </fields>
        <name>NVIC_ICPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x400</addressOffset>
        <description>IRQ0 ~ IRQ3 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ0
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ1
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ2
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ3
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_3</name>
          </field>
        </fields>
        <name>NVIC_IPR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x404</addressOffset>
        <description>IRQ4 ~ IRQ7 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ4
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ5
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ6
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_6</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ7
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_7</name>
          </field>
        </fields>
        <name>NVIC_IPR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x408</addressOffset>
        <description>IRQ8 ~ IRQ11 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ8
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_8</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ9
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_9</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ10
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_10</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ11
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_11</name>
          </field>
        </fields>
        <name>NVIC_IPR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40C</addressOffset>
        <description>IRQ12 ~ IRQ15 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ12
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_12</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ13
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_13</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ14
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ15
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_15</name>
          </field>
        </fields>
        <name>NVIC_IPR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x410</addressOffset>
        <description>IRQ16 ~ IRQ19 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ16
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_16</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ17
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_17</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ18
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_18</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ19
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_19</name>
          </field>
        </fields>
        <name>NVIC_IPR4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x414</addressOffset>
        <description>IRQ20 ~ IRQ23 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ20
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_20</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ21
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_21</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ22
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_22</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ23
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_23</name>
          </field>
        </fields>
        <name>NVIC_IPR5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x418</addressOffset>
        <description>IRQ24 ~ IRQ27 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ24
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_24</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ25
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_25</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ26
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_26</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ27
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_27</name>
          </field>
        </fields>
        <name>NVIC_IPR6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x41C</addressOffset>
        <description>IRQ28 ~ IRQ31 Priority Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ28
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_28</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ29
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_29</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ30
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_30</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of IRQ31
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_31</name>
          </field>
        </fields>
        <name>NVIC_IPR7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xD00</addressOffset>
        <description>CPUID Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Reads as 0x0</description>
            <name>REVESION</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Reads as 0xC20</description>
            <name>PARTNO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Reads as 0xC for ARMv6-M parts</description>
            <name>PART</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Implementer code assigned by ARM. ( ARM = 0x41)</description>
            <name>IMPLEMENTER</name>
          </field>
        </fields>
        <name>CPUID</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x410CC200</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD04</addressOffset>
        <description>Interrupt Control State Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>0 = Thread mode
                        Value &gt; 1 = the exception number for the current executing exception.This is a read only bit.</description>
            <name>VECTACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Indicates the exception number for the highest priority pending exception. The pending state includes the effect of memory-mapped enable and mask registers. It does not include the PRIMASK special-purpose register qualifier. A value of zero indicates no pending exceptions.
                        This is a read only bit.</description>
            <name>VECTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates if an external configurable (NVIC generated) interrupt is pending.
                        This is a read only bit.</description>
            <name>ISRPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If set, a pending exception will be serviced on exit from the debug halt state.
                        This is a read only bit.</description>
            <name>ISRPREEMPT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write 1 to clear a pending SysTick. This is a write only bit.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>PENDSTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set a pending SysTick. Reads back with current state (1 if Pending, 0 if not).</description>
            <name>PENDSTSET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write 1 to clear a pending PendSV interrupt. This is a write only bit.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>PENDSVCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set a pending PendSV interrupt. This is normally used to request a context switch. Reads back with current state (1 if Pending, 0 if not).</description>
            <name>PENDSVSET</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Setting this bit will activate an NMI. Since NMI is the highest priority exception, it will activate as soon as it is registered. Reads back with current state (1 if Pending, 0 if not).</description>
            <name>NMIPENDSET</name>
          </field>
        </fields>
        <name>ICSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD0C</addressOffset>
        <description>Application Interrupt and Reset Control Register</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Set this bit to 1 will clears all active state information for fixed and configurable exceptions. The bit is a write only bit and can only be written when the core is halted. Note: It is the debugger's responsibility to re-initialize the stack. </description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>VECTCLRACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing this bit 1 will cause a reset signal to be asserted to the chip to indicate a reset is requested. The bit is a write only bit and self-clears as part of the reset sequence. </description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>SYSRESETREQ</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When write this register, this field should be 0x05FA, otherwise the write action will be unpredictable. </description>
            <name>VECTORKEY</name>
          </field>
        </fields>
        <name>AIRCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD10</addressOffset>
        <description>System Control Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When set to 1, the core can enter a sleep state on an exception return to Thread mode. This is the mode and exception level entered at reset, the base level of execution.</description>
            <name>SLEEPONEXIT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A qualifying hint that indicates waking from sleep might take longer.</description>
            <name>SLEEPDEEP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When enabled, interrupt transitions from Inactive to Pending are included in the list of wakeup events for the WFE instruction.</description>
            <name>SEVONPEND</name>
          </field>
        </fields>
        <name>SCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD1C</addressOffset>
        <description>System Handler Priority Register 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of system handler 11 SVCall
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_11</name>
          </field>
        </fields>
        <name>SHPR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD20</addressOffset>
        <description>System Handler Priority Register 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of system handler 14 PendSV
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_14</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Priority of system handler 15 SysTick
                        "0" denotes the highest priority and "3" denotes lowest priority</description>
            <name>PRI_15</name>
          </field>
        </fields>
        <name>SHPR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40030000</baseAddress>
    <description>Registers group</description>
    <groupName>SPI</groupName>
    <interrupts></interrupts>
    <name>SPI0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Go and Busy Status
                        1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
                        0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
                        During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.
                        NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>GO_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive At Negative Edge
                        1 = The received data input signal is latched at the falling edge of SPICLK.
                        0 = The received data input signal is latched at the rising edge of SPICLK.</description>
            <name>RX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit At Negative Edge
                        1 = The transmitted data output signal is changed at the falling edge of SPICLK.
                        0 = The transmitted data output signal is changed at the rising edge of SPICLK.</description>
            <name>TX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Transmit Bit Length
                        This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted.
                        TX_BIT_LEN = 0x01 ... 1 bit
                        TX_BIT_LEN = 0x02 ... 2 bits
                        ......
                        TX_BIT_LEN = 0x1f ... 31 bits
                        TX_BIT_LEN = 0x00 .. 32 bits</description>
            <name>TX_BIT_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Numbers of Transmit/Receive Word
                        This field specifies how many transmit/receive word numbers should be executed in one transfer.
                        00 = Only one transmit/receive word will be executed in one transfer.
                        01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
                        10 = Reserved.
                        11 = Reserved.</description>
            <name>TX_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First
                        1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
                        0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).</description>
            <name>LSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity
                        1 = SPICLK idle high.
                        0 = SPICLK idle low.</description>
            <name>CLKP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Suspend Interval (master only)
                        These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation:
                        (SP_CYCLE[3:0] + 2)*period of SPI clock
                        SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
                        SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
                        ......
                        SP_CYCLE = 0xe ... 16 SPICLK clock cycle
                        SP_CYCLE = 0xf ... 17 SPICLK clock cycle</description>
            <name>SP_CYCLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Flag
                        1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
                        0 = It indicates that the transfer does not finish yet.
                        NOTE: This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable
                        1 = Enable MICROWIRE/SPI Interrupt.
                        0 = Disable MICROWIRE/SPI Interrupt.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SLAVE Mode Indication
                        1 = Slave mode.
                        0 = Master mode.</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reorder Mode Select
                        00 = Disable both byte reorder and byte suspend functions.
                        01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        10 = Enable byte reorder function, but disable byte suspend function.
                        11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.</description>
            <name>REORDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Two Bits Transfer Mode Active
                        1 = Enable two-bit transfer mode.
                        0 = disable two-bit transfer mode.
                        Note that when enable TWOB, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.
                        Note that when enable TWOB, the setting of TX_NUM must be programmed as 0x00.</description>
            <name>TWOB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Variable Clock Enable (master only)
                        1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
                        0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. 
                        Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
            <name>VARCLK_EN</name>
          </field>
        </fields>
        <name>SPI_CNTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider Register (master only) 
                        The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER+1)*2)
                        In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
            <name>DIVIDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider 2 Register (master only) 
                        The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER2+1)*2)</description>
            <name>DIVIDER2</name>
          </field>
        </fields>
        <name>SPI_DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Slave Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave Select Register (master only)
                        If AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.
                        If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).
                        Note: 
                        1. This interface can only drive one device/slave at a given time. Therefore, the slave select pin of the selected device must be set to its active level before starting any read or write transfer. 
                        2. SPISSx0 is also defined as device/slave select input signal in slave mode. </description>
            <name>SSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Active Level
                        It defines the active level of slave select signal (SPISSx0/1). 
                        1 = The slave select signal SPISSx0/1 is active at high-level/rising-edge.
                        0 = The slave select signal SPISSx0/1 is active at low-level/falling-edge..</description>
            <name>SS_LVL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Slave Select (master only)
                        1 = If this bit is set, SPISSx0/1 signals are generated automatically. It means that slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
                        0 = If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.</description>
            <name>AUTOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Level Trigger (slave only)
                        1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high.
                        0: The input slave select signal is edge-trigger. This is default value.</description>
            <name>SS_LTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Level Trigger Flag
                        When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
                        1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN.
                        0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements.
                        Note: This bit is READ only</description>
            <name>LTRIG_FLAG</name>
          </field>
        </fields>
        <name>SPI_SSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Data Receive Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Receive Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Data Transmit Register 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Data Transmit Register 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Variable Clock Pattern Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Variable Clock Pattern 
                        The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.</description>
            <name>VARCLK</name>
          </field>
        </fields>
        <name>SPI_VARCLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7FFF87</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>SPI DMA control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit DMA start
                        Set this bit to 1 will start the transmit DMA process. SPI module will issue request to DMA module automatically. 
                        If using DMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI module will set it automatically whenever necessary.
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>TX_DMA_GO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive DMA start
                        Set this bit to 1 will start the receive DMA process. SPI module will issue request to DMA module automatically. 
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>RX_DMA_GO</name>
          </field>
        </fields>
        <name>SPI_DMA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40034000</baseAddress>
    <description>Registers group</description>
    <groupName>SPI</groupName>
    <interrupts></interrupts>
    <name>SPI1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Go and Busy Status
                        1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
                        0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
                        During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.
                        NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>GO_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive At Negative Edge
                        1 = The received data input signal is latched at the falling edge of SPICLK.
                        0 = The received data input signal is latched at the rising edge of SPICLK.</description>
            <name>RX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit At Negative Edge
                        1 = The transmitted data output signal is changed at the falling edge of SPICLK.
                        0 = The transmitted data output signal is changed at the rising edge of SPICLK.</description>
            <name>TX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Transmit Bit Length
                        This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted.
                        TX_BIT_LEN = 0x01 ... 1 bit
                        TX_BIT_LEN = 0x02 ... 2 bits
                        ......
                        TX_BIT_LEN = 0x1f ... 31 bits
                        TX_BIT_LEN = 0x00 .. 32 bits</description>
            <name>TX_BIT_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Numbers of Transmit/Receive Word
                        This field specifies how many transmit/receive word numbers should be executed in one transfer.
                        00 = Only one transmit/receive word will be executed in one transfer.
                        01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
                        10 = Reserved.
                        11 = Reserved.</description>
            <name>TX_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First
                        1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
                        0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).</description>
            <name>LSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity
                        1 = SPICLK idle high.
                        0 = SPICLK idle low.</description>
            <name>CLKP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Suspend Interval (master only)
                        These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation:
                        (SP_CYCLE[3:0] + 2)*period of SPI clock
                        SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
                        SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
                        ......
                        SP_CYCLE = 0xe ... 16 SPICLK clock cycle
                        SP_CYCLE = 0xf ... 17 SPICLK clock cycle</description>
            <name>SP_CYCLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Flag
                        1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
                        0 = It indicates that the transfer does not finish yet.
                        NOTE: This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable
                        1 = Enable MICROWIRE/SPI Interrupt.
                        0 = Disable MICROWIRE/SPI Interrupt.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SLAVE Mode Indication
                        1 = Slave mode.
                        0 = Master mode.</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reorder Mode Select
                        00 = Disable both byte reorder and byte suspend functions.
                        01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        10 = Enable byte reorder function, but disable byte suspend function.
                        11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.</description>
            <name>REORDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Two Bits Transfer Mode Active
                        1 = Enable two-bit transfer mode.
                        0 = disable two-bit transfer mode.
                        Note that when enable TWOB, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.
                        Note that when enable TWOB, the setting of TX_NUM must be programmed as 0x00.</description>
            <name>TWOB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Variable Clock Enable (master only)
                        1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
                        0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. 
                        Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
            <name>VARCLK_EN</name>
          </field>
        </fields>
        <name>SPI_CNTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider Register (master only) 
                        The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER+1)*2)
                        In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
            <name>DIVIDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider 2 Register (master only) 
                        The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER2+1)*2)</description>
            <name>DIVIDER2</name>
          </field>
        </fields>
        <name>SPI_DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Slave Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave Select Register (master only)
                        If AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.
                        If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).
                        Note: 
                        1. This interface can only drive one device/slave at a given time. Therefore, the slave select pin of the selected device must be set to its active level before starting any read or write transfer. 
                        2. SPISSx0 is also defined as device/slave select input signal in slave mode. </description>
            <name>SSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Active Level
                        It defines the active level of slave select signal (SPISSx0/1). 
                        1 = The slave select signal SPISSx0/1 is active at high-level/rising-edge.
                        0 = The slave select signal SPISSx0/1 is active at low-level/falling-edge..</description>
            <name>SS_LVL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Slave Select (master only)
                        1 = If this bit is set, SPISSx0/1 signals are generated automatically. It means that slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
                        0 = If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.</description>
            <name>AUTOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Level Trigger (slave only)
                        1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high.
                        0: The input slave select signal is edge-trigger. This is default value.</description>
            <name>SS_LTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Level Trigger Flag
                        When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
                        1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN.
                        0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements.
                        Note: This bit is READ only</description>
            <name>LTRIG_FLAG</name>
          </field>
        </fields>
        <name>SPI_SSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Data Receive Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Receive Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Data Transmit Register 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Data Transmit Register 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Variable Clock Pattern Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Variable Clock Pattern 
                        The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.</description>
            <name>VARCLK</name>
          </field>
        </fields>
        <name>SPI_VARCLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7FFF87</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>SPI DMA control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit DMA start
                        Set this bit to 1 will start the transmit DMA process. SPI module will issue request to DMA module automatically. 
                        If using DMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI module will set it automatically whenever necessary.
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>TX_DMA_GO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive DMA start
                        Set this bit to 1 will start the receive DMA process. SPI module will issue request to DMA module automatically. 
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>RX_DMA_GO</name>
          </field>
        </fields>
        <name>SPI_DMA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40130000</baseAddress>
    <description>Registers group</description>
    <groupName>SPI</groupName>
    <interrupts></interrupts>
    <name>SPI2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Go and Busy Status
                        1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
                        0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
                        During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.
                        NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>GO_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive At Negative Edge
                        1 = The received data input signal is latched at the falling edge of SPICLK.
                        0 = The received data input signal is latched at the rising edge of SPICLK.</description>
            <name>RX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit At Negative Edge
                        1 = The transmitted data output signal is changed at the falling edge of SPICLK.
                        0 = The transmitted data output signal is changed at the rising edge of SPICLK.</description>
            <name>TX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Transmit Bit Length
                        This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted.
                        TX_BIT_LEN = 0x01 ... 1 bit
                        TX_BIT_LEN = 0x02 ... 2 bits
                        ......
                        TX_BIT_LEN = 0x1f ... 31 bits
                        TX_BIT_LEN = 0x00 .. 32 bits</description>
            <name>TX_BIT_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Numbers of Transmit/Receive Word
                        This field specifies how many transmit/receive word numbers should be executed in one transfer.
                        00 = Only one transmit/receive word will be executed in one transfer.
                        01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
                        10 = Reserved.
                        11 = Reserved.</description>
            <name>TX_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First
                        1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
                        0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).</description>
            <name>LSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity
                        1 = SPICLK idle high.
                        0 = SPICLK idle low.</description>
            <name>CLKP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Suspend Interval (master only)
                        These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation:
                        (SP_CYCLE[3:0] + 2)*period of SPI clock
                        SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
                        SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
                        ......
                        SP_CYCLE = 0xe ... 16 SPICLK clock cycle
                        SP_CYCLE = 0xf ... 17 SPICLK clock cycle</description>
            <name>SP_CYCLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Flag
                        1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
                        0 = It indicates that the transfer does not finish yet.
                        NOTE: This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable
                        1 = Enable MICROWIRE/SPI Interrupt.
                        0 = Disable MICROWIRE/SPI Interrupt.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SLAVE Mode Indication
                        1 = Slave mode.
                        0 = Master mode.</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reorder Mode Select
                        00 = Disable both byte reorder and byte suspend functions.
                        01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        10 = Enable byte reorder function, but disable byte suspend function.
                        11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.</description>
            <name>REORDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Two Bits Transfer Mode Active
                        1 = Enable two-bit transfer mode.
                        0 = disable two-bit transfer mode.
                        Note that when enable TWOB, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.
                        Note that when enable TWOB, the setting of TX_NUM must be programmed as 0x00.</description>
            <name>TWOB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Variable Clock Enable (master only)
                        1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
                        0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. 
                        Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
            <name>VARCLK_EN</name>
          </field>
        </fields>
        <name>SPI_CNTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider Register (master only) 
                        The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER+1)*2)
                        In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
            <name>DIVIDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider 2 Register (master only) 
                        The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER2+1)*2)</description>
            <name>DIVIDER2</name>
          </field>
        </fields>
        <name>SPI_DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Slave Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave Select Register (master only)
                        If AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.
                        If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).
                        Note: 
                        1. This interface can only drive one device/slave at a given time. Therefore, the slave select pin of the selected device must be set to its active level before starting any read or write transfer. 
                        2. SPISSx0 is also defined as device/slave select input signal in slave mode. </description>
            <name>SSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Active Level
                        It defines the active level of slave select signal (SPISSx0/1). 
                        1 = The slave select signal SPISSx0/1 is active at high-level/rising-edge.
                        0 = The slave select signal SPISSx0/1 is active at low-level/falling-edge..</description>
            <name>SS_LVL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Slave Select (master only)
                        1 = If this bit is set, SPISSx0/1 signals are generated automatically. It means that slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
                        0 = If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.</description>
            <name>AUTOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Level Trigger (slave only)
                        1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high.
                        0: The input slave select signal is edge-trigger. This is default value.</description>
            <name>SS_LTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Level Trigger Flag
                        When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
                        1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN.
                        0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements.
                        Note: This bit is READ only</description>
            <name>LTRIG_FLAG</name>
          </field>
        </fields>
        <name>SPI_SSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Data Receive Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Receive Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Data Transmit Register 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Data Transmit Register 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Variable Clock Pattern Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Variable Clock Pattern 
                        The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.</description>
            <name>VARCLK</name>
          </field>
        </fields>
        <name>SPI_VARCLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7FFF87</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>SPI DMA control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit DMA start
                        Set this bit to 1 will start the transmit DMA process. SPI module will issue request to DMA module automatically. 
                        If using DMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI module will set it automatically whenever necessary.
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>TX_DMA_GO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive DMA start
                        Set this bit to 1 will start the receive DMA process. SPI module will issue request to DMA module automatically. 
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>RX_DMA_GO</name>
          </field>
        </fields>
        <name>SPI_DMA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xC</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40134000</baseAddress>
    <description>Registers group</description>
    <groupName>SPI</groupName>
    <interrupts></interrupts>
    <name>SPI3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Go and Busy Status
                        1 = In master mode, writing 1 to this bit to start the SPI data transfer; in slave mode, writing 1 to this bit indicates that the slave is ready to communicate with a master.
                        0 = Writing 0 to this bit to stop data transfer if SPI is transferring.
                        During the data transfer, this bit keeps the value of 1. As the transfer is finished, this bit will be cleared automatically.
                        NOTE: All registers should be set before writing 1 to this GO_BUSY bit. The transfer result will be unpredictable if software changes related settings when GO_BUSY bit is 1.</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>GO_BUSY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive At Negative Edge
                        1 = The received data input signal is latched at the falling edge of SPICLK.
                        0 = The received data input signal is latched at the rising edge of SPICLK.</description>
            <name>RX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit At Negative Edge
                        1 = The transmitted data output signal is changed at the falling edge of SPICLK.
                        0 = The transmitted data output signal is changed at the rising edge of SPICLK.</description>
            <name>TX_NEG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Transmit Bit Length
                        This field specifies how many bits are transmitted in one transaction. Up to 32 bits can be transmitted.
                        TX_BIT_LEN = 0x01 ... 1 bit
                        TX_BIT_LEN = 0x02 ... 2 bits
                        ......
                        TX_BIT_LEN = 0x1f ... 31 bits
                        TX_BIT_LEN = 0x00 .. 32 bits</description>
            <name>TX_BIT_LEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Numbers of Transmit/Receive Word
                        This field specifies how many transmit/receive word numbers should be executed in one transfer.
                        00 = Only one transmit/receive word will be executed in one transfer.
                        01 = Two successive transmit/receive words will be executed in one transfer. (burst mode)
                        10 = Reserved.
                        11 = Reserved.</description>
            <name>TX_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First
                        1 = The LSB is sent first on the line (bit 0 of SPI_TX0/1), and the first bit received from the line will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
                        0 = The MSB is transmitted/received first (which bit in SPI_TX0/1 and SPI_RX0/1 register that is depends on the TX_BIT_LEN field).</description>
            <name>LSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity
                        1 = SPICLK idle high.
                        0 = SPICLK idle low.</description>
            <name>CLKP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Suspend Interval (master only)
                        These four bits provide configurable suspend interval between two successive transmit/receive transactions in a transfer. The suspend interval is from the last falling clock edge of the current transaction to the first rising clock edge of the successive transaction if CLKP = 0. If CLKP = 1, the interval is from the rising clock edge to the falling clock edge. The default value is 0x0. When TX_NUM = 00b, setting this field has no effect on transfer. The desired suspend interval is obtained according to the following equation:
                        (SP_CYCLE[3:0] + 2)*period of SPI clock
                        SP_CYCLE = 0x0 ... 2 SPICLK clock cycle
                        SP_CYCLE = 0x1 ... 3 SPICLK clock cycle
                        ......
                        SP_CYCLE = 0xe ... 16 SPICLK clock cycle
                        SP_CYCLE = 0xf ... 17 SPICLK clock cycle</description>
            <name>SP_CYCLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Flag
                        1 = It indicates that the transfer is done. The interrupt flag is set if it was enable.
                        0 = It indicates that the transfer does not finish yet.
                        NOTE: This bit can be cleared by writing 1 to itself.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable
                        1 = Enable MICROWIRE/SPI Interrupt.
                        0 = Disable MICROWIRE/SPI Interrupt.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SLAVE Mode Indication
                        1 = Slave mode.
                        0 = Master mode.</description>
            <name>SLAVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Reorder Mode Select
                        00 = Disable both byte reorder and byte suspend functions.
                        01 = Enable byte reorder function and insert a byte suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        10 = Enable byte reorder function, but disable byte suspend function.
                        11 = Disable byte reorder function, but insert a suspend interval (2~17 SPICLK cycles) among each byte. The setting of TX_BIT_LEN must be configured as 0x00. (32 bits/word).
                        Byte reorder function is only available if TX_BIT_LEN is defined as 16, 24 and 32.</description>
            <name>REORDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Two Bits Transfer Mode Active
                        1 = Enable two-bit transfer mode.
                        0 = disable two-bit transfer mode.
                        Note that when enable TWOB, the serial transmitted 2-bit data output are from SPI_TX1/0, and the received 2-bit data input are put in SPI_RX1/0.
                        Note that when enable TWOB, the setting of TX_NUM must be programmed as 0x00.</description>
            <name>TWOB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Variable Clock Enable (master only)
                        1 = The serial clock output frequency is variable. The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
                        0 = The serial clock output frequency is fixed and decided only by the value of DIVIDER. 
                        Note that when enable this VARCLK_EN bit, the setting of TX_BIT_LEN must be programmed as 0x10 (16 bits mode)</description>
            <name>VARCLK_EN</name>
          </field>
        </fields>
        <name>SPI_CNTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x4</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Clock Divider Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider Register (master only) 
                        The value in this field is the frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER+1)*2)
                        In slave mode, the period of SPI clock driven by a master shall equal or over 5 times the period of PCLK. In other words, the maximum frequency of SPI clock is the fifth of the frequency of slave's PCLK.</description>
            <name>DIVIDER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Clock Divider 2 Register (master only) 
                        The value in this field is the 2nd frequency divider of the system clock, PCLK, to generate the serial clock on the output SPICLK. The desired frequency is obtained according to the following equation:
                        fsclk = fpclk / ((DIVIDER2+1)*2)</description>
            <name>DIVIDER2</name>
          </field>
        </fields>
        <name>SPI_DIVIDER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Slave Select Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave Select Register (master only)
                        If AUTOSS bit is cleared, writing 1 to any bit location of this field sets the proper SPISSx0/1 line to an active state and writing 0 sets the line back to inactive state.
                        If AUTOSS bit is set, writing 1 to any bit location of this field will select appropriate SPISSx0/1 line to be automatically driven to active state for the duration of the transmit/receive, and will be driven to inactive state for the rest of the time. (The active level of SPISSx0/1 is specified in SS_LVL).
                        Note: 
                        1. This interface can only drive one device/slave at a given time. Therefore, the slave select pin of the selected device must be set to its active level before starting any read or write transfer. 
                        2. SPISSx0 is also defined as device/slave select input signal in slave mode. </description>
            <name>SSR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Active Level
                        It defines the active level of slave select signal (SPISSx0/1). 
                        1 = The slave select signal SPISSx0/1 is active at high-level/rising-edge.
                        0 = The slave select signal SPISSx0/1 is active at low-level/falling-edge..</description>
            <name>SS_LVL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Automatic Slave Select (master only)
                        1 = If this bit is set, SPISSx0/1 signals are generated automatically. It means that slave select signal, which is set in SSR[1:0] register is asserted by the SPI controller when transmit/receive is started by setting GO_BUSY, and is de-asserted after each transmit/receive is finished.
                        0 = If this bit is cleared, slave select signals are asserted and de-asserted by setting and clearing related bits in SSR[1:0] register.</description>
            <name>AUTOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Level Trigger (slave only)
                        1: The slave select signal will be level-trigger. It depends on SS_LVL to decide the signal is active low or active high.
                        0: The input slave select signal is edge-trigger. This is default value.</description>
            <name>SS_LTRIG</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Level Trigger Flag
                        When the SS_LTRIG bit is set in slave mode, this bit can be read to indicate the received bit number is met the requirement or not.
                        1 = The transaction number and the transferred bit length met the specified requirements which defined in TX_NUM and TX_BIT_LEN.
                        0 = The transaction number or the transferred bit length of one transaction doesn't meet the specified requirements.
                        Note: This bit is READ only</description>
            <name>LTRIG_FLAG</name>
          </field>
        </fields>
        <name>SPI_SSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Data Receive Register 0</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Data Receive Register 1</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Receive Register
                        The Data Receive Registers hold the value of received data of the last executed transfer. The number of valid bits depend on the transmit bit length field in the SPI_CNTRL register. For example, if TX_BIT_LEN is set to 0x08 and TX_NUM is set to 0x0, bit RX0[7:0] holds the received data.
                        NOTE: The Data Receive Registers are read only registers.</description>
            <name>RX</name>
          </field>
        </fields>
        <name>SPI_RX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x20</addressOffset>
        <description>Data Transmit Register 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Data Transmit Register 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data Transmit Register
                        The Data Transmit Registers hold the data to be transmitted in the next transfer. The number of valid bits depend on the transmit bit length field in the CNTRL register. 
                        For example, if TX_BIT_LEN is set to 0x08 and the TX_NUM is set to 0x0, the bit TX0[7:0] will be transmitted in next transfer. If TX_BIT_LEN is set to 0x00 and TX_NUM is set to 0x1, the core will perform two successive 32-bit transmit/receive using the same setting (the order is TX0[31:0], TX1[31:0]).</description>
            <name>TX</name>
          </field>
        </fields>
        <name>SPI_TX1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Variable Clock Pattern Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Variable Clock Pattern 
                        The value in this field is the frequency patterns of the SPI clock. If the bit patterns of VARCLK are 0, the output frequency of SPICLK is according the value of DIVIDER. If the bit patterns of VARCLK are 1, the output frequency of SPICLK is according the value of DIVIDER2. Refer to register SPI_DIVIDER.</description>
            <name>VARCLK</name>
          </field>
        </fields>
        <name>SPI_VARCLK</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7FFF87</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>SPI DMA control register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit DMA start
                        Set this bit to 1 will start the transmit DMA process. SPI module will issue request to DMA module automatically. 
                        If using DMA mode to transfer data, remember not to set GO_BUSY bit of SPI_CNTRL register. The DMA controller inside SPI module will set it automatically whenever necessary.
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>TX_DMA_GO</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive DMA start
                        Set this bit to 1 will start the receive DMA process. SPI module will issue request to DMA module automatically. 
                        Hardware will clear this bit automatically after DMA transfer done.</description>
            <name>RX_DMA_GO</name>
          </field>
        </fields>
        <name>SPI_DMA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010000</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter Mode Enable Bit (Low Density only)
                        This bit is the counter mode enable bit. When Timer is used as an event counter, this bit should be set to 1 and Timer will work as an event counter triggered by raising edge of external pin.
                        1 = Enable counter mode
                        0 = Disable counter mode</description>
            <name>CTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle. (This mode only supported in Low Density)	
                        11	The timer is operating in auto-reload counting mode. The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled); however, the 24-bit up-timer counts continuously without reset. (This mode only supported in Low Density)	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40010020</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter Mode Enable Bit (Low Density only)
                        This bit is the counter mode enable bit. When Timer is used as an event counter, this bit should be set to 1 and Timer will work as an event counter triggered by raising edge of external pin.
                        1 = Enable counter mode
                        0 = Disable counter mode</description>
            <name>CTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle. (This mode only supported in Low Density)	
                        11	The timer is operating in auto-reload counting mode. The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled); however, the 24-bit up-timer counts continuously without reset. (This mode only supported in Low Density)	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40110000</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter Mode Enable Bit (Low Density only)
                        This bit is the counter mode enable bit. When Timer is used as an event counter, this bit should be set to 1 and Timer will work as an event counter triggered by raising edge of external pin.
                        1 = Enable counter mode
                        0 = Disable counter mode</description>
            <name>CTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle. (This mode only supported in Low Density)	
                        11	The timer is operating in auto-reload counting mode. The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled); however, the 24-bit up-timer counts continuously without reset. (This mode only supported in Low Density)	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x10</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40110020</baseAddress>
    <description>Registers group</description>
    <groupName>TMR</groupName>
    <interrupts></interrupts>
    <name>TMR3</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Timer0 Control and Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pre-scale Counter
                        Clock input is divided by PRESCALE+1 before it is fed to the counter. If PRESCALE=0, then there is no scaling.</description>
            <name>PRESCALE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data Load Enable
                        When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit up-timer value as the timer is counting. 
                        1 = Timer Data Register update enable.
                        0 = Timer Data Register update disable. </description>
            <name>TDR_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Counter Mode Enable Bit (Low Density only)
                        This bit is the counter mode enable bit. When Timer is used as an event counter, this bit should be set to 1 and Timer will work as an event counter triggered by raising edge of external pin.
                        1 = Enable counter mode
                        0 = Disable counter mode</description>
            <name>CTB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Active Status Bit (Read only)
                        This bit indicates the up-timer status.
                        0 = Timer is not active.
                        1 = Timer is active.</description>
            <name>CACT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Reset Bit
                        Set this bit will reset the 24-bit up-timer, 8-bit pre-scale counter and also force CEN to 0.
                        0 = No effect.
                        1 = Reset Timer's 8-bit pre-scale counter, internal 24-bit up-timer and CEN bit.</description>
            <name>CRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Timer Operating Mode
                        MODE	Timer Operating Mode	
                        00	The timer is operating in the one-shot mode. The associated interrupt signal is generated once (if IE is enabled) and CEN is automatically cleared by hardware.	
                        01	The timer is operating in the periodic mode. The associated interrupt signal is generated periodically (if IE is enabled).	
                        10	The timer is operating in the toggle mode. The interrupt signal is generated periodically (if IE is enabled). And the associated signal (tout) is changing back and forth with 50% duty cycle. (This mode only supported in Low Density)	
                        11	The timer is operating in auto-reload counting mode. The associated interrupt signal is generated when TDR = TCMPR (if IE is enabled); however, the 24-bit up-timer counts continuously without reset. (This mode only supported in Low Density)	</description>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt Enable Bit
                        1 = Enable timer Interrupt.
                        0 = Disable timer Interrupt. 
                        If timer interrupt is enabled, the timer asserts its interrupt signal when the associated up-timer value is equal to TCMPR.</description>
            <name>IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Enable Bit
                        1 = Starts counting
                        0 = Stops/Suspends counting
                        Note1: In stop status, and then set CEN to 1 will enables the 24-bit up-timer keeps up counting from the last stop counting value.
                        Note2: This bit is auto-cleared by hardware in one-shot mode (MODE[28:27]=00) when the associated timer interrupt is generated (IE[29]=1).</description>
            <name>CEN</name>
          </field>
        </fields>
        <name>TCSR</name>
        <resetMask>0xFFFFFFFA</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Timer0 Compare Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Compared Value
                        TCMP is a 24-bit compared register. When the internal 24-bit up-timer counts and its value is equal to TCMP value, a Timer Interrupt is requested if the timer interrupt is enabled with TCSR.IE[29]=1. The TCMP value defines the timer counting cycle time.
                        Time out period = (Period of timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP)
                        NOTE1: Never write 0x0 or 0x1 in TCMP, or the core will run into unknown state.
                        NOTE2: No matter CEN is 0 or 1, whenever software write a new value into this register, TIMER will restart counting using this new value and abort previous count.</description>
            <name>TCMP</name>
          </field>
        </fields>
        <name>TCMPR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Timer0 Interrupt Status Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Timer Interrupt Flag
                        This bit indicates the interrupt status of Timer.
                        TIF bit is set by hardware when the up counting value of internal 24-bit timer matches the timer compared value (TCMP). It is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TIF</name>
          </field>
        </fields>
        <name>TISR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Timer0 Data Register</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Timer Data Register
                        When TCSR.TDR_EN is set to 1, the internal 24-bit up-timer value will be loaded into TDR. User can read this register for the up-timer value.</description>
            <name>TDR</name>
          </field>
        </fields>
        <name>TDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40050000</baseAddress>
    <description>Registers group</description>
    <groupName>UART</groupName>
    <interrupts></interrupts>
    <name>UART0</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Receive Buffer Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive Buffer Register
                        By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).</description>
            <name>RBR</name>
            <readAction>modify</readAction>
          </field>
        </fields>
        <name>UA_RBR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Transmit Holding Register.</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit Holding Register
                        By writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>THR</name>
          </field>
        </fields>
        <name>UA_THR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt Enable Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Enable.
                        0 = Mask off INT_RDA
                        1 = Enable INT_RDA</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RDA_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Enable
                        0 = Mask off INT_THRE
                        1 = Enable INT_THRE</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>THRE_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Enable
                        0 = Mask off INT_RLS
                        1 = Enable INT_RLS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RLS_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Modem Status Interrupt Enable
                        0 = Mask off INT_MODEM
                        1 = Enable INT_MODEM</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>MODEM_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Time out Interrupt Enable
                        0 = Mask off INT_TOUT
                        1 = Enable INT_TOUT.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTO_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Enable
                        0 = Mask off INT_Buf_ERR
                        1 = Enable INT_Buf_ERR</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BUF_ERR_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up CPU function enable
                        0 = Disable UART wake up CPU function
                        1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS change will wake up CPU from deep sleep mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WAKE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN RX Break Field Detected Interrupt Enable
                        0 = Mask off Lin bus Rx break filed interrupt.
                        1 = Enable Lin bus Rx break filed interrupt.
                        Note: This field is used for LIN function mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_RX_BRK_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable Time-out counter.
                        0 = Disable Time-out counter.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TIME_OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Auto Flow Control Enable
                        1 = Enable RTS auto flow control.
                        0 = Disable RTS auto flow control.
                        When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR[RTS_Tri_Lev], the UART will de-assert RTS signal.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>AUTO_RTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Auto Flow Control Enable
                        1 = Enable CTS auto flow control.
                        0 = Disable CTS auto flow control.
                        When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>AUTO_CTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX DMA Enable 
                        1 = Enable TX DMA.
                        0 = Disable TX DMA.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DMA_TX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable RX DMA.
                        0 = Disable RX DMA.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DMA_RX_EN</name>
          </field>
        </fields>
        <name>UA_IER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>FIFO Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Field Software Reset
                        When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
                        Note: This bit will auto clear needs at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Field Software Reset
                        When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
                        Note: This bit will auto clear needs at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Rx FIFO Interrupt (INT_RDA) Trigger Level 
                        When the number of bytes in the receive FIFO equals the RFITL then the RDA_IF will be set (if IER [RDA_IEN] is enable, an interrupt will generated).
                        RFITL	INTR_RDA Trigger Level (Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	
                        0100	30/14 (High Speed/Normal Speed)	
                        0101	46/14 (High Speed/Normal Speed)	
                        0110	62/14 (High Speed/Normal Speed)	
                        others	62/14 (High Speed/Normal Speed)	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RFITL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Disable register
                        The receiver is disabled or not (set 1 is disable receiver)
                        1 = Disable Receiver.
                        0 = Enable Receiver.
                        Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RX_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>RTS Trigger Level for Auto-flow Control Use(not available in UART2 channel)
                        RTS_Tri_Lev	Trigger Level (Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	
                        0100	30/14 (High Speed/Normal Speed)	
                        0101	46/14 (High Speed/Normal Speed)	
                        0110	62/14 (High Speed/Normal Speed)	
                        others	62/14 (High Speed/Normal Speed)	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS_TRI_LEV</name>
          </field>
        </fields>
        <name>UA_FCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Line Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Length Select
                        WLS[1:0]	Character length	
                        00	5 bits	
                        01	6 bits	
                        10	7 bits	
                        11	8 bits	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WLS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of "STOP bit"
                        0= One "STOP bit" is generated in the transmitted data
                        1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
                        Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>NSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Bit Enable
                        0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
                        1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.</description>
            <name>PBE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Even Parity Enable
                        0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
                        1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
                        This bit has effect only when bit 3 (parity bit enable) is set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>EPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stick Parity Enable 
                        0 = Disable stick parity 
                        1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Control Bit 
                        When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BCB</name>
          </field>
        </fields>
        <name>UA_LCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Modem Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS (Request-To-Send) Signal (not available in UART2 channel)
                        0: Drive RTS pin to logic 1 (If the LEV_RTS set to low level triggered).
                        1: Drive RTS pin to logic 0 (If the LEV_RTS set to low level triggered).
                        0: Drive RTS pin to logic 0 (If the LEV_RTS set to hihg level triggered).
                        1: Drive RTS pin to logic 1 (If the LEV_RTS set to high level triggered).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Trigger Level (not available in UART2 channel)
                        This bit can change the RTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LEV_RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Pin State (not available in UART2 channel)
                        This bit is the output pin status of RTS.</description>
            <name>RTS_ST</name>
          </field>
        </fields>
        <name>UA_MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Modem Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Detect CTS State Change Flag (not available in UART2 channel)
                        This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when UA_IER [Modem_IEN] is set to 1.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>DCTSF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Pin Status (not available in UART2 channel)
                        This bit is the pin status of CTS. </description>
            <name>CTS_ST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Trigger Level (not available in UART2 channel)
                        This bit can change the CTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LEV_CTS</name>
          </field>
        </fields>
        <name>UA_MSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>FIFO Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx overflow Error IF (Read Only) 
                        This bit is set when Rx FIFO overflow.
                        If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 64/16 bytes of (UA_RBR), this bit will be set.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>RX_OVER_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Byte Detection Flag (Read Only) (Low Density Only)
                        This bit is set to logic 1 and set UA_ALT_CSR [RS485_ADD_EN] whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = 1) bit, and it is reset whenever the CPU writes 1 to this bit.
                        NOTE: This field is used for RS-485 function mode.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>RS485_ADD_DETF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>PEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>FEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Interrupt Flag
                        This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>BIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Rx FIFO pointer (Read Only)
                        This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer decreases one.</description>
            <name>RX_POINTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Empty (Read Only)
                        This bit initiate Rx FIFO empty or not.
                        When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
            <name>RX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Full (Read Only)
                        This bit initiates Rx FIFO full or not.
                        This bit is set when RX_POINTER is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>TX FIFO Pointer (Read Only)
                        This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift Register, Tx_Pointer decreases one.</description>
            <name>TX_POINTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Empty (Read Only)
                        This bit indicates Tx FIFO empty or not.
                        When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Full (Read Only)
                        This bit indicates Tx FIFO full or not.
                        This bit is set when Tx_Point is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>TX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Overflow Error Interrupt Flag (Read Only)
                        If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>TX_OVER_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Empty Flag (Read Only)
                        Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte has been transmitted.
                        Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
                        NOTE: This bit is read only. </description>
            <name>TE_FLAG</name>
          </field>
        </fields>
        <name>UA_FSR</name>
        <resetMask>0xEFBFBFFF</resetMask>
        <resetValue>0x10404000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Flag (Read Only).
                        When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
                        NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).</description>
            <name>RDA_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Flag (Read Only). 
                        This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If UA_IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
                        NOTE: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
            <name>THRE_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Interrupt Flag (Read Only).
                        This bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
                        NOTE: When in RS-485 function mode, this field include "receiver detect any address byte received address byte character (bit9 = 1') bit. "</description>
            <name>RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Interrupt Flag (Read Only) (not available in UART2 channel)
                        This bit is set when the CTS pin has state change(DCTSF=1). if UA_IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>MODEM_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Flag (Read Only)
                        This bit is set when the RX FIFO is not empty and no activities occurres in the RX FIFO and the time out counter equal to TOIC. If IER[Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>TOUT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the TX or RX FIFO overflows (TX_Over_IF or RX_Over_IF is set). When BUF_ERR_IF is set, the transfer maybe is not correct. If UA_IER[BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both TX_OVER_IF and RX_OVER_IF are cleared. </description>
            <name>BUF_ERR_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN Bus RX Break Field Detected Flag
                        This bit is set when RX received LIN Break Field. If UA_IER[LIN_RX_BRK_IEN] is enabled the LIN RX Break interrupt will be generated.
                        NOTE: This bit is read only and user can write 1 to clear it.</description>
            <name>LIN_RX_BREAK_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Indicator (INT_RDA).
                        This bit is set if RDA_IEN and RDA_IF are both set to 1.
                        1 = The RDA interrupt is generated.
                        0 = No RDA interrupt is generated .</description>
            <name>RDA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Indicator (INT_THRE).
                        This bit is set if THRE_IEN and THRE_IF are both set to 1.
                        1 = The THRE interrupt is generated.
                        0 = No THRE interrupt is generated.</description>
            <name>THRE_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Indicator to (INT_RLS).
                        This bit is set if RLS_IEN and RLS_IF are both set to 1.
                        1 = The RLS interrupt is generated.
                        0 = No RLS interrupt is generated.</description>
            <name>RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Status Interrupt Indicator to (INT_MOS).
                        This bit is set if MODEM_IEN and MODEM_IF are both set to 1..
                        1 = The Modem interrupt is generated.
                        0 = No Modem interrupt is generated.</description>
            <name>MODEM_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Indicator (INT_Tout)
                        This bit is set if TOUT_IEN and TOUT_IF are both set to 1.
                        1 = The Tout interrupt is generated.
                        0 = No Tout interrupt is generated.</description>
            <name>TOUT_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Indicator (INT_Buf_err)
                        This bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.
                        1 = The buffer error interrupt is generated.
                        0 = No buffer error interrupt is generated.</description>
            <name>BUF_ERR_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-writeOnce</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN Bus Rx Break Field Detected Interrupt Indicator 
                        This bit is set if LIN_RX_BRK_IEN and LIN_RX_BREAK_IF are both set to 1.
                        1 = The LIN RX Break interrupt is generated.
                        0 = No LIN RX Break interrupt is generated.</description>
            <name>LIN_RX_BREAK_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Receive Line Status Flag (Read Only)
                        This bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
            <name>HW_RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, MODEM Interrupt Flag (Read Only) (not available in UART2 channel)
                        This bit is set when the CTS pin has state change(DCTSF=1). if IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>HW_MODEM_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Time out Interrupt Flag (Read Only)
                        This bit is set when the Rx FIFO is not empty and no activities occurres in the Rx FIFO and the time out counter equal to TOIC. If IER[Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>HW_TOUT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When Buf_Err_IF is set, the transfer maybe is not correct. If IER[Buf_Err_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared.</description>
            <name>HW_BUF_ERR_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, LIN Bus Rx Break Field Detect Interrupt Flag
                        This bit is set when Rx received LIN Break Field. If IER[LIN_RX_BRK_IEN] is enabled the LIN RX Break interrupt will be generated.
                        NOTE: This bit is read only and user can write 1 to clear it.</description>
            <name>HW_LIN_RX_BREAK_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Receive Line Status Interrupt Indicator (INT_RLS).
                        This bit is set if RLS_IEN and HW_RLS_IF are both set to 1.
                        1 = The RLS interrupt is generated in DMA mode.
                        0 = No RLS interrupt is generated in DMA mode.</description>
            <name>HW_RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, MODEM Status Interrupt Indicator (INT_MOS)(not available in UART2 channel).
                        This bit is set if MODEM_IEN and HW_MODEM_IF are both set to 1.
                        1 = The Modem interrupt is generated in DMA mode.
                        0 = No Modem interrupt is generated in DMA mode.</description>
            <name>HW_MODEM_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Time Out Interrupt Indicator (INT_Tout)
                        This bit is set if TOUT_IEN and HW_TOUT_IF are both set to 1.
                        1 = The Tout interrupt is generated in DMA mode.
                        0 = No Tout interrupt is generated in DMA mode.</description>
            <name>HW_TOUT_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Buffer Error Interrupt Indicator(INT_Buf_err)
                        This bit is set if BUF_ERR_IEN and HW_BUF_ERR_IF are both set to 1.
                        1 = The buffer error interrupt is generated in DMA mode.
                        0 = No buffer error interrupt is generated in DMA mode.</description>
            <name>HW_BUF_ERR_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, LIN Bus Rx Break Field Detected Interrupt Indicator
                        This bit is set if LIN_RX_BRK_IEN and HW_LIN_RX_BREAK_IF are both set to 1.
                        1 = The LIN RX Break interrupt is generated in DMA mode.
                        0 = No LIN RX Break interrupt is generated in DMA mode.</description>
            <name>HW_LIN_RX_BREAK_INT</name>
          </field>
        </fields>
        <name>UA_ISR</name>
        <resetMask>0xFFFFFFFD</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Time Out Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Time Out Interrupt Comparator
                        The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (INTR_TOUT) is generated if UA_IER [RTO_IEN]. A new incoming data word or RX FIFO empty clears INTR_TOUT.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TOIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX Delay time value (Low Density Only)
                        This field is use to programming the transfer delay time between the last stop bit and next start bit.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DLY</name>
          </field>
        </fields>
        <name>UA_TOR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Baud Rate Divisor Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Baud Rate Divider 
                        The field indicated the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider X
                        The baud rate divider M = X+1.</description>
            <name>DIVIDER_X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X equal 1
                        0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must &gt; =8)
                        1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must &gt;=3).
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <name>DIV_X_ONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X Enable
                        The BRD = Baud Rate Divider, and the baud rate equation is 
                        Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
                        0 = Disable divider X (the equation of M = 16)
                        1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must &gt; =8).
                        NOTE: When in IrDA mode, this bit must disable.
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <name>DIV_X_EN</name>
          </field>
        </fields>
        <name>UA_BAUD</name>
        <resetMask>0xF0FFFFFF</resetMask>
        <resetValue>0xF000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>IrDA Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable IrDA Receiver
                        1: Enable IrDA transmitter
                        0: Enable IrDA receiver</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TX_SELECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_TX
                        1= Inverse TX output signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_RX
                        1= Inverse RX input signal
                        0= No inversion</description>
            <modifiedWriteValues>zeroToSet</modifiedWriteValues>
            <name>INV_RX</name>
          </field>
        </fields>
        <name>UA_IRCR</name>
        <resetMask>0xFFFFFFBF</resetMask>
        <resetValue>0x40</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>LIN Break Failed Count Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>UART LIN Break Field Length
                        This field indicates a 4-bit LIN TX break field count.
                        NOTE: This break field length is UA_LIN_BKFL + 2</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>UA_LIN_BKFL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN RX Enable
                        1 = Enable LIN RX mode.
                        0 = Disable LIN RX mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_RX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN TX Break Mode Enable
                        1 = Enable LIN TX Break mode.
                        0 = Disable LIN TX Break mode.
                        NOTE: When TX break field transfer operation finish, this will be cleared automatically.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_TX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Normal Multi-drop Operation Mode (NMM) (Low Density Only)
                        1 = Enable RS-485 Normal Multi-drop Operation Mode (NMM).
                        0 = Disable RS-485 Normal Multi-drop Operation Mode (NMM).
                        Note: It can't be active with RS485_AAD operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_NMM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Address Detection Operation Mode (AAD) (Low Density Only)
                        1 = Enable RS-485 Auto Address Detection Operation Mode (AAD).
                        0 = Disable RS-485 Auto Address Detection Operation Mode (AAD).
                        Note: It can't be active with RS485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_AAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Direction Mode (AUD) (Low Density Only)
                        1 = Enable RS-485 Auto Direction Operation Mode (AUO).
                        0 = Disable RS-485 Auto Direction Operation Mode (AUO).
                        Note:This field is used for RS-485 any operation mode.
                        Note: It can be active with RS-485_AAD or RS485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_AUD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Detection Enable (Low Density Only)
                        1 = Enable address detection mode.
                        0 = Disable address detection mode.
                        Note: This field is used for RS485 any operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_ADD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Address match value register (Low Density Only)
                        This field contains the RS-485 address match values.
                        Note: This field is used for RS-485 auto address detection mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>ADDR_MATCH</name>
          </field>
        </fields>
        <name>UA_ALT_CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Function Select Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Function Select Enable
                        00 = UART Function
                        01 = Enable LIN Function
                        10 = Enable IrDA Function
                        11 = Enable RS-485 Function (Low Density Only)</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>FUN_SEL</name>
          </field>
        </fields>
        <name>UA_FUN_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40150000</baseAddress>
    <description>Registers group</description>
    <groupName>UART</groupName>
    <interrupts></interrupts>
    <name>UART1</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Receive Buffer Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive Buffer Register
                        By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).</description>
            <name>RBR</name>
            <readAction>modify</readAction>
          </field>
        </fields>
        <name>UA_RBR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Transmit Holding Register.</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit Holding Register
                        By writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>THR</name>
          </field>
        </fields>
        <name>UA_THR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt Enable Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Enable.
                        0 = Mask off INT_RDA
                        1 = Enable INT_RDA</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RDA_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Enable
                        0 = Mask off INT_THRE
                        1 = Enable INT_THRE</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>THRE_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Enable
                        0 = Mask off INT_RLS
                        1 = Enable INT_RLS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RLS_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Modem Status Interrupt Enable
                        0 = Mask off INT_MODEM
                        1 = Enable INT_MODEM</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>MODEM_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Time out Interrupt Enable
                        0 = Mask off INT_TOUT
                        1 = Enable INT_TOUT.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTO_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Enable
                        0 = Mask off INT_Buf_ERR
                        1 = Enable INT_Buf_ERR</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BUF_ERR_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up CPU function enable
                        0 = Disable UART wake up CPU function
                        1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS change will wake up CPU from deep sleep mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WAKE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN RX Break Field Detected Interrupt Enable
                        0 = Mask off Lin bus Rx break filed interrupt.
                        1 = Enable Lin bus Rx break filed interrupt.
                        Note: This field is used for LIN function mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_RX_BRK_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable Time-out counter.
                        0 = Disable Time-out counter.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TIME_OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Auto Flow Control Enable
                        1 = Enable RTS auto flow control.
                        0 = Disable RTS auto flow control.
                        When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR[RTS_Tri_Lev], the UART will de-assert RTS signal.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>AUTO_RTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Auto Flow Control Enable
                        1 = Enable CTS auto flow control.
                        0 = Disable CTS auto flow control.
                        When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>AUTO_CTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX DMA Enable 
                        1 = Enable TX DMA.
                        0 = Disable TX DMA.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DMA_TX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable RX DMA.
                        0 = Disable RX DMA.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DMA_RX_EN</name>
          </field>
        </fields>
        <name>UA_IER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>FIFO Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Field Software Reset
                        When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
                        Note: This bit will auto clear needs at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Field Software Reset
                        When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
                        Note: This bit will auto clear needs at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Rx FIFO Interrupt (INT_RDA) Trigger Level 
                        When the number of bytes in the receive FIFO equals the RFITL then the RDA_IF will be set (if IER [RDA_IEN] is enable, an interrupt will generated).
                        RFITL	INTR_RDA Trigger Level (Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	
                        0100	30/14 (High Speed/Normal Speed)	
                        0101	46/14 (High Speed/Normal Speed)	
                        0110	62/14 (High Speed/Normal Speed)	
                        others	62/14 (High Speed/Normal Speed)	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RFITL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Disable register
                        The receiver is disabled or not (set 1 is disable receiver)
                        1 = Disable Receiver.
                        0 = Enable Receiver.
                        Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RX_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>RTS Trigger Level for Auto-flow Control Use(not available in UART2 channel)
                        RTS_Tri_Lev	Trigger Level (Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	
                        0100	30/14 (High Speed/Normal Speed)	
                        0101	46/14 (High Speed/Normal Speed)	
                        0110	62/14 (High Speed/Normal Speed)	
                        others	62/14 (High Speed/Normal Speed)	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS_TRI_LEV</name>
          </field>
        </fields>
        <name>UA_FCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Line Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Length Select
                        WLS[1:0]	Character length	
                        00	5 bits	
                        01	6 bits	
                        10	7 bits	
                        11	8 bits	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WLS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of "STOP bit"
                        0= One "STOP bit" is generated in the transmitted data
                        1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
                        Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>NSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Bit Enable
                        0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
                        1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.</description>
            <name>PBE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Even Parity Enable
                        0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
                        1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
                        This bit has effect only when bit 3 (parity bit enable) is set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>EPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stick Parity Enable 
                        0 = Disable stick parity 
                        1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Control Bit 
                        When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BCB</name>
          </field>
        </fields>
        <name>UA_LCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Modem Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS (Request-To-Send) Signal (not available in UART2 channel)
                        0: Drive RTS pin to logic 1 (If the LEV_RTS set to low level triggered).
                        1: Drive RTS pin to logic 0 (If the LEV_RTS set to low level triggered).
                        0: Drive RTS pin to logic 0 (If the LEV_RTS set to hihg level triggered).
                        1: Drive RTS pin to logic 1 (If the LEV_RTS set to high level triggered).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Trigger Level (not available in UART2 channel)
                        This bit can change the RTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LEV_RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Pin State (not available in UART2 channel)
                        This bit is the output pin status of RTS.</description>
            <name>RTS_ST</name>
          </field>
        </fields>
        <name>UA_MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Modem Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Detect CTS State Change Flag (not available in UART2 channel)
                        This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when UA_IER [Modem_IEN] is set to 1.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>DCTSF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Pin Status (not available in UART2 channel)
                        This bit is the pin status of CTS. </description>
            <name>CTS_ST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Trigger Level (not available in UART2 channel)
                        This bit can change the CTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LEV_CTS</name>
          </field>
        </fields>
        <name>UA_MSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>FIFO Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx overflow Error IF (Read Only) 
                        This bit is set when Rx FIFO overflow.
                        If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 64/16 bytes of (UA_RBR), this bit will be set.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>RX_OVER_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Byte Detection Flag (Read Only) (Low Density Only)
                        This bit is set to logic 1 and set UA_ALT_CSR [RS485_ADD_EN] whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = 1) bit, and it is reset whenever the CPU writes 1 to this bit.
                        NOTE: This field is used for RS-485 function mode.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>RS485_ADD_DETF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>PEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>FEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Interrupt Flag
                        This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>BIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Rx FIFO pointer (Read Only)
                        This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer decreases one.</description>
            <name>RX_POINTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Empty (Read Only)
                        This bit initiate Rx FIFO empty or not.
                        When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
            <name>RX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Full (Read Only)
                        This bit initiates Rx FIFO full or not.
                        This bit is set when RX_POINTER is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>TX FIFO Pointer (Read Only)
                        This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift Register, Tx_Pointer decreases one.</description>
            <name>TX_POINTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Empty (Read Only)
                        This bit indicates Tx FIFO empty or not.
                        When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Full (Read Only)
                        This bit indicates Tx FIFO full or not.
                        This bit is set when Tx_Point is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>TX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Overflow Error Interrupt Flag (Read Only)
                        If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>TX_OVER_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Empty Flag (Read Only)
                        Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte has been transmitted.
                        Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
                        NOTE: This bit is read only. </description>
            <name>TE_FLAG</name>
          </field>
        </fields>
        <name>UA_FSR</name>
        <resetMask>0xEFBFBFFF</resetMask>
        <resetValue>0x10404000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Flag (Read Only).
                        When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
                        NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).</description>
            <name>RDA_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Flag (Read Only). 
                        This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If UA_IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
                        NOTE: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
            <name>THRE_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Interrupt Flag (Read Only).
                        This bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
                        NOTE: When in RS-485 function mode, this field include "receiver detect any address byte received address byte character (bit9 = 1') bit. "</description>
            <name>RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Interrupt Flag (Read Only) (not available in UART2 channel)
                        This bit is set when the CTS pin has state change(DCTSF=1). if UA_IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>MODEM_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Flag (Read Only)
                        This bit is set when the RX FIFO is not empty and no activities occurres in the RX FIFO and the time out counter equal to TOIC. If IER[Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>TOUT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the TX or RX FIFO overflows (TX_Over_IF or RX_Over_IF is set). When BUF_ERR_IF is set, the transfer maybe is not correct. If UA_IER[BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both TX_OVER_IF and RX_OVER_IF are cleared. </description>
            <name>BUF_ERR_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN Bus RX Break Field Detected Flag
                        This bit is set when RX received LIN Break Field. If UA_IER[LIN_RX_BRK_IEN] is enabled the LIN RX Break interrupt will be generated.
                        NOTE: This bit is read only and user can write 1 to clear it.</description>
            <name>LIN_RX_BREAK_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Indicator (INT_RDA).
                        This bit is set if RDA_IEN and RDA_IF are both set to 1.
                        1 = The RDA interrupt is generated.
                        0 = No RDA interrupt is generated .</description>
            <name>RDA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Indicator (INT_THRE).
                        This bit is set if THRE_IEN and THRE_IF are both set to 1.
                        1 = The THRE interrupt is generated.
                        0 = No THRE interrupt is generated.</description>
            <name>THRE_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Indicator to (INT_RLS).
                        This bit is set if RLS_IEN and RLS_IF are both set to 1.
                        1 = The RLS interrupt is generated.
                        0 = No RLS interrupt is generated.</description>
            <name>RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Status Interrupt Indicator to (INT_MOS).
                        This bit is set if MODEM_IEN and MODEM_IF are both set to 1..
                        1 = The Modem interrupt is generated.
                        0 = No Modem interrupt is generated.</description>
            <name>MODEM_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Indicator (INT_Tout)
                        This bit is set if TOUT_IEN and TOUT_IF are both set to 1.
                        1 = The Tout interrupt is generated.
                        0 = No Tout interrupt is generated.</description>
            <name>TOUT_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Indicator (INT_Buf_err)
                        This bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.
                        1 = The buffer error interrupt is generated.
                        0 = No buffer error interrupt is generated.</description>
            <name>BUF_ERR_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-writeOnce</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN Bus Rx Break Field Detected Interrupt Indicator 
                        This bit is set if LIN_RX_BRK_IEN and LIN_RX_BREAK_IF are both set to 1.
                        1 = The LIN RX Break interrupt is generated.
                        0 = No LIN RX Break interrupt is generated.</description>
            <name>LIN_RX_BREAK_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Receive Line Status Flag (Read Only)
                        This bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
            <name>HW_RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, MODEM Interrupt Flag (Read Only) (not available in UART2 channel)
                        This bit is set when the CTS pin has state change(DCTSF=1). if IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>HW_MODEM_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Time out Interrupt Flag (Read Only)
                        This bit is set when the Rx FIFO is not empty and no activities occurres in the Rx FIFO and the time out counter equal to TOIC. If IER[Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>HW_TOUT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When Buf_Err_IF is set, the transfer maybe is not correct. If IER[Buf_Err_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared.</description>
            <name>HW_BUF_ERR_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, LIN Bus Rx Break Field Detect Interrupt Flag
                        This bit is set when Rx received LIN Break Field. If IER[LIN_RX_BRK_IEN] is enabled the LIN RX Break interrupt will be generated.
                        NOTE: This bit is read only and user can write 1 to clear it.</description>
            <name>HW_LIN_RX_BREAK_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Receive Line Status Interrupt Indicator (INT_RLS).
                        This bit is set if RLS_IEN and HW_RLS_IF are both set to 1.
                        1 = The RLS interrupt is generated in DMA mode.
                        0 = No RLS interrupt is generated in DMA mode.</description>
            <name>HW_RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, MODEM Status Interrupt Indicator (INT_MOS)(not available in UART2 channel).
                        This bit is set if MODEM_IEN and HW_MODEM_IF are both set to 1.
                        1 = The Modem interrupt is generated in DMA mode.
                        0 = No Modem interrupt is generated in DMA mode.</description>
            <name>HW_MODEM_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Time Out Interrupt Indicator (INT_Tout)
                        This bit is set if TOUT_IEN and HW_TOUT_IF are both set to 1.
                        1 = The Tout interrupt is generated in DMA mode.
                        0 = No Tout interrupt is generated in DMA mode.</description>
            <name>HW_TOUT_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Buffer Error Interrupt Indicator(INT_Buf_err)
                        This bit is set if BUF_ERR_IEN and HW_BUF_ERR_IF are both set to 1.
                        1 = The buffer error interrupt is generated in DMA mode.
                        0 = No buffer error interrupt is generated in DMA mode.</description>
            <name>HW_BUF_ERR_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, LIN Bus Rx Break Field Detected Interrupt Indicator
                        This bit is set if LIN_RX_BRK_IEN and HW_LIN_RX_BREAK_IF are both set to 1.
                        1 = The LIN RX Break interrupt is generated in DMA mode.
                        0 = No LIN RX Break interrupt is generated in DMA mode.</description>
            <name>HW_LIN_RX_BREAK_INT</name>
          </field>
        </fields>
        <name>UA_ISR</name>
        <resetMask>0xFFFFFFFD</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Time Out Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Time Out Interrupt Comparator
                        The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (INTR_TOUT) is generated if UA_IER [RTO_IEN]. A new incoming data word or RX FIFO empty clears INTR_TOUT.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TOIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX Delay time value (Low Density Only)
                        This field is use to programming the transfer delay time between the last stop bit and next start bit.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DLY</name>
          </field>
        </fields>
        <name>UA_TOR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Baud Rate Divisor Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Baud Rate Divider 
                        The field indicated the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider X
                        The baud rate divider M = X+1.</description>
            <name>DIVIDER_X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X equal 1
                        0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must &gt; =8)
                        1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must &gt;=3).
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <name>DIV_X_ONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X Enable
                        The BRD = Baud Rate Divider, and the baud rate equation is 
                        Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
                        0 = Disable divider X (the equation of M = 16)
                        1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must &gt; =8).
                        NOTE: When in IrDA mode, this bit must disable.
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <name>DIV_X_EN</name>
          </field>
        </fields>
        <name>UA_BAUD</name>
        <resetMask>0xF0FFFFFF</resetMask>
        <resetValue>0xF000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>IrDA Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable IrDA Receiver
                        1: Enable IrDA transmitter
                        0: Enable IrDA receiver</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TX_SELECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_TX
                        1= Inverse TX output signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_RX
                        1= Inverse RX input signal
                        0= No inversion</description>
            <modifiedWriteValues>zeroToSet</modifiedWriteValues>
            <name>INV_RX</name>
          </field>
        </fields>
        <name>UA_IRCR</name>
        <resetMask>0xFFFFFFBF</resetMask>
        <resetValue>0x40</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>LIN Break Failed Count Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>UART LIN Break Field Length
                        This field indicates a 4-bit LIN TX break field count.
                        NOTE: This break field length is UA_LIN_BKFL + 2</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>UA_LIN_BKFL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN RX Enable
                        1 = Enable LIN RX mode.
                        0 = Disable LIN RX mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_RX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN TX Break Mode Enable
                        1 = Enable LIN TX Break mode.
                        0 = Disable LIN TX Break mode.
                        NOTE: When TX break field transfer operation finish, this will be cleared automatically.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_TX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Normal Multi-drop Operation Mode (NMM) (Low Density Only)
                        1 = Enable RS-485 Normal Multi-drop Operation Mode (NMM).
                        0 = Disable RS-485 Normal Multi-drop Operation Mode (NMM).
                        Note: It can't be active with RS485_AAD operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_NMM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Address Detection Operation Mode (AAD) (Low Density Only)
                        1 = Enable RS-485 Auto Address Detection Operation Mode (AAD).
                        0 = Disable RS-485 Auto Address Detection Operation Mode (AAD).
                        Note: It can't be active with RS485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_AAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Direction Mode (AUD) (Low Density Only)
                        1 = Enable RS-485 Auto Direction Operation Mode (AUO).
                        0 = Disable RS-485 Auto Direction Operation Mode (AUO).
                        Note:This field is used for RS-485 any operation mode.
                        Note: It can be active with RS-485_AAD or RS485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_AUD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Detection Enable (Low Density Only)
                        1 = Enable address detection mode.
                        0 = Disable address detection mode.
                        Note: This field is used for RS485 any operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_ADD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Address match value register (Low Density Only)
                        This field contains the RS-485 address match values.
                        Note: This field is used for RS-485 auto address detection mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>ADDR_MATCH</name>
          </field>
        </fields>
        <name>UA_ALT_CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Function Select Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Function Select Enable
                        00 = UART Function
                        01 = Enable LIN Function
                        10 = Enable IrDA Function
                        11 = Enable RS-485 Function (Low Density Only)</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>FUN_SEL</name>
          </field>
        </fields>
        <name>UA_FUN_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x34</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40154000</baseAddress>
    <description>Registers group</description>
    <groupName>UART</groupName>
    <interrupts></interrupts>
    <name>UART2</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x0</addressOffset>
        <description>Receive Buffer Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Receive Buffer Register
                        By reading this register, the UART will return an 8-bit data received from Rx pin (LSB first).</description>
            <name>RBR</name>
            <readAction>modify</readAction>
          </field>
        </fields>
        <name>UA_RBR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Transmit Holding Register.</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Transmit Holding Register
                        By writing to this register, the UART will send out an 8-bit data through the TX pin (LSB first).</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>THR</name>
          </field>
        </fields>
        <name>UA_THR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt Enable Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Enable.
                        0 = Mask off INT_RDA
                        1 = Enable INT_RDA</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RDA_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Enable
                        0 = Mask off INT_THRE
                        1 = Enable INT_THRE</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>THRE_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Enable
                        0 = Mask off INT_RLS
                        1 = Enable INT_RLS</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RLS_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Modem Status Interrupt Enable
                        0 = Mask off INT_MODEM
                        1 = Enable INT_MODEM</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>MODEM_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Time out Interrupt Enable
                        0 = Mask off INT_TOUT
                        1 = Enable INT_TOUT.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTO_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Enable
                        0 = Mask off INT_Buf_ERR
                        1 = Enable INT_Buf_ERR</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BUF_ERR_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake up CPU function enable
                        0 = Disable UART wake up CPU function
                        1 = Enable wake up function, when the system is in deep sleep mode, an external /CTS change will wake up CPU from deep sleep mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WAKE_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN RX Break Field Detected Interrupt Enable
                        0 = Mask off Lin bus Rx break filed interrupt.
                        1 = Enable Lin bus Rx break filed interrupt.
                        Note: This field is used for LIN function mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_RX_BRK_IEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable Time-out counter.
                        0 = Disable Time-out counter.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TIME_OUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Auto Flow Control Enable
                        1 = Enable RTS auto flow control.
                        0 = Disable RTS auto flow control.
                        When RTS auto-flow is enabled, if the number of bytes in the Rx FIFO equals the UA_FCR[RTS_Tri_Lev], the UART will de-assert RTS signal.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>AUTO_RTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Auto Flow Control Enable
                        1 = Enable CTS auto flow control.
                        0 = Disable CTS auto flow control.
                        When CTS auto-flow is enabled, the UART will send data to external device when CTS input assert (UART will not send data to device until CTS is asserted).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>AUTO_CTS_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>TX DMA Enable 
                        1 = Enable TX DMA.
                        0 = Disable TX DMA.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DMA_TX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time-Out Counter Enable
                        1 = Enable RX DMA.
                        0 = Disable RX DMA.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DMA_RX_EN</name>
          </field>
        </fields>
        <name>UA_IER</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>FIFO Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx Field Software Reset
                        When Rx_RST is set, all the bytes in the transmit FIFO and Rx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Rx internal state machine and pointers.
                        Note: This bit will auto clear needs at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>RFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Field Software Reset
                        When Tx_RST is set, all the bytes in the transmit FIFO and Tx internal state machine are cleared.
                        0 = Writing 0 to this bit has no effect.
                        1 = Writing 1 to this bit will reset the Tx internal state machine and pointers.
                        Note: This bit will auto clear needs at least 3 UART engine clock cycles.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>TFR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Rx FIFO Interrupt (INT_RDA) Trigger Level 
                        When the number of bytes in the receive FIFO equals the RFITL then the RDA_IF will be set (if IER [RDA_IEN] is enable, an interrupt will generated).
                        RFITL	INTR_RDA Trigger Level (Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	
                        0100	30/14 (High Speed/Normal Speed)	
                        0101	46/14 (High Speed/Normal Speed)	
                        0110	62/14 (High Speed/Normal Speed)	
                        others	62/14 (High Speed/Normal Speed)	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RFITL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Disable register
                        The receiver is disabled or not (set 1 is disable receiver)
                        1 = Disable Receiver.
                        0 = Enable Receiver.
                        Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before UA_ALT_CSR [RS-485_NMM] is programmed.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RX_DIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>RTS Trigger Level for Auto-flow Control Use(not available in UART2 channel)
                        RTS_Tri_Lev	Trigger Level (Bytes)	
                        0000	01	
                        0001	04	
                        0010	08	
                        0011	14	
                        0100	30/14 (High Speed/Normal Speed)	
                        0101	46/14 (High Speed/Normal Speed)	
                        0110	62/14 (High Speed/Normal Speed)	
                        others	62/14 (High Speed/Normal Speed)	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS_TRI_LEV</name>
          </field>
        </fields>
        <name>UA_FCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Line Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Word Length Select
                        WLS[1:0]	Character length	
                        00	5 bits	
                        01	6 bits	
                        10	7 bits	
                        11	8 bits	</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>WLS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of "STOP bit"
                        0= One "STOP bit" is generated in the transmitted data
                        1= One and a half "STOP bit" is generated in the transmitted data when 5-bit word length is selected;
                        Two "STOP bit" is generated when 6-, 7- and 8-bit word length is selected.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>NSB</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Bit Enable
                        0 = Parity bit is not generated (transmit data) or checked (receive data) during transfer.
                        1 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the serial data.</description>
            <name>PBE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Even Parity Enable
                        0 = Odd number of logic 1's are transmitted or checked in the data word and parity bits.
                        1 = Even number of logic 1's are transmitted or checked in the data word and parity bits.
                        This bit has effect only when bit 3 (parity bit enable) is set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>EPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stick Parity Enable 
                        0 = Disable stick parity 
                        1 = When bits PBE , EPE and SPE are set, the parity bit is transmitted and checked as cleared. When PBE and SPE are set and EPE is cleared, the parity bit is transmitted and checked as set.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>SPE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Control Bit 
                        When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State (logic 0). This bit acts only on TX and has no effect on the transmitter logic.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BCB</name>
          </field>
        </fields>
        <name>UA_LCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Modem Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS (Request-To-Send) Signal (not available in UART2 channel)
                        0: Drive RTS pin to logic 1 (If the LEV_RTS set to low level triggered).
                        1: Drive RTS pin to logic 0 (If the LEV_RTS set to low level triggered).
                        0: Drive RTS pin to logic 0 (If the LEV_RTS set to hihg level triggered).
                        1: Drive RTS pin to logic 1 (If the LEV_RTS set to high level triggered).</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Trigger Level (not available in UART2 channel)
                        This bit can change the RTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LEV_RTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RTS Pin State (not available in UART2 channel)
                        This bit is the output pin status of RTS.</description>
            <name>RTS_ST</name>
          </field>
        </fields>
        <name>UA_MCR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Modem Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Detect CTS State Change Flag (not available in UART2 channel)
                        This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU when UA_IER [Modem_IEN] is set to 1.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>DCTSF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Pin Status (not available in UART2 channel)
                        This bit is the pin status of CTS. </description>
            <name>CTS_ST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Trigger Level (not available in UART2 channel)
                        This bit can change the CTS trigger level.
                        0= low level triggered
                        1= high level triggered</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LEV_CTS</name>
          </field>
        </fields>
        <name>UA_MSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>FIFO Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Rx overflow Error IF (Read Only) 
                        This bit is set when Rx FIFO overflow.
                        If the number of bytes of received data is greater than Rx FIFO(UA_RBR) size, 64/16 bytes of (UA_RBR), this bit will be set.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>RX_OVER_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Byte Detection Flag (Read Only) (Low Density Only)
                        This bit is set to logic 1 and set UA_ALT_CSR [RS485_ADD_EN] whenever in RS-485 mode the receiver detect any address byte received address byte character (bit9 = 1) bit, and it is reset whenever the CPU writes 1 to this bit.
                        NOTE: This field is used for RS-485 function mode.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>RS485_ADD_DETF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "parity bit", and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>PEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error Flag
                        This bit is set to logic 1 whenever the received character does not have a valid "stop bit" (that is, the stop bit following the last data bit or parity bit is detected as a logic 0), and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>FEF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Interrupt Flag
                        This bit is set to a logic 1 whenever the received data input(Rx) is held in the "spacing state" (logic 0) for longer than a full word transmission time (that is, the total time of "start bit" + data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>BIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Rx FIFO pointer (Read Only)
                        This field indicates the Rx FIFO Buffer Pointer. When UART receives one byte from external device, Rx_Pointer increases one. When one byte of Rx FIFO is read by CPU, Rx_Pointer decreases one.</description>
            <name>RX_POINTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Empty (Read Only)
                        This bit initiate Rx FIFO empty or not.
                        When the last byte of Rx FIFO has been read by CPU, hardware sets this bit high. It will be cleared when UART receives any new data.</description>
            <name>RX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver FIFO Full (Read Only)
                        This bit initiates Rx FIFO full or not.
                        This bit is set when RX_POINTER is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>RX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>TX FIFO Pointer (Read Only)
                        This field indicates the Tx FIFO Buffer Pointer. When CPU write one byte into UA_THR, Tx_Pointer increases one. When one byte of Tx FIFO is transferred to Transmitter Shift Register, Tx_Pointer decreases one.</description>
            <name>TX_POINTER</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Empty (Read Only)
                        This bit indicates Tx FIFO empty or not.
                        When the last byte of Tx FIFO has been transferred to Transmitter Shift Register, hardware sets this bit high. It will be cleared when writing data into THR (Tx FIFO not empty).</description>
            <name>TX_EMPTY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter FIFO Full (Read Only)
                        This bit indicates Tx FIFO full or not.
                        This bit is set when Tx_Point is equal to 64/16(UART0/UART1), otherwise is cleared by hardware.</description>
            <name>TX_FULL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Tx Overflow Error Interrupt Flag (Read Only)
                        If Tx FIFO(UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1. 
                        NOTE: This bit is read only, but can be cleared by writing '1' to it.</description>
            <name>TX_OVER_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Empty Flag (Read Only)
                        Bit is set by hardware when Tx FIFO(UA_THR) is empty and the STOP bit of the last byte has been transmitted.
                        Bit is cleared automatically when Tx FIFO is not empty or the last byte transmission has not completed.
                        NOTE: This bit is read only. </description>
            <name>TE_FLAG</name>
          </field>
        </fields>
        <name>UA_FSR</name>
        <resetMask>0xEFBFBFFF</resetMask>
        <resetValue>0x10404000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Interrupt Status Register.</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Flag (Read Only).
                        When the number of bytes in the Rx FIFO equals the RFITL then the RDA_IF will be set. If IER[RDA_IEN] is enabled, the RDA interrupt will be generated. 
                        NOTE: This bit is read only and it will be cleared when the number of unread bytes of Rx FIFO drops below the threshold level (RFITL).</description>
            <name>RDA_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Flag (Read Only). 
                        This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register. If UA_IER[THRE_IEN] is enabled, the THRE interrupt will be generated.
                        NOTE: This bit is read only and it will be cleared when writing data into THR (TX FIFO not empty).</description>
            <name>THRE_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Interrupt Flag (Read Only).
                        This bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.
                        NOTE: When in RS-485 function mode, this field include "receiver detect any address byte received address byte character (bit9 = 1') bit. "</description>
            <name>RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Interrupt Flag (Read Only) (not available in UART2 channel)
                        This bit is set when the CTS pin has state change(DCTSF=1). if UA_IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>MODEM_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Flag (Read Only)
                        This bit is set when the RX FIFO is not empty and no activities occurres in the RX FIFO and the time out counter equal to TOIC. If IER[Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>TOUT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the TX or RX FIFO overflows (TX_Over_IF or RX_Over_IF is set). When BUF_ERR_IF is set, the transfer maybe is not correct. If UA_IER[BUF_ERR_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both TX_OVER_IF and RX_OVER_IF are cleared. </description>
            <name>BUF_ERR_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN Bus RX Break Field Detected Flag
                        This bit is set when RX received LIN Break Field. If UA_IER[LIN_RX_BRK_IEN] is enabled the LIN RX Break interrupt will be generated.
                        NOTE: This bit is read only and user can write 1 to clear it.</description>
            <name>LIN_RX_BREAK_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Data Available Interrupt Indicator (INT_RDA).
                        This bit is set if RDA_IEN and RDA_IF are both set to 1.
                        1 = The RDA interrupt is generated.
                        0 = No RDA interrupt is generated .</description>
            <name>RDA_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Holding Register Empty Interrupt Indicator (INT_THRE).
                        This bit is set if THRE_IEN and THRE_IF are both set to 1.
                        1 = The THRE interrupt is generated.
                        0 = No THRE interrupt is generated.</description>
            <name>THRE_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Line Status Interrupt Indicator to (INT_RLS).
                        This bit is set if RLS_IEN and RLS_IF are both set to 1.
                        1 = The RLS interrupt is generated.
                        0 = No RLS interrupt is generated.</description>
            <name>RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>MODEM Status Interrupt Indicator to (INT_MOS).
                        This bit is set if MODEM_IEN and MODEM_IF are both set to 1..
                        1 = The Modem interrupt is generated.
                        0 = No Modem interrupt is generated.</description>
            <name>MODEM_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Time Out Interrupt Indicator (INT_Tout)
                        This bit is set if TOUT_IEN and TOUT_IF are both set to 1.
                        1 = The Tout interrupt is generated.
                        0 = No Tout interrupt is generated.</description>
            <name>TOUT_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Buffer Error Interrupt Indicator (INT_Buf_err)
                        This bit is set if BUF_ERR_IEN and BUF_ERR_IF are both set to 1.
                        1 = The buffer error interrupt is generated.
                        0 = No buffer error interrupt is generated.</description>
            <name>BUF_ERR_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-writeOnce</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN Bus Rx Break Field Detected Interrupt Indicator 
                        This bit is set if LIN_RX_BRK_IEN and LIN_RX_BREAK_IF are both set to 1.
                        1 = The LIN RX Break interrupt is generated.
                        0 = No LIN RX Break interrupt is generated.</description>
            <name>LIN_RX_BREAK_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Receive Line Status Flag (Read Only)
                        This bit is set when the Rx receive data have parity error, framing error or break error (at least one of 3 bits, BIF, FEF and PEF, is set). If IER[RLS_IEN] is enabled, the RLS interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when all bits of BIF, FEF and PEF are cleared.</description>
            <name>HW_RLS_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, MODEM Interrupt Flag (Read Only) (not available in UART2 channel)
                        This bit is set when the CTS pin has state change(DCTSF=1). if IER[Modem_IEN] is enabled, the Modem interrupt will be generated.
                        NOTE: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on DCTSF.</description>
            <name>HW_MODEM_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Time out Interrupt Flag (Read Only)
                        This bit is set when the Rx FIFO is not empty and no activities occurres in the Rx FIFO and the time out counter equal to TOIC. If IER[Tout_IEN] is enabled, the Tout interrupt will be generated. 
                        NOTE: This bit is read only and user can read UA_RBR (Rx is in active) to clear it.</description>
            <name>HW_TOUT_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Buffer Error Interrupt Flag (Read Only)
                        This bit is set when the Tx or Rx FIFO overflows (Tx_Over_IF or Rx_Over_IF is set). When Buf_Err_IF is set, the transfer maybe is not correct. If IER[Buf_Err_IEN] is enabled, the buffer error interrupt will be generated.
                        NOTE: This bit is cleared when both Tx_Over_IF and Rx_Over_IF are cleared.</description>
            <name>HW_BUF_ERR_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, LIN Bus Rx Break Field Detect Interrupt Flag
                        This bit is set when Rx received LIN Break Field. If IER[LIN_RX_BRK_IEN] is enabled the LIN RX Break interrupt will be generated.
                        NOTE: This bit is read only and user can write 1 to clear it.</description>
            <name>HW_LIN_RX_BREAK_IF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Receive Line Status Interrupt Indicator (INT_RLS).
                        This bit is set if RLS_IEN and HW_RLS_IF are both set to 1.
                        1 = The RLS interrupt is generated in DMA mode.
                        0 = No RLS interrupt is generated in DMA mode.</description>
            <name>HW_RLS_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1B</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, MODEM Status Interrupt Indicator (INT_MOS)(not available in UART2 channel).
                        This bit is set if MODEM_IEN and HW_MODEM_IF are both set to 1.
                        1 = The Modem interrupt is generated in DMA mode.
                        0 = No Modem interrupt is generated in DMA mode.</description>
            <name>HW_MODEM_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Time Out Interrupt Indicator (INT_Tout)
                        This bit is set if TOUT_IEN and HW_TOUT_IF are both set to 1.
                        1 = The Tout interrupt is generated in DMA mode.
                        0 = No Tout interrupt is generated in DMA mode.</description>
            <name>HW_TOUT_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, Buffer Error Interrupt Indicator(INT_Buf_err)
                        This bit is set if BUF_ERR_IEN and HW_BUF_ERR_IF are both set to 1.
                        1 = The buffer error interrupt is generated in DMA mode.
                        0 = No buffer error interrupt is generated in DMA mode.</description>
            <name>HW_BUF_ERR_INT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>In DMA mode, LIN Bus Rx Break Field Detected Interrupt Indicator
                        This bit is set if LIN_RX_BRK_IEN and HW_LIN_RX_BREAK_IF are both set to 1.
                        1 = The LIN RX Break interrupt is generated in DMA mode.
                        0 = No LIN RX Break interrupt is generated in DMA mode.</description>
            <name>HW_LIN_RX_BREAK_INT</name>
          </field>
        </fields>
        <name>UA_ISR</name>
        <resetMask>0xFFFFFFFD</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Time Out Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Time Out Interrupt Comparator
                        The time out counter resets and starts counting (the counting clock = baud rate) whenever the RX FIFO receives a new data word. Once the content of time out counter (TOUT_CNT) is equal to that of time out interrupt comparator (TOIC), a receiver time out interrupt (INTR_TOUT) is generated if UA_IER [RTO_IEN]. A new incoming data word or RX FIFO empty clears INTR_TOUT.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TOIC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>TX Delay time value (Low Density Only)
                        This field is use to programming the transfer delay time between the last stop bit and next start bit.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>DLY</name>
          </field>
        </fields>
        <name>UA_TOR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Baud Rate Divisor Register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Baud Rate Divider 
                        The field indicated the baud rate divider</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>BRD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Divider X
                        The baud rate divider M = X+1.</description>
            <name>DIVIDER_X</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1C</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X equal 1
                        0 = Divider M = X (the equation of M = X+1, but Divider_X[27:24] must &gt; =8)
                        1 = Divider M = 1 (the equation of M = 1, but BRD[15:0] must &gt;=3).
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <name>DIV_X_ONE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Divider X Enable
                        The BRD = Baud Rate Divider, and the baud rate equation is 
                        Baud Rate = Clock / [ M * (BRD + 2) ] ; The default value of M is 16.
                        0 = Disable divider X (the equation of M = 16)
                        1 = Enable divider X (the equation of M = X+1, but Divider_X[27:24 must &gt; =8).
                        NOTE: When in IrDA mode, this bit must disable.
                        Mode	DIV_X_EN 	DIV_X_ONE 	DIVIDER X 	BRD 	Baud rate equation 	
                        0 	Disable 	0 	B	A	UART_CLK / [16 * (A+2)]	
                        1 	Enable 	0 	B	A	UART_CLK/[(B+1)*(A+2)],B must &gt;= 8	
                        2 	Enable 	1	Don't Care	A	UART_CLK / (A+2), A must &gt;=3	</description>
            <name>DIV_X_EN</name>
          </field>
        </fields>
        <name>UA_BAUD</name>
        <resetMask>0xF0FFFFFF</resetMask>
        <resetValue>0xF000000</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>IrDA Control Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable IrDA Receiver
                        1: Enable IrDA transmitter
                        0: Enable IrDA receiver</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>TX_SELECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_TX
                        1= Inverse TX output signal
                        0= No inversion</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>INV_TX</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>INV_RX
                        1= Inverse RX input signal
                        0= No inversion</description>
            <modifiedWriteValues>zeroToSet</modifiedWriteValues>
            <name>INV_RX</name>
          </field>
        </fields>
        <name>UA_IRCR</name>
        <resetMask>0xFFFFFFBF</resetMask>
        <resetValue>0x40</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>LIN Break Failed Count Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>UART LIN Break Field Length
                        This field indicates a 4-bit LIN TX break field count.
                        NOTE: This break field length is UA_LIN_BKFL + 2</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>UA_LIN_BKFL</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN RX Enable
                        1 = Enable LIN RX mode.
                        0 = Disable LIN RX mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_RX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LIN TX Break Mode Enable
                        1 = Enable LIN TX Break mode.
                        0 = Disable LIN TX Break mode.
                        NOTE: When TX break field transfer operation finish, this will be cleared automatically.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>LIN_TX_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Normal Multi-drop Operation Mode (NMM) (Low Density Only)
                        1 = Enable RS-485 Normal Multi-drop Operation Mode (NMM).
                        0 = Disable RS-485 Normal Multi-drop Operation Mode (NMM).
                        Note: It can't be active with RS485_AAD operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_NMM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Address Detection Operation Mode (AAD) (Low Density Only)
                        1 = Enable RS-485 Auto Address Detection Operation Mode (AAD).
                        0 = Disable RS-485 Auto Address Detection Operation Mode (AAD).
                        Note: It can't be active with RS485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_AAD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Auto Direction Mode (AUD) (Low Density Only)
                        1 = Enable RS-485 Auto Direction Operation Mode (AUO).
                        0 = Disable RS-485 Auto Direction Operation Mode (AUO).
                        Note:This field is used for RS-485 any operation mode.
                        Note: It can be active with RS-485_AAD or RS485_NMM operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_AUD</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>RS-485 Address Detection Enable (Low Density Only)
                        1 = Enable address detection mode.
                        0 = Disable address detection mode.
                        Note: This field is used for RS485 any operation mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>RS485_ADD_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Address match value register (Low Density Only)
                        This field contains the RS-485 address match values.
                        Note: This field is used for RS-485 auto address detection mode.</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>ADDR_MATCH</name>
          </field>
        </fields>
        <name>UA_ALT_CSR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Function Select Register.</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Function Select Enable
                        00 = UART Function
                        01 = Enable LIN Function
                        10 = Enable IrDA Function
                        11 = Enable RS-485 Function (Low Density Only)</description>
            <modifiedWriteValues>oneToSet</modifiedWriteValues>
            <name>FUN_SEL</name>
          </field>
        </fields>
        <name>UA_FUN_SEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x1C</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40060000</baseAddress>
    <description>Registers group</description>
    <groupName>USB</groupName>
    <interrupts></interrupts>
    <name>USB</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Interrupt Enable Flag</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1/0: Enable/disable BUS event interrupt.</description>
            <name>BUS_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1/0: Enable/disable USB event interrupt.</description>
            <name>USB_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1/0: Enable/disable Floating detect Interrupt</description>
            <name>FLDET_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1/0: Enable/disable Wakeup Interrupt.</description>
            <name>WAKEUP_IE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1/0: Enable/Disable USB wakeup function</description>
            <name>WAKEUP_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = The NAK status is updated into the endpoint status register, USB_EPSTS, when it is set to 1 and there is NAK response in IN token. It also enable the interrupt event when the device responds NAK after receiving IN token.
                        0 = The NAK status doesn't be updated into the endpoint status register when it was set to 0. It also disable the interrupt event when device responds NAK after receiving IN token</description>
            <name>INNAK_EN</name>
          </field>
        </fields>
        <name>USB_INTEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Interrupt Event Flag</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The BUS event means that there is one of the suspense or the resume function in the bus.
                        1 = Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred, cleared by write 1 to USB_INTSTS[0].
                        0 = No any BUS event is occurred</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>BUS_STS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The USB event includes the Setup Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
                        1 = USB event occurred, check EPSTS0~5[2:0] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[1] or EPSTS0~5 and SETUP (USB_INTSTS[31])
                        0 = No any USB event is occurred</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>USB_STS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = There is attached/detached event in the USB bus and it is cleared by write 1 to USB_INTSTS[2].
                        0 = There is not attached/detached event in the USB</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>FLDET_STS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Wakeup event occurred, cleared by write 1 to USB_INTSTS[3]
                        0 = No Wakeup event is occurred</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WAKEUP_STS</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1]
                        0 = No event occurred in endpoint 0</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>EPEVT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1]
                        0 = No event occurred in endpoint 1</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>EPEVT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1]
                        0 = No event occurred in endpoint 2</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>EPEVT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1]
                        0 = No event occurred in endpoint 3</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>EPEVT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1]
                        0 = No event occurred in endpoint 4</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>EPEVT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1]
                        0 = No event occurred in endpoint 5</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>EPEVT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Setup event occurred, cleared by write 1 to USB_INTSTS[31]
                        0 = No Setup event</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>SETUP</name>
          </field>
        </fields>
        <name>USB_INTSTS</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Function Address</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Function Address of this USB device.</description>
            <name>FADDR</name>
          </field>
        </fields>
        <name>USB_FADDR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>System state</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>It indicates that the received data is over the maximum payload number or not.
                        1 = It indicates that the Out Data more than the Max Payload in MXPLD register or the Setup Data more than 8 Bytes
                        0 = No overrun</description>
            <name>OVERRUN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>These bits are used to indicate the current status of this endpoint
                        000 = In ACK
                        001 = In NAK
                        010 = Out Packet Data0 ACK
                        110 = Out Packet Data1 ACK
                        011 = Setup ACK
                        111 = Isochronous transfer end</description>
            <name>EPSTS0</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>These bits are used to indicate the current status of this endpoint
                        000 = In ACK
                        001 = In NAK
                        010 = Out Packet Data0 ACK
                        110 = Out Packet Data1 ACK
                        011 = Setup ACK
                        111 = Isochronous transfer end</description>
            <name>EPSTS1</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>These bits are used to indicate the current status of this endpoint
                        000 = In ACK
                        001 = In NAK
                        010 = Out Packet Data0 ACK
                        110 = Out Packet Data1 ACK
                        011 = Setup ACK
                        111 = Isochronous transfer end</description>
            <name>EPSTS2</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>These bits are used to indicate the current status of this endpoint
                        000 = In ACK
                        001 = In NAK
                        010 = Out Packet Data0 ACK
                        110 = Out Packet Data1 ACK
                        011 = Setup ACK
                        111 = Isochronous transfer end</description>
            <name>EPSTS3</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>These bits are used to indicate the current status of this endpoint
                        000 = In ACK
                        001 = In NAK
                        010 = Out Packet Data0 ACK
                        110 = Out Packet Data1 ACK
                        011 = Setup ACK
                        111 = Isochronous transfer end</description>
            <name>EPSTS4</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>These bits are used to indicate the current status of this endpoint
                        000 = In ACK
                        001 = In NAK
                        010 = Out Packet Data0 ACK
                        110 = Out Packet Data1 ACK
                        011 = Setup ACK
                        111 = Isochronous transfer end</description>
            <name>EPSTS5</name>
          </field>
        </fields>
        <name>USB_EPSTS</name>
        <resetMask>0xFFFFFF0F</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Bus state &amp; attribution</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Bus reset when SE0(single-ended 0) more than 2.5uS.
                        0: Bus no reset.</description>
            <name>USBRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Bus idle more than 3mS, either cable is plugged off or host is sleeping.
                        0: Bus no suspend.</description>
            <name>SUSPEND</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Resume from suspension
                        0: No bus resume.</description>
            <name>RESUME</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: No response more than 18 bits time
                        0: No time out.</description>
            <name>TIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Enable PHY transceiver function.
                        0: Disable PHY transceiver function.</description>
            <name>PHY_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Force USB bus to K state, used for remote wake-up.
                        0: Release the USB bus from K state.</description>
            <name>RWAKEUP</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Enable USB controller.
                        0: Disable USB controller.</description>
            <name>USB_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Pull-up resistor on USB_DP enable bit
                        1: Enable
                        0: Disable</description>
            <name>DPPU_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Turn-on related circuit of PHY transceiver
                        0: power-down related circuit of PHY transceiver</description>
            <name>PWRDN</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: Byte Mode. The size of the transfer from CPU to USB SRAM can be Byte only.
                        0: Word Mode. The size of the transfer from CPU to USB SRAM can be Word. only</description>
            <name>BYTEM</name>
          </field>
        </fields>
        <name>USB_ATTR</name>
        <resetMask>0xFFFFFFBF</resetMask>
        <resetValue>0x40</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Device Floating Detected</description>
        <fields>
          <field>
            <access>read-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1: When the controller is attached into the BUS, this bit will be set as 1
                        0: The controller didn't attached into the USB host</description>
            <name>FLDET</name>
          </field>
        </fields>
        <name>USB_FLDET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Buffer Segmentation</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for the Setup token with the USB SRAM starting address. The effective starting address is
                        USB_SRAM address + { BUFSEG[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Note: It is used for Setup token only.</description>
            <name>BUFSEG</name>
          </field>
        </fields>
        <name>USB_BUFSEG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Buffer Segmentation of endpoint 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:
                        USB_SRAM address + { BUFSEG0[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Refer to section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
            <name>BUFSEG0</name>
          </field>
        </fields>
        <name>USB_BUFSEG0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Maximal payload of endpoint 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>It is used to define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
                        (1). When the register is written by CPU, For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready. For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
                        (2). When the register is read by CPU, For IN token, the value of MXPLD is indicated the data length be transmitted to host. For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
                        Note that once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
            <name>MXPLD</name>
          </field>
        </fields>
        <name>USB_MXPLD0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Configuration of endpoint 0</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits are used to define the endpoint number of the current endpoint.</description>
            <name>EP_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is used to set the endpoint as Isochronous endpoint, no handshake.
                        1: Isochronous endpoint
                        0: No Isochronous endpoint</description>
            <name>ISOCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>00 = Endpoint is disabled
                        01 = OUT endpoint
                        10 = IN endpoint
                        11 = Undefined</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = DATA1 PID
                        0 = DATA0 PID
                        It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
            <name>DSQ_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Clear the device to response STALL handshake in setup stage
                        0 = Disable the device to clear the STALL handshake in setup stage</description>
            <name>CSTALL</name>
          </field>
        </fields>
        <name>USB_CFG0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>stall control register and In/out ready clear flag of endpoint 0</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it is auto clear to 0.
                        For IN token, write 1 is used to clear the IN token had ready to transmit the data to USB.
                        For OUT token, write 1 is used to clear the OUT token had ready to receive the data from USB.
                        This bit is write 1 only and it is always 0 when it was read back.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Set the device to respond STALL automatically
                        0 = Disable the device to response STALL</description>
            <name>SSTALL</name>
          </field>
        </fields>
        <name>USB_CFGP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>Buffer Segmentation of endpoint 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:
                        USB_SRAM address + { BUFSEG1[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Refer to section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
            <name>BUFSEG1</name>
          </field>
        </fields>
        <name>USB_BUFSEG1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>Maximal payload of endpoint 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>It is used to define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
                        (1). When the register is written by CPU, For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready. For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
                        (2). When the register is read by CPU, For IN token, the value of MXPLD is indicated the data length be transmitted to host. For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
                        Note that once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
            <name>MXPLD</name>
          </field>
        </fields>
        <name>USB_MXPLD1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>Configuration of endpoint 1</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits are used to define the endpoint number of the current endpoint.</description>
            <name>EP_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is used to set the endpoint as Isochronous endpoint, no handshake.
                        1: Isochronous endpoint
                        0: No Isochronous endpoint</description>
            <name>ISOCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>00 = Endpoint is disabled
                        01 = OUT endpoint
                        10 = IN endpoint
                        11 = Undefined</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = DATA1 PID
                        0 = DATA0 PID
                        It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
            <name>DSQ_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Clear the device to response STALL handshake in setup stage
                        0 = Disable the device to clear the STALL handshake in setup stage</description>
            <name>CSTALL</name>
          </field>
        </fields>
        <name>USB_CFG1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>stall control register and In/out ready clear flag of endpoint 1</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it is auto clear to 0.
                        For IN token, write 1 is used to clear the IN token had ready to transmit the data to USB.
                        For OUT token, write 1 is used to clear the OUT token had ready to receive the data from USB.
                        This bit is write 1 only and it is always 0 when it was read back.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Set the device to respond STALL automatically
                        0 = Disable the device to response STALL</description>
            <name>SSTALL</name>
          </field>
        </fields>
        <name>USB_CFGP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Buffer Segmentation of endpoint 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:
                        USB_SRAM address + { BUFSEG2[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Refer to section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
            <name>BUFSEG2</name>
          </field>
        </fields>
        <name>USB_BUFSEG2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Maximal payload of endpoint 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>It is used to define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
                        (1). When the register is written by CPU, For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready. For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
                        (2). When the register is read by CPU, For IN token, the value of MXPLD is indicated the data length be transmitted to host. For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
                        Note that once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
            <name>MXPLD</name>
          </field>
        </fields>
        <name>USB_MXPLD2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Configuration of endpoint 2</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits are used to define the endpoint number of the current endpoint.</description>
            <name>EP_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is used to set the endpoint as Isochronous endpoint, no handshake.
                        1: Isochronous endpoint
                        0: No Isochronous endpoint</description>
            <name>ISOCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>00 = Endpoint is disabled
                        01 = OUT endpoint
                        10 = IN endpoint
                        11 = Undefined</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = DATA1 PID
                        0 = DATA0 PID
                        It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
            <name>DSQ_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Clear the device to response STALL handshake in setup stage
                        0 = Disable the device to clear the STALL handshake in setup stage</description>
            <name>CSTALL</name>
          </field>
        </fields>
        <name>USB_CFG2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>stall control register and In/out ready clear flag of endpoint 2</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it is auto clear to 0.
                        For IN token, write 1 is used to clear the IN token had ready to transmit the data to USB.
                        For OUT token, write 1 is used to clear the OUT token had ready to receive the data from USB.
                        This bit is write 1 only and it is always 0 when it was read back.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Set the device to respond STALL automatically
                        0 = Disable the device to response STALL</description>
            <name>SSTALL</name>
          </field>
        </fields>
        <name>USB_CFGP2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Buffer Segmentation of endpoint 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:
                        USB_SRAM address + { BUFSEG3[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Refer to section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
            <name>BUFSEG3</name>
          </field>
        </fields>
        <name>USB_BUFSEG3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Maximal payload of endpoint 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>It is used to define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
                        (1). When the register is written by CPU, For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready. For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
                        (2). When the register is read by CPU, For IN token, the value of MXPLD is indicated the data length be transmitted to host. For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
                        Note that once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
            <name>MXPLD</name>
          </field>
        </fields>
        <name>USB_MXPLD3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Configuration of endpoint 3</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits are used to define the endpoint number of the current endpoint.</description>
            <name>EP_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is used to set the endpoint as Isochronous endpoint, no handshake.
                        1: Isochronous endpoint
                        0: No Isochronous endpoint</description>
            <name>ISOCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>00 = Endpoint is disabled
                        01 = OUT endpoint
                        10 = IN endpoint
                        11 = Undefined</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = DATA1 PID
                        0 = DATA0 PID
                        It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
            <name>DSQ_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Clear the device to response STALL handshake in setup stage
                        0 = Disable the device to clear the STALL handshake in setup stage</description>
            <name>CSTALL</name>
          </field>
        </fields>
        <name>USB_CFG3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5C</addressOffset>
        <description>stall control register and In/out ready clear flag of endpoint 3</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it is auto clear to 0.
                        For IN token, write 1 is used to clear the IN token had ready to transmit the data to USB.
                        For OUT token, write 1 is used to clear the OUT token had ready to receive the data from USB.
                        This bit is write 1 only and it is always 0 when it was read back.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Set the device to respond STALL automatically
                        0 = Disable the device to response STALL</description>
            <name>SSTALL</name>
          </field>
        </fields>
        <name>USB_CFGP3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x60</addressOffset>
        <description>Buffer Segmentation of endpoint 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:
                        USB_SRAM address + { BUFSEG4[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Refer to section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
            <name>BUFSEG4</name>
          </field>
        </fields>
        <name>USB_BUFSEG4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x64</addressOffset>
        <description>Maximal payload of endpoint 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>It is used to define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
                        (1). When the register is written by CPU, For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready. For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
                        (2). When the register is read by CPU, For IN token, the value of MXPLD is indicated the data length be transmitted to host. For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
                        Note that once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
            <name>MXPLD</name>
          </field>
        </fields>
        <name>USB_MXPLD4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x68</addressOffset>
        <description>Configuration of endpoint 4</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits are used to define the endpoint number of the current endpoint.</description>
            <name>EP_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is used to set the endpoint as Isochronous endpoint, no handshake.
                        1: Isochronous endpoint
                        0: No Isochronous endpoint</description>
            <name>ISOCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>00 = Endpoint is disabled
                        01 = OUT endpoint
                        10 = IN endpoint
                        11 = Undefined</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = DATA1 PID
                        0 = DATA0 PID
                        It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
            <name>DSQ_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Clear the device to response STALL handshake in setup stage
                        0 = Disable the device to clear the STALL handshake in setup stage</description>
            <name>CSTALL</name>
          </field>
        </fields>
        <name>USB_CFG4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6C</addressOffset>
        <description>stall control register and In/out ready clear flag of endpoint 4</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it is auto clear to 0.
                        For IN token, write 1 is used to clear the IN token had ready to transmit the data to USB.
                        For OUT token, write 1 is used to clear the OUT token had ready to receive the data from USB.
                        This bit is write 1 only and it is always 0 when it was read back.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Set the device to respond STALL automatically
                        0 = Disable the device to response STALL</description>
            <name>SSTALL</name>
          </field>
        </fields>
        <name>USB_CFGP4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Buffer Segmentation of endpoint 5</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>It is used to indicate the offset address for each endpoint with the USB SRAM starting address. The effective starting address of the endpoint is:
                        USB_SRAM address + { BUFSEG5[8:3], 3'b000}
                        Where the USB_SRAM address = 0x40060100h.
                        Refer to section 5.4.4.7 for the endpoint SRAM structure and its description.</description>
            <name>BUFSEG5</name>
          </field>
        </fields>
        <name>USB_BUFSEG5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>Maximal payload of endpoint 5</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>It is used to define the data length which is transmitted to host (IN token) or the actual data length which is received from the host (OUT token). It also used to indicate that the endpoint is ready to be transmitted in IN token or received in OUT token.
                        (1). When the register is written by CPU, For IN token, the value of MXPLD is used to define the data length to be transmitted and indicate the data buffer is ready. For OUT token, it means that the controller is ready to receive data from the host and the value of MXPLD is the maximal data length comes from host.
                        (2). When the register is read by CPU, For IN token, the value of MXPLD is indicated the data length be transmitted to host. For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
                        Note that once MXPLD is written, the data packets will be transmitted/received immediately after IN/OUT token arrived.</description>
            <name>MXPLD</name>
          </field>
        </fields>
        <name>USB_MXPLD5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>Configuration of endpoint 5</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>These bits are used to define the endpoint number of the current endpoint.</description>
            <name>EP_NUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is used to set the endpoint as Isochronous endpoint, no handshake.
                        1: Isochronous endpoint
                        0: No Isochronous endpoint</description>
            <name>ISOCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>00 = Endpoint is disabled
                        01 = OUT endpoint
                        10 = IN endpoint
                        11 = Undefined</description>
            <name>STATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = DATA1 PID
                        0 = DATA0 PID
                        It is used to specify the DATA0 or DATA1 PID in the following IN token transaction. H/W will toggle automatically in IN token base on the bit.</description>
            <name>DSQ_SYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Clear the device to response STALL handshake in setup stage
                        0 = Disable the device to clear the STALL handshake in setup stage</description>
            <name>CSTALL</name>
          </field>
        </fields>
        <name>USB_CFG5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7C</addressOffset>
        <description>In ready clear flag of endpoint 5</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When the MXPLD register is set by user, it means that the endpoint is ready to transmit or receive data. If the user wants to turn off this transaction before the transaction start, users can set this bit to 1 to turn it off and it is auto clear to 0.
                        For IN token, write 1 is used to clear the IN token had ready to transmit the data to USB.
                        For OUT token, write 1 is used to clear the OUT token had ready to receive the data from USB.
                        This bit is write 1 only and it is always 0 when it was read back.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>CLRRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = Set the device to respond STALL automatically
                        0 = Disable the device to response STALL</description>
            <name>SSTALL</name>
          </field>
        </fields>
        <name>USB_CFGP5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x90</addressOffset>
        <description>Drive Single Ended Zero (SE0) in USB Bus</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The Single Ended Zero (SE0) is when both lines (USB_DP and USB_DM) are being pulled low.
                        1 = Force USB PHY transceiver to drive SE0
                        0 = None</description>
            <name>DRVSE0</name>
          </field>
        </fields>
        <name>USB_DRVSE0</name>
        <resetMask>0xFFFFFFFE</resetMask>
        <resetValue>0x1</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA4</addressOffset>
        <description>New description for register</description>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = The USB PDMA read data from USB buffer to memory
                        0 = The USB PDMA write data from memory to USB buffer</description>
            <name>PDMA_RW</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>1 = The PDMA function in USB is enabled
                        0 = The PDMA function in USB is disabled
                        This bit will be automatically cleared after PDMA transfer done</description>
            <name>PDMA_EN</name>
          </field>
        </fields>
        <name>USB_PDMA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <access>read-write</access>
    <addressBlock>
      <offset>0x0</offset>
      <size>0x4</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40004000</baseAddress>
    <description>Registers group</description>
    <groupName>WDT</groupName>
    <interrupts></interrupts>
    <name>WDT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Watchdog Timer Control Register</description>
        <fields>
          <field>
            <access>write-only</access>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Watchdog Timer (write protection bit) 
                        Set this bit will clear the Watchdog timer. 
                        0 = Writing 0 to this bit has no effect
                        1 = Reset the contents of the Watchdog timer
                        NOTE: This bit will auto clear after few clock cycle</description>
            <modifiedWriteValues>modify</modifiedWriteValues>
            <name>WTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Reset Enable (write protection bit)
                        Setting this bit will enable the Watchdog timer reset function.
                        0 = Disable Watchdog timer reset function
                        1 = Enable Watchdog timer reset function</description>
            <name>WTRE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Reset Flag
                        When the Watchdog timer initiates a reset, the hardware will set this bit. This flag can be read by software to determine the source of reset. Software is responsible to clear it manually by writing 1 to it. If WTRE is disabled, then the Watchdog timer has no effect on this bit.
                        0 = Watchdog timer reset did not occur
                        1 = Watchdog timer reset occurs
                        NOTE: This bit is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WTRF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Interrupt Flag
                        If the Watchdog timer interrupt is enabled, then the hardware will set this bit to indicate that the Watchdog timer interrupt has occurred. 
                        0 = Watchdog timer interrupt does not occur
                        1 = Watchdog timer interrupt occurs
                        NOTE: This bit is cleared by writing 1 to this bit.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WTIF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Wakeup Function Enable bit (write protection bit)
                        0 : Disable Watchdog timer Wakeup CPU function.
                        1 : Enable the Wakeup function that Watchdog timer timeout can wake up CPU from power-down mode.
                        Note: CHIP can wakeup by WDT only if WDT clock source select RC10K.</description>
            <name>WTWKE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Wakeup Flag
                        If Watchdog timer causes CPU wakes up from power-down mode, this bit will be set to high. It must be cleared by software with a write 1 to this bit.
                        0 : Watchdog timer does not cause CPU wakeup.
                        1 : CPU wake up from sleep or power-down mode by Watchdog timeout.</description>
            <modifiedWriteValues>oneToClear</modifiedWriteValues>
            <name>WTWKF</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Interrupt Enable (write protection bit)
                        0 = Disable the Watchdog timer interrupt
                        1 = Enable the Watchdog timer interrupt</description>
            <name>WTIE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog Timer Enable (write protection bit)
                        0 = Disable the Watchdog timer (This action will reset the internal counter)
                        1 = Enable the Watchdog timer</description>
            <name>WTE</name>
          </field>
        </fields>
        <fields>
          <field>
            <access>read-write</access>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Watchdog Timer Interval Select (write protection bit)
                        These three bits select the timeout interval for the Watchdog timer. 
                        WTIS	Timeout Interval Selection	Interrupt Period	WTR Timeout Interval (WDT_CLK=12MHz)	
                        000	2^4 * WDT_CLK	(2^4 + 1024) * WDT_CLK	1.33 us ~ 86.67 us	
                        001	2^6 * WDT_CLK	(2^6 + 1024) * WDT_CLK	5.33 us ~ 90.67 us	
                        010	2^8 * WDT_CLK	(2^8 + 1024) * WDT_CLK	21.33 us ~ 106.67 us	
                        011	2^10 * WDT_CLK	(2^10 + 1024) * WDT_CLK	85.33 us ~ 170.67 us	
                        100	2^12 * WDT_CLK	(2^12 + 1024) * WDT_CLK	341.33 us ~ 426.67 us	
                        101	2^14 * WDT_CLK	(2^14 + 1024) * WDT_CLK	1.36 ms ~ 1.45 ms	
                        110	2^16 * WDT_CLK	(2^16 + 1024) * WDT_CLK	5.46 ms ~ 5.55 ms	
                        111	2^18 * WDT_CLK	(2^18 + 1024) * WDT_CLK	21.84 ms ~ 21.93 ms	</description>
            <name>WTIS</name>
          </field>
        </fields>
        <name>WTCR</name>
        <resetMask>0xFFFFF8FF</resetMask>
        <resetValue>0x700</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <resetMask>0x0</resetMask>
    <resetValue>0x0</resetValue>
    <size>0x20</size>
  </peripheral>
</peripherals>
<resetMask>0x0</resetMask>
<resetValue>0x0</resetValue>
<size>0x20</size>
<version>0.1</version>
<width>0x20</width></device>
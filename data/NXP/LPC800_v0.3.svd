<?xml version="1.0" encoding="UTF-8"?>
<device xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" schemaVersion="1.1" xs:noNamespaceSchemaLocation="CMSIS-SVD_Schema_1_1.xsd"><addressUnitBits>0x8</addressUnitBits>
<cpu>
  <dcachePresent>
    <dcachePresen></dcachePresen>
  </dcachePresent>
  <deviceNumInterrupts>0x0</deviceNumInterrupts>
  <dtcmPresent>
    <dtcmPresen></dtcmPresen>
  </dtcmPresent>
  <endian>little</endian>
  <fpuPresent>0x0</fpuPresent>
  <icachePresent>
    <icachePresen></icachePresen>
  </icachePresent>
  <itcmPresent>
    <itcmPresen></itcmPresen>
  </itcmPresent>
  <mpuPresent>0x0</mpuPresent>
  <name>CM0</name>
  <nvicPrioBits>0x2</nvicPrioBits>
  <revision>r0p0</revision>
  <sauNumRegions>0x0</sauNumRegions>
  <vendorSystickConfig>0x0</vendorSystickConfig>
</cpu>
<description>LPC800</description>
<name>LPC800</name>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40000000</baseAddress>
    <description>Windowed Watchdog Timer (WWDT)</description>
    <groupName>WWDT</groupName>
    <interrupts>
      <interrupt>
        <name>WDT</name>
        <value>0xC</value>
      </interrupt>
    </interrupts>
    <name>WWDT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog enable bit. Once this bit has been written with a 1, it cannot be rewritten with a 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog timer is stopped.</description>
                <name>STOPPED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog timer is running.</description>
                <name>RUNNING</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog reset enable bit. Once this bit has been written with a 1 it cannot be rewritten with a 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>A watchdog timeout will not cause a chip reset.</description>
                <name>NORESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>A watchdog timeout will cause a chip reset.</description>
                <name>RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDRESET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT. Cleared by software. Causes a chip reset if WDRESET = 1.</description>
            <name>WDTOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Warning interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software.</description>
            <name>WDINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog update mode. This bit can be set once by software and is only cleared by a reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog time-out value (TC) can be changed at any time.</description>
                <name>THE_WATCHDOG_TIME_OU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The watchdog time-out value (TC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW.</description>
                <name>THE_WATCHDOG_TIME_OU</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDPROTECT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents disabling or powering down the watchdog oscillator. This bit can be set once by software and is only cleared by any reset.</description>
            <name>LOCK</name>
          </field>
        </fields>
        <name>MOD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Watchdog timer constant register. This 24-bit register determines the time-out value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Watchdog time-out value.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <name>TC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Feed value should be 0xAA followed by 0x55.</description>
            <name>FEED</name>
          </field>
        </fields>
        <name>FEED</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Watchdog timer value register. This 24-bit register reads out the current value of the Watchdog timer.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Counter timer value.</description>
            <name>COUNT</name>
          </field>
        </fields>
        <name>TV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Watchdog Warning Interrupt compare value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0xA</bitWidth>
            <description>Watchdog warning interrupt compare value.</description>
            <name>WARNINT</name>
          </field>
        </fields>
        <name>WARNINT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Watchdog Window compare value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Watchdog window value.</description>
            <name>WINDOW</name>
          </field>
        </fields>
        <name>WINDOW</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40004000</baseAddress>
    <description>Multi-Rate Timer (MRT)</description>
    <groupName>MRT</groupName>
    <interrupts>
      <interrupt>
        <name>MRT</name>
        <value>0xA</value>
      </interrupt>
    </interrupts>
    <name>MRT</name>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xF4</addressOffset>
        <description>Idle channel register. This register returns the number of the first idle channel.</description>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Idle channel. Reading the CHAN bits, returns the lowest idle timer channel. If all timer channels are running, CHAN = .</description>
            <name>CHAN</name>
          </field>
        </fields>
        <name>IDLE_CH</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>Global interrupt flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMER0 has reached the end of the time interval. If the INTEN bit in the CONTROL0 register is also set to 1, the interrupt for timer channel 0 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GFLAG0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMER1 has reached the end of the time interval. If the INTEN bit in the CONTROL1 register is also set to 1, the interrupt for timer channel 1 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GFLAG1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMER2 has reached the end of the time interval. If the INTEN bit in the CONTROL2 register is also set to 1, the interrupt for timer channel 2 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GFLAG2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag of TIMER3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMER3 has reached the end of the time interval. If the INTEN bit in the CONTROL3 register is also set to 1, the interrupt for timer channel 3 and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GFLAG3</name>
          </field>
        </fields>
        <name>IRQ_FLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>MRT0 Time interval value register. This value is loaded into the TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately.  If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD_THE_L</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running.</description>
                <name>FORCE_LOAD_THE_INTV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>MRT0 Time interval value register. This value is loaded into the TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately.  If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD_THE_L</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running.</description>
                <name>FORCE_LOAD_THE_INTV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>MRT0 Time interval value register. This value is loaded into the TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately.  If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD_THE_L</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running.</description>
                <name>FORCE_LOAD_THE_INTV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>MRT0 Time interval value register. This value is loaded into the TIMER0 register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Time interval load value. This value is loaded into the TIMERn register and the MRTn starts counting down from IVALUE -1. If the timer is idle, writing a non-zero value to this bit field starts the timer immediately.  If the timer is running, writing a zero to this bit field does the following: If LOAD = 1, the timer stops immediately. If LOAD = 0, the timer stops at the end of the time interval.</description>
            <name>IVALUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines how the timer interval value IVALUE is loaded into the TIMERn register. This bit is write-only. Reading this bit always returns 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No force load. The load from the INTVALn register to the TIMERn register is processed at the end of the time interval if the repeat mode is selected.</description>
                <name>NO_FORCE_LOAD_THE_L</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Force load. The INTVALn interval value IVALUE is immediately loaded into the TIMERn register while TIMERn is running.</description>
                <name>FORCE_LOAD_THE_INTV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOAD</name>
          </field>
        </fields>
        <name>INTVAL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x4</addressOffset>
        <description>MRT0 Timer register. This register reads the value of the down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The initial value is loaded as IVALUE - 1 from the TIME_INTVALn register either at the end of the time interval if the LOAD bit in TIME_INTVALn is 0 and the timer is in repeat mode or immediately if LOAD = 1. When the timer is in idle state, reading this bit fields returns -1 (0x7FFF FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>MRT0 Timer register. This register reads the value of the down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The initial value is loaded as IVALUE - 1 from the TIME_INTVALn register either at the end of the time interval if the LOAD bit in TIME_INTVALn is 0 and the timer is in repeat mode or immediately if LOAD = 1. When the timer is in idle state, reading this bit fields returns -1 (0x7FFF FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>MRT0 Timer register. This register reads the value of the down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The initial value is loaded as IVALUE - 1 from the TIME_INTVALn register either at the end of the time interval if the LOAD bit in TIME_INTVALn is 0 and the timer is in repeat mode or immediately if LOAD = 1. When the timer is in idle state, reading this bit fields returns -1 (0x7FFF FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x34</addressOffset>
        <description>MRT0 Timer register. This register reads the value of the down-counter.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x18</bitWidth>
            <description>Holds the current timer value of the down-counter. The initial value is loaded as IVALUE - 1 from the TIME_INTVALn register either at the end of the time interval if the LOAD bit in TIME_INTVALn is 0 and the timer is in repeat mode or immediately if LOAD = 1. When the timer is in idle state, reading this bit fields returns -1 (0x7FFF FFFF).</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>TIMER3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFF</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>MRT0 Control register. This register controls the MRT0 modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot bus stall mode.</description>
                <name>ONE_SHOT_BUS_STALL_M</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>MRT0 Control register. This register controls the MRT0 modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot bus stall mode.</description>
                <name>ONE_SHOT_BUS_STALL_M</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>MRT0 Control register. This register controls the MRT0 modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot bus stall mode.</description>
                <name>ONE_SHOT_BUS_STALL_M</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>MRT0 Control register. This register controls the MRT0 modes.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the TIMERn interrupt.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects timer mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeat interrupt mode.</description>
                <name>REPEAT_INTERRUPT_MOD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot interrupt mode.</description>
                <name>ONE_SHOT_INTERRUPT_M</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>One-shot bus stall mode.</description>
                <name>ONE_SHOT_BUS_STALL_M</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <name>CTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>MRT0 Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE_TIMERN_I</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING_TIMERN_IS_R</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <name>STAT0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>MRT0 Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE_TIMERN_I</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING_TIMERN_IS_R</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <name>STAT1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>MRT0 Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE_TIMERN_I</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING_TIMERN_IS_R</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <name>STAT2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>MRT0 Status register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitors the interrupt flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No pending interrupt. Writing a zero is equivalent to no operation.</description>
                <name>NO_PENDING_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pending interrupt. The interrupt is pending because TIMERn has reached the end of the time interval. If the INTEN bit in the CONTROLn is also set to 1, the interrupt for timer channel n and the global interrupt are raised.  Writing a 1 to this bit clears the interrupt request.</description>
                <name>PENDING_INTERRUPT_T</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INTFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Indicates the state of TIMERn. This bit is read-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle state. TIMERn is stopped.</description>
                <name>IDLE_STATE_TIMERN_I</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Running. TIMERn is running.</description>
                <name>RUNNING_TIMERN_IS_R</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RUN</name>
          </field>
        </fields>
        <name>STAT3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40008000</baseAddress>
    <description>Self wake-up timer (WKT)</description>
    <groupName>WKT</groupName>
    <interrupts>
      <interrupt>
        <name>WKT</name>
        <value>0xF</value>
      </interrupt>
    </interrupts>
    <name>WKT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Self wake-up timer control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select the self wake-up timer clock source.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Divided IRC clock. This clock runs at 750 kHz and provides time-out periods of up to approximately 95 minutes in 1.33 us increments. This clock is not available in most low-power modes and must not be selected if the timer is to be used to wake up from one of these modes.</description>
                <name>DIVIDED_IRC_CLOCK_T</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low power clock. This is the (nominally) 10 kHz clock and provides time-out periods of up to approximately 119 hours in 100 CTS can be from the input pin, or fs increments. The accuracy of this clock is limited to +/- 45 % over temperature and processing. This clock is available in all power modes. Prior to use, the low-power oscillator must be enabled. The oscillator must also be set to remain active in Deep power-down if needed.</description>
                <name>LOW_POWER_CLOCK_THI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Wake-up or alarm timer flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. The self wake-up timer has not timed out. Writing a 0 to has no effect.</description>
                <name>NO_TIME_OUT_THE_SEL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. The self wake-up timer has timed out. This flag generates an interrupt request which can wake up the part from any low power mode not deep power-down. Writing a 1 clears this status bit and the interrupt too?</description>
                <name>TIME_OUT_THE_SELF_W</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ALARMFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clears the self wake-up timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect. Reading this bit always returns 0.</description>
                <name>NO_EFFECT_READING_T</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the counter. Counting is halted until a new count value is loaded.</description>
                <name>CLEAR_THE_COUNTER_C</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLEARCTR</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Counter register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>A write to this register pre-loads start count value into the timer and starts the count-down sequence. A read reflects the current value of the timer.</description>
            <name>VALUE</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4000C000</baseAddress>
    <description>Switch matrix (SWM)</description>
    <groupName>SWM</groupName>
    <interrupts></interrupts>
    <name>SWM</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Pin assign register 0. Assign movable functions U0_TXD, U0_RXD, U0_RTS, U0_CTS</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U0_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U0_TXD_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U0_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U0_RXD_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U0_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U0_RTS_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U0_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U0_CTS_I</name>
          </field>
        </fields>
        <name>PINASSIGN0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Pin assign register 1. Assign movable functions U0_SCLC, U1_TXD, U1_RXD</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U0_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U0_SCLK_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U1_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U1_TXD_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U1_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U1_RXD_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U1_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U1_RTS_O</name>
          </field>
        </fields>
        <name>PINASSIGN1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Pin assign register 2. Assign movable functions U2_TXD, U2_RXD</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U1_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U1_CTS_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U1_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U1_SCLK_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U2_TXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U2_TXD_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U2_RXD function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U2_RXD_I</name>
          </field>
        </fields>
        <name>PINASSIGN2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Pin assignregister 3. Assign movable function SPI0_SCK</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U2_RTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U2_RTS_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U2_CTS function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U2_CTS_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>U2_SCLK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>U2_SCLK_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI0_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI0_SCK_IO</name>
          </field>
        </fields>
        <name>PINASSIGN3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin assign register 4. Assign movable functions SPI0_MOSI, SPI0_MISO, SPI0_SSEL, SPI1_SCK</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI0_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI0_MOSI_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI0_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI0_MISO_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI0_SSEL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI0_SSEL_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI1_SCK function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI1_SCK_IO</name>
          </field>
        </fields>
        <name>PINASSIGN4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Pin assign register 5. Assign movable functions SPI1_MOSI, SPI1_MISO, SPI1_SSEL, CTIN_0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI1_MOSI function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI1_MOSI_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI1_MISIO function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI1_MISO_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>SPI1_SSEL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>SPI1_SSEL_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTIN_0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTIN_0_I</name>
          </field>
        </fields>
        <name>PINASSIGN5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>Pin assign register 6. Assign movable functions CTIN_1, CTIN_2, CTIN_3, CTOUT_0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTIN_1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTIN_1_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTIN_2function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTIN_2_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTIN_3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTIN_3_I</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTOUT_0 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTOUT_0_O</name>
          </field>
        </fields>
        <name>PINASSIGN6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Pin assign egister 7. Assign movable functions CTOUT_1, CTOUT_2, CTOUT_3, I2C_SDA</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTOUT_1 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTOUT_1_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTOUT_2 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTOUT_2_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CTOUT_3 function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CTOUT_3_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C_SDA function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>I2C_SDA_IO</name>
          </field>
        </fields>
        <name>PINASSIGN7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Pin assign register 8. Assign movable functions I2C_SCL, ACMP_O, CLKOUT, GPIO_INT_BMAT</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>I2C_SCL function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>I2C_SCL_IO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>ACMP_O_O function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>ACMP_O_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CLKOUT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>CLKOUT_O</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>GPIO_INT_BMAT function assignment. The value is the pin number to be assigned to this function. The following pins are available: PIO0_0 (= 0) to PIO0_17 (= 0x11).</description>
            <name>GPIO_INT_BMAT_O</name>
          </field>
        </fields>
        <name>PINASSIGN8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFFFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C0</addressOffset>
        <description>Pin enable register 0. Enables fixed-pin functions ACMP_I0, ACMP_I1, SWCLK, SWDIO, XTALIN, XTALOUT, RESET, CLKIN, VDDCMP</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable ACMP_I1. This function is enabled on pin PIO0_0.</description>
                <name>ENABLE_ACMP_I1_THIS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable ACMP_I1. GPIO function PIO0_0 (default) or any other movable function can be assigned to pin PIO0_0.</description>
                <name>DISABLE_ACMP_I1_GPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACMP_I1_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed-pin function is deselected and GPIO is assigned to this pin. Functions CLKIN and ACMP_I2 are connected to the same pin PIO0_1. To use ACMP_I2, disable the CLKIN function in bit 7 of this register and enable ACMP_I2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable ACMP_I2. This function is enabled on pin PIO0_1.</description>
                <name>ENABLE_ACMP_I2_THIS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable ACMP_I2. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin PIO0_1.</description>
                <name>DISABLE_ACMP_I2_GPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACMP_I2_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable SWCLK. This function is enabled on pin PIO0_3.</description>
                <name>ENABLE_SWCLK_THIS_F</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable SWCLK. GPIO function PIO0_3 is selected on this pin. Any other movable function can be assigned to pin PIO0_3.</description>
                <name>DISABLE_SWCLK_GPIO_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWCLK_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable SWDIO. This function is enabled on pin PIO0_2.</description>
                <name>ENABLE_SWDIO_THIS_F</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable SWDIO. GPIO function PIO0_2 is selected on this pin. Any other movable function can be assigned to pin PIO0_2.</description>
                <name>DISABLE_SWDIO_GPIO_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWDIO_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable XTALIN. This function is enabled on pin PIO0_8.</description>
                <name>ENABLE_XTALIN_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable XTALIN. GPIO function PIO0_8 (default) or any other movable function can be assigned to pin PIO0_8.</description>
                <name>DISABLE_XTALIN_GPIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>XTALIN_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable XTALOUT. This function is enabled on pin PIO0_9.</description>
                <name>ENABLE_XTALOUT_THIS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable XTALOUT. GPIO function PIO0_9 (default) or any other movable function can be assigned to pin PIO0_9.</description>
                <name>DISABLE_XTALOUT_GPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>XTALOUT_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. This function is selected by default.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable RESET. This function is enabled on pin PIO0_5.</description>
                <name>ENABLE_RESET_THIS_F</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable RESET. GPIO function PIO0_5 is selected on this pin. Any other movable function can be assigned to pin PIO0_5.</description>
                <name>DISABLE_RESET_GPIO_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RESET_EN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed-pin function is deselected and GPIO is assigned to this pin. Functions CLKIN and ACMP_I2 are connected to the same pin PIO0_1. To use CLKIN, disable ACMP_I2 in bit 1 of this register and enable CLKIN.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable CLKIN. This function is enabled on pin PIO0_1.</description>
                <name>ENABLE_CLKIN_THIS_F</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable CLKIN. GPIO function PIO0_1 (default) or any other movable function can be assigned to pin CLKIN.</description>
                <name>DISABLE_CLKIN_GPIO_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables fixed-pin function. Writing a 1 deselects the function and any movable function can be assigned to this pin. By default the fixed--pin function is deselected and GPIO is assigned to this pin.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable VDDCMP. This function is enabled on pin PIO0_6.</description>
                <name>ENABLE_VDDCMP_THIS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable VDDCMP. GPIO function PIO0_6 (default) or any other movable function can be assigned to pin PIO0_6.</description>
                <name>DISABLE_VDDCMP_GPIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>VDDCMP</name>
          </field>
        </fields>
        <name>PINENABLE0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1B3</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40020000</baseAddress>
    <description>Power Management Unit (PMU)</description>
    <groupName>PMU</groupName>
    <interrupts></interrupts>
    <name>PMU</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Power control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Power mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Default. The part is in active or sleep mode.</description>
                <name>DEFAULT_THE_PART_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ARM WFI will enter Deep-sleep mode.</description>
                <name>ARM_WFI_WILL_ENTER_D</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ARM WFI will enter Power-down mode.</description>
                <name>ARM_WFI_WILL_ENTER_P</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down).</description>
                <name>ARM_WFI_WILL_ENTER_D</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents entry to Deep power-down mode when 0x3 is written to the PM field above, the SLEEPDEEP bit is set, and a WFI is executed.   This bit is cleared only by power-on reset, so writing a one to this bit locks the part in a mode in which Deep power-down mode is blocked.</description>
            <name>NODPD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Sleep mode flag</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read: No power-down mode entered. LPC11Uxx is in Active mode. Write: No effect.</description>
                <name>READ_NO_POWER_DOWN_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0.</description>
                <name>READ_SLEEPDEEP_SLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLEEPFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Deep power-down flag</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read: Deep power-down mode  not entered. Write: No effect.</description>
                <name>READ_DEEP_POWER_DOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read: Deep power-down mode entered. Write: Clear the Deep power-down flag.</description>
                <name>READ_DEEP_POWER_DOW</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DPDFLAG</name>
          </field>
        </fields>
        <name>PCON</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Deep power-down control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WAKEUP pin hysteresis enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Hysteresis for WAKUP pin disabled.</description>
                <name>DISABLED_HYSTERESIS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Hysteresis for WAKEUP pin enabled.</description>
                <name>ENABLED_HYSTERESIS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKEUPHYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WAKEUP pin disable. Setting this bit disables the wake-up pin, so it can be used for other purposes. Never set this bit if you intend to use a pin to wake up the part from Deep power-down mode. You can only disable the wake-up pin if the self wake-up timer is enabled and configured. Setting this bit is not necessary if Deep power-down mode is not used.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The wake-up function is enabled on pin PIO0_4.</description>
                <name>ENABLED_THE_WAKE_UP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Setting this bit disables the wake-up function on pin PIO0_4.</description>
                <name>DISABLED_SETTING_TH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WAKEPAD_DISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the low-power oscillator for use with the 10 kHz self wake-up timer clock. You must set this bit if the CLKSEL bit in the self wake-up timer CTRL bit is set.  Do not enable the low-power oscillator if the self wake-up timer is clocked by the divided IRC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LPOSCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable the low-power oscillator in Deep power-down mode. Setting this bit causes the low-power oscillator to remain running during Deep power-down mode provided that bit 12 in this register is set as well.  You must set this bit for the self wake-up timer to be able to wake up the part from Deep power-down mode. Do not set this bit unless you must use the self wake-up timer to wake up from Deep power-down mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LPOSCDPDEN</name>
          </field>
        </fields>
        <name>DPDCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>General purpose register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data retained during Deep power-down mode.</description>
            <name>GPDATA</name>
          </field>
        </fields>
        <name>GPREG3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40024000</baseAddress>
    <description>Analog comparator</description>
    <groupName>CMP</groupName>
    <interrupts>
      <interrupt>
        <name>CMP</name>
        <value>0xB</value>
      </interrupt>
    </interrupts>
    <name>CMP</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Comparator control register</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>This field controls which edges on the comparator output set the COMPEDGE bit (bit 23 below): 00 = Falling edges 01 = Rising edges 1x = Both edges</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges</description>
                <name>FALLING_EDGES</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges</description>
                <name>RISING_EDGES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both edges</description>
                <name>BOTH_EDGES</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Both edges</description>
                <name>BOTH_EDGES</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EDGESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator output control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Comparator output  is used directly.</description>
                <name>DIRECT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Comparator output is synchronized to the bus clock for output to other modules.</description>
                <name>SYNCH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMPSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects positive voltage input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Voltage ladder output</description>
                <name>VOLTAGE_LADDER_OUTPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ACMP_I1</description>
                <name>ACMP_I1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ACMP_I2</description>
                <name>ACMP_I2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Internal reference voltage</description>
                <name>INTERNAL_REFERENCE_V</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMP_VP_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects negative voltage input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>voltage ladder output</description>
                <name>VOLTAGE_LADDER_OUTPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ACMP_I1</description>
                <name>ACMP_I1</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>ACMP_I2</description>
                <name>ACMP_I2</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Internal reference voltage</description>
                <name>INTERNAL_REFERENCE_V</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMP_VM_SEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Interrupt clear bit. To clear the COMPEDGE bit and thus negate the interrupt request, toggle the EDGECLR bit by first writing a 1 and then a 0.</description>
            <name>EDGECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator status. This bit reflects the state of the comparator output.</description>
            <name>COMPSTAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Comparator edge-detect status.</description>
            <name>COMPEDGE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Controls the hysteresis of the comparator. When the comparator is outputting a certain state, this is the difference between the selected signals, in the opposite direction from the state being output, that will switch the output.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>None (the output will switch as the voltages cross)</description>
                <name>NONE_THE_OUTPUT_WIL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 mV</description>
                <name>5_MV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>10 mV</description>
                <name>10_MV</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>20 mV</description>
                <name>20_MV</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Voltage ladder register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Voltage ladder enable</description>
            <name>LADEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Voltage ladder value. The reference voltage Vref depends on the LADREF bit below. 00000 = VSS 00001 = 1 x Vref/31 00010 = 2 x Vref/31 ... 11111 = Vref</description>
            <name>LADSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the reference voltage Vref for the voltage ladder:</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Supply pin VDD</description>
                <name>SUPPLY_PIN_VDD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>VDDCMP pin</description>
                <name>VDDCMP_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LADREF</name>
          </field>
        </fields>
        <name>LAD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40040000</baseAddress>
    <description> Flash controller </description>
    <groupName>FLASHCTRL</groupName>
    <interrupts>
      <interrupt>
        <name>FLASH_IRQ</name>
        <value>0xE</value>
      </interrupt>
    </interrupts>
    <name>FLASHCTRL</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Flash configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 system clock flash access time (for system clock frequencies of up to 20 MHz).</description>
                <name>1_SYSTEM_CLOCK_FLASH</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 system clocks flash access time (for system clock frequencies of up to 30 MHz).</description>
                <name>2_SYSTEM_CLOCKS_FLAS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASHTIM</name>
          </field>
        </fields>
        <name>FLASHCFG</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Signature start address register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x11</bitWidth>
            <description>Signature generation start address (corresponds to AHB byte address bits[20:4]).</description>
            <name>START</name>
          </field>
        </fields>
        <name>FMSSTART</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Signature stop-address register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x11</bitWidth>
            <description>Stop address for signature generation (the word specified by STOPA is included in the address range). The address is in units of memory words, not bytes.  If the option bistprotection=1, bits 2:0 cannot be written and are forced to 111.</description>
            <name>STOPA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is written to 1, signature generation starts. At the end of signature generation, this bit is automatically cleared.</description>
            <name>STRTBIST</name>
          </field>
        </fields>
        <name>FMSSTOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x2C</addressOffset>
        <description>Signature Word </description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>32-bit signature.</description>
            <name>SIG</name>
          </field>
        </fields>
        <name>FMSW0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40044000</baseAddress>
    <description>I/O configuration (IOCON)</description>
    <groupName>IOCON</groupName>
    <interrupts></interrupts>
    <name>IOCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>I/O configuration for pin PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_17</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>I/O configuration for pin PIO0_13</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_13</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>I/O configuration for pin PIO0_12</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_12</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>I/O configuration for pin PIO0_5/RESET</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>I/O configuration for pin PIO0_4</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>I/O configuration for pin PIO0_3/SWCLK</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>I/O configuration for pin PIO0_2/SWDIO</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>I/O configuration for pin PIO0_11. This is the pin configuration for the true open-drain pin.</description>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects I2C mode.  Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode/ Fast-mode I2C.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard I/O functionality</description>
                <name>STANDARD_IO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode Plus I2C</description>
                <name>FAST_MODE_PLUS_I2C</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_11</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>I/O configuration for pin PIO0_10. This is the pin configuration for the true open-drain pin.</description>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects I2C mode.  Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard mode/ Fast-mode I2C.</description>
                <name>STANDARD_MODE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard I/O functionality</description>
                <name>STANDARD_IO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fast-mode Plus I2C</description>
                <name>FAST_MODE_PLUS_I2C</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2CMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_10</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x80</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>I/O configuration for pin PIO0_16</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_16</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>I/O configuration for pin PIO0_15</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_15</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>I/O configuration for pin PIO0_1/ACMP_I1/CLKIN</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x34</addressOffset>
        <description>I/O configuration for pin PIO0_9/XTALOUT</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_9</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x38</addressOffset>
        <description>I/O configuration for pin PIO0_8/XTALIN</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_8</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3C</addressOffset>
        <description>I/O configuration for pin PIO0_7</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>I/O configuration for pin PIO0_6/VDDCMP</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>I/O configuration for pin PIO0_0/ACMP_I0</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>I/O configuration for pin PIO0_14</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects function mode (on-chip pull-up/pull-down resistor control).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive (no pull-down/pull-up resistor enabled).</description>
                <name>INACTIVE_NO_PULL_DO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-down resistor enabled.</description>
                <name>PULL_DOWN_RESISTOR_E</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pull-up resistor enabled.</description>
                <name>PULL_UP_RESISTOR_ENA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeater mode.</description>
                <name>REPEATER_MODE_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Hysteresis.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable.</description>
                <name>ENABLE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Invert input</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input not inverted (HIGH on pin reads as 1; LOW on pin reads as 0).</description>
                <name>INPUT_NOT_INVERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input inverted (HIGH on pin reads as 0, LOW on pin reads as 1).</description>
                <name>INPUT_INVERTED_HIGH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>INV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Open-drain mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable.</description>
                <name>DISABLE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Open-drain mode enabled.  This is not a true open-drain mode.</description>
                <name>OPEN_DRAIN_MODE_ENAB</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Digital filter sample mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Bypass input filter.</description>
                <name>BYPASS_INPUT_FILTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 clock cycle. Input pulses shorter than one filter clock are rejected.</description>
                <name>1_CLOCK_CYCLE_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clock cycles. Input pulses shorter than two filter clocks are rejected.</description>
                <name>2_CLOCK_CYCLES_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clock cycles. Input pulses shorter than three filter clocks are rejected.</description>
                <name>3_CLOCK_CYCLES_INPU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>S_MODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Select peripheral clock divider for input filter sampling clock. Value 0x7 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV0.</description>
                <name>IOCONFILTRCLKDIV0_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV1.</description>
                <name>IOCONFILTRCLKDIV1_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV2.</description>
                <name>IOCONFILTRCLKDIV2_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV3.</description>
                <name>IOCONFILTRCLKDIV3_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV4.</description>
                <name>IOCONFILTRCLKDIV4_</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV5.</description>
                <name>IOCONFILTRCLKDIV5_</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IOCONFILTRCLKDIV6.</description>
                <name>IOCONFILTRCLKDIV6_</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLK_DIV</name>
          </field>
        </fields>
        <name>PIO0_14</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x90</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40048000</baseAddress>
    <description>System configuration (SYSCON)</description>
    <groupName>SYSCON</groupName>
    <interrupts>
      <interrupt>
        <name>BOD</name>
        <value>0xD</value>
      </interrupt>
    </interrupts>
    <name>SYSCON</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>System memory remap</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System memory remap. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM.</description>
                <name>BOOT_LOADER_MODE_IN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>User RAM Mode. Interrupt vectors are re-mapped to Static RAM.</description>
                <name>USER_RAM_MODE_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash.</description>
                <name>USER_FLASH_MODE_INT</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MAP</name>
          </field>
        </fields>
        <name>SYSMEMREMAP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Peripheral reset control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI0 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the SPI0 reset.</description>
                <name>ASSERT_THE_SPI0_RESE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the SPI0 reset.</description>
                <name>CLEAR_THE_SPI0_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPI0_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI1 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the SPI1 reset.</description>
                <name>ASSERT_THE_SPI1_RESE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the SPI1 reset.</description>
                <name>CLEAR_THE_SPI1_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPI1_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART fractional baud rate generator (UARTFRG) reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the UARTFRG reset.</description>
                <name>ASSERT_THE_UARTFRG_R</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the UARTFRG reset.</description>
                <name>CLEAR_THE_UARTFRG_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UARTFRG_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART0 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the USART0 reset.</description>
                <name>ASSERT_THE_USART0_RE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the USART0 reset.</description>
                <name>CLEAR_THE_USART0_RES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>USART0_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>U1ART1 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the UART reset.</description>
                <name>ASSERT_THE_UART_RESE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the UART1 reset.</description>
                <name>CLEAR_THE_UART1_RESE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UART1_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>UART2 reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the UART2 reset.</description>
                <name>ASSERT_THE_UART2_RES</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the UART2 reset.</description>
                <name>CLEAR_THE_UART2_RESE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UART2_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the I2C reset.</description>
                <name>ASSERT_THE_I2C_RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the I2C reset.</description>
                <name>CLEAR_THE_I2C_RESET_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2C_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Multi-rate timer (MRT) reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the MRT reset.</description>
                <name>ASSERT_THE_MRT_RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the MRT reset.</description>
                <name>CLEAR_THE_MRT_RESET_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MRT_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the SCT reset.</description>
                <name>ASSERT_THE_SCT_RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the SCT reset.</description>
                <name>CLEAR_THE_SCT_RESET_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCT_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Self wake-up timer (WKT) reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the WKT reset.</description>
                <name>ASSERT_THE_WKT_RESET</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the WKT reset.</description>
                <name>CLEAR_THE_WKT_RESET_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WKT_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO and GPIO pin interrupt reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the GPIO reset.</description>
                <name>ASSERT_THE_GPIO_RESE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the GPIO reset.</description>
                <name>CLEAR_THE_GPIO_RESET</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GPIO_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash controller reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the flash controller reset.</description>
                <name>ASSERT_THE_FLASH_CON</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the flash controller reset.</description>
                <name>CLEAR_THE_FLASH_CONT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASH_RST_N</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog comparator reset control</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Assert the analog comparator reset.</description>
                <name>ASSERT_THE_ANALOG_CO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear the analog comparator controller reset.</description>
                <name>CLEAR_THE_ANALOG_COM</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACMP_RST_N</name>
          </field>
        </fields>
        <name>PRESETCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1FFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>System PLL control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32</description>
            <name>MSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Post divider ratio P. The division ratio is 2 x P.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 1</description>
                <name>P_EQ_1</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 2</description>
                <name>P_EQ_2</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 4</description>
                <name>P_EQ_4</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>P = 8</description>
                <name>P_EQ_8</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PSEL</name>
          </field>
        </fields>
        <name>SYSPLLCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0xC</addressOffset>
        <description>System PLL status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>PLL lock status</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>PLL not locked</description>
                <name>PLL_NOT_LOCKED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PLL locked</description>
                <name>PLL_LOCKED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOCK</name>
          </field>
        </fields>
        <name>SYSPLLSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>System oscillator control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Bypass system oscillator</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Oscillator is not bypassed.</description>
                <name>DISABLED_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN pin bypassing the oscillator. Use this mode when using an external clock source instead of the crystal oscillator.</description>
                <name>ENABLED_PLL_INPUT_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BYPASS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines frequency range for Low-power oscillator.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 - 20 MHz frequency range.</description>
                <name>1__20_MHZ_FREQUENCY</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>15 - 25 MHz frequency range</description>
                <name>15__25_MHZ_FREQUENC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FREQRANGE</name>
          </field>
        </fields>
        <name>SYSOSCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Watchdog oscillator control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Select divider for Fclkana.  wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64</description>
            <name>DIVSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Select watchdog oscillator analog output frequency (Fclkana).</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>0.6 MHz</description>
                <name>0_6_MHZ</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.05 MHz</description>
                <name>1_05_MHZ</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.4 MHz</description>
                <name>1_4_MHZ</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>1.75 MHz</description>
                <name>1_75_MHZ</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.1 MHz</description>
                <name>2_1_MHZ</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.4 MHz</description>
                <name>2_4_MHZ</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2.7 MHz</description>
                <name>2_7_MHZ</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.0 MHz</description>
                <name>3_0_MHZ</name>
                <value>0x8</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.25 MHz</description>
                <name>3_25_MHZ</name>
                <value>0x9</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.5 MHz</description>
                <name>3_5_MHZ</name>
                <value>0xA</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3.75 MHz</description>
                <name>3_75_MHZ</name>
                <value>0xB</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.0 MHz</description>
                <name>4_0_MHZ</name>
                <value>0xC</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.2 MHz</description>
                <name>4_2_MHZ</name>
                <value>0xD</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.4 MHz</description>
                <name>4_4_MHZ</name>
                <value>0xE</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4.6 MHz</description>
                <name>4_6_MHZ</name>
                <value>0xF</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FREQSEL</name>
          </field>
        </fields>
        <name>WDTOSCCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xA0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>System reset status register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>POR reset status</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No POR detected</description>
                <name>NO_POR_DETECTED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>POR detected. Writing a one clears this reset.</description>
                <name>POR_DETECTED_WRITIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>POR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the external RESET pin. External reset status.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No reset event detected.</description>
                <name>NO_RESET_EVENT_DETEC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reset detected. Writing a one clears this reset.</description>
                <name>RESET_DETECTED_WRIT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EXTRST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the Watchdog reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No WDT reset detected</description>
                <name>NO_WDT_RESET_DETECTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>WDT reset detected. Writing a one clears this reset.</description>
                <name>WDT_RESET_DETECTED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the Brown-out detect reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No BOD reset detected</description>
                <name>NO_BOD_RESET_DETECTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>BOD reset detected. Writing a one clears this reset.</description>
                <name>BOD_RESET_DETECTED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Status of the software system reset</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No System reset detected</description>
                <name>NO_SYSTEM_RESET_DETE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>System reset detected. Writing a one clears this reset.</description>
                <name>SYSTEM_RESET_DETECTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSRST</name>
          </field>
        </fields>
        <name>SYSRSTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>System PLL clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>System PLL clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC</description>
                <name>IRC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crystal Oscillator (SYSOSC)</description>
                <name>CRYSTAL_OSCILLATOR_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>CLKIN. External clock input.</description>
                <name>CLKIN_EXTERNAL_CLOC</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>SYSPLLCLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>System PLL clock source update enable</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable system PLL clock source update</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Update clock source</description>
                <name>UPDATE_CLOCK_SOURCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA</name>
          </field>
        </fields>
        <name>SYSPLLCLKUEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x70</addressOffset>
        <description>Main clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Clock source for main clock</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC Oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PLL input</description>
                <name>PLL_INPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>PLL output</description>
                <name>PLL_OUTPUT</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>MAINCLKSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x74</addressOffset>
        <description>Main clock source update enable</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable main clock source update</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Update clock source</description>
                <name>UPDATE_CLOCK_SOURCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA</name>
          </field>
        </fields>
        <name>MAINCLKUEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x78</addressOffset>
        <description>System clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>System AHB clock divider values 0: System clock disabled.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>SYSAHBCLKDIV</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x80</addressOffset>
        <description>System clock control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the clock for the AHB, the APB bridge, the Cortex-M0+ core clocks, SYSCON, and the PMU. This bit is read only and always reads as 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved</description>
                <name>RESERVED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for ROM.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ROM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SRAM.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RAM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for flash register interface.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASHREG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for flash.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for I2C.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>I2C</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for GPIO port registers and GPIO pin interrupt registers.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>GPIO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for switch matrix.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SWM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for state configurable timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for self wake-up timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WKT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for multi-rate timer.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MRT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SPI0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPI0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for SPI1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPI1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for CRC.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CRC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for UART0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UART0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for UART1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UART1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for UART2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UART2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for WWDT.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WWDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock for IOCON block.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCON</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables clock to analog comparator.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable</description>
                <name>DISABLE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable</description>
                <name>ENABLE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACMP</name>
          </field>
        </fields>
        <name>SYSAHBCLKCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1F</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x94</addressOffset>
        <description>UART clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>UART clock divider values.  0: Clock disabled.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>UARTCLKDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE0</addressOffset>
        <description>CLKOUT clock source select</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CLKOUT clock source</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>IRC oscillator</description>
                <name>IRC_OSCILLATOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Crystal oscillator (SYSOSC)</description>
                <name>CRYSTAL_OSCILLATOR_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Watchdog oscillator</description>
                <name>WATCHDOG_OSCILLATOR</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Main clock</description>
                <name>MAIN_CLOCK</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL</name>
          </field>
        </fields>
        <name>CLKOUTSEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE4</addressOffset>
        <description>CLKOUT clock source update enable</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable CLKOUT clock source update</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change</description>
                <name>NO_CHANGE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Update clock source</description>
                <name>UPDATE_CLOCK_SOURCE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA</name>
          </field>
        </fields>
        <name>CLKOUTUEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE8</addressOffset>
        <description>CLKOUT clock divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>CLKOUT clock divider values 0: Disable CLKOUT clock divider.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>CLKOUTDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>UART fractional generator divider value</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Denominator of the fractional divider. DIV is equal to the programmed value +1. Always set to 0xFF to use with the fractional baud rate generator.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>UARTFRGDIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>UART fractional generator multiplier value</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Numerator of the fractional divider. MULT is equal to the programmed value.</description>
            <name>MULT</name>
          </field>
        </fields>
        <name>UARTFRGMULT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>External trace buffer command register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trace start command</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Trace stop command</description>
            <name>STOP</name>
          </field>
        </fields>
        <name>EXTTRACECMD</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x100</addressOffset>
        <description>POR captured PIO status 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>State of PIO0_17 through PIO0_0 at power-on reset</description>
            <name>PIOSTAT</name>
          </field>
        </fields>
        <name>PIOPORCAP0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x134</addressOffset>
        <description>Peripheral clock 6 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x138</addressOffset>
        <description>Peripheral clock 5 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x13C</addressOffset>
        <description>Peripheral clock 4 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x140</addressOffset>
        <description>Peripheral clock 3 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x144</addressOffset>
        <description>Peripheral clock 2 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x148</addressOffset>
        <description>Peripheral clock 1 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14C</addressOffset>
        <description>Peripheral clock 0 to the IOCON block for programmable glitch filter</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>IOCON glitch filter clock divider values 0: Disable IOCONFILTR_PCLK.  1: Divide by 1. to 255: Divide by 255.</description>
            <name>DIV</name>
          </field>
        </fields>
        <name>IOCONCLKDIV0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x150</addressOffset>
        <description>Brown-Out Detect</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD reset level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is .</description>
                <name>LEVEL_0_THE_RESET_A</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is .</description>
                <name>LEVEL_1_THE_RESET_A</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is .</description>
                <name>LEVEL_2_THE_RESET_A</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3: The reset assertion threshold voltage is ; the reset de-assertion threshold voltage is.</description>
                <name>LEVEL_3_THE_RESET_A</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTLEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>BOD interrupt level</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 0: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is</description>
                <name>LEVEL_0_THE_INTERRU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 1:The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is .</description>
                <name>LEVEL_1THE_INTERRUP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 2: The interrupt assertion threshold voltage is  ; the interrupt de-assertion threshold voltage is .</description>
                <name>LEVEL_2_THE_INTERRU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Level 3: The interrupt assertion threshold voltage is ; the interrupt de-assertion threshold voltage is .</description>
                <name>LEVEL_3_THE_INTERRU</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODINTVAL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD reset enable</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disable reset function.</description>
                <name>DISABLE_RESET_FUNCTI</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enable reset function.</description>
                <name>ENABLE_RESET_FUNCTIO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BODRSTENA</name>
          </field>
        </fields>
        <name>BODCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x154</addressOffset>
        <description>System tick counter calibration</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1A</bitWidth>
            <description>System tick timer calibration value</description>
            <name>CAL</name>
          </field>
        </fields>
        <name>SYSTCKCAL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x170</addressOffset>
        <description>IQR delay. Allows trade-off between interrupt latency and determinism.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>8-bit latency value</description>
            <name>LATENCY</name>
          </field>
        </fields>
        <name>IRQLATENCY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x10</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x174</addressOffset>
        <description>NMI Source Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 is 1. See Table 58 for the list of interrupt sources and their IRQ numbers.</description>
            <name>IRQNO</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0.</description>
            <name>NMIEN</name>
          </field>
        </fields>
        <name>NMISRC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>Start logic 0 pin wake-up enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 0 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 1 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 2 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 3 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 4 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 5 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 6 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>GPIO pin interrupt 7 wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PINT7</name>
          </field>
        </fields>
        <name>STARTERP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x214</addressOffset>
        <description>Start logic 1 interrupt wake-up enable register</description>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>WWDT interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WWDT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Self wake-up timer interrupt wake-up</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled</description>
                <name>DISABLED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled</description>
                <name>ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WKT</name>
          </field>
        </fields>
        <name>STARTERP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x230</addressOffset>
        <description>Power-down states in deep-sleep mode</description>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD power-down control for Deep-sleep and Power-down mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator power-down control for Deep-sleep and Power-down mode. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDTOSC_PD</name>
          </field>
        </fields>
        <name>PDSLEEPCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x234</addressOffset>
        <description>Power-down states for wake-up from deep-sleep</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator output wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRCOUT_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator power-down wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASH_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Crystal oscillator wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator wake-up configuration. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDTOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System PLL wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSPLL_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog comparator wake-up configuration</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACMP</name>
          </field>
        </fields>
        <name>PDAWAKECFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xEDF0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x238</addressOffset>
        <description>Power configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator output power</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRCOUT_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>IRC oscillator power down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IRC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Flash power down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>FLASH_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>BOD power down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BOD_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Crystal oscillator power down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Watchdog oscillator power down. Changing this bit to powered-down has no effect when the LOCK bit in the WWDT MOD register is set. In this case, the watchdog oscillator is always running.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>WDTOSC_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>System PLL power down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYSPLL_PD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Analog comparator power down</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered</description>
                <name>POWERED</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Powered down</description>
                <name>POWERED_DOWN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ACMP</name>
          </field>
        </fields>
        <name>PDRUNCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xEDF0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x3F4</addressOffset>
        <description>Device ID</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>TBD</description>
            <name>DEVICEID</name>
          </field>
        </fields>
        <name>DEVICE_ID</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x178</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x17C</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x180</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x184</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x188</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18C</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL5</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x190</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL6</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x194</addressOffset>
        <description>GPIO Pin Interrupt Select register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Pin number select for pin interrupt or pattern match engine input. (PIO0_0 to PIO0_17 correspond to numbers 0 to 17).</description>
            <name>INTPIN</name>
          </field>
        </fields>
        <name>PINTSEL7</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40050000</baseAddress>
    <description>I2C-bus interface</description>
    <groupName>I2C</groupName>
    <interrupts>
      <interrupt>
        <name>I2C</name>
        <value>0x8</value>
      </interrupt>
    </interrupts>
    <name>I2C</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Configuration for shared functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Enable. When disabled, configurations settings for the Master function are not changed, but the Master function is internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C Master function is disabled.</description>
                <name>DISABLED_THE_I2C_MA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C Master function is enabled.</description>
                <name>ENABLED_THE_I2C_MAS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Enable. When disabled, configurations settings for the Slave function are not changed, but the Slave function is internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C slave function is disabled.</description>
                <name>DISABLED_THE_I2C_SL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C slave function is enabled.</description>
                <name>ENABLED_THE_I2C_SLA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Enable. When disabled, configurations settings for the Monitor function are not changed, but the Monitor function is internally reset.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The I2C monitor function is disabled.</description>
                <name>DISABLED_THE_I2C_MO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The I2C monitor function is enabled.</description>
                <name>ENABLED_THE_I2C_MON</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>I2C bus Time-out Enable. When disabled, timeout flags will be automatically cleared.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. Time-out function is disabled.</description>
                <name>DISABLED_TIME_OUT_F</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Time-out function is enabled. Both types of time-out flags will be generated and will cause interrupts if they are enabled. Typically, only one timeout will be used in a system.</description>
                <name>ENABLED_TIME_OUT_FU</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor function Clock Stretching.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The monitor function will not perform clock stretching. Software may not always be able to read data provided by the monitor function before it is overwritten. This mode may be used when non-invasive monitoring is critical.</description>
                <name>DISABLED_THE_MONITO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The monitor function will perform clock stretching in order to ensure that software can read all incoming data supplied by the monitor function.</description>
                <name>ENABLED_THE_MONITOR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONCLKSTR</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Status register for Master, Slave, and Monitor functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending. Indicates whether the Master function needs software service. This flag will cause an interrupt when set if enabled via the INTENSET register.  The MSTPENDING flag is automatically cleared when a 1 is written to the MSTCONTINUE bit in the MSTCTL register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No service needed. The Master function does not currently need service.</description>
                <name>NO_SERVICE_NEEDED_T</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Service needed. The Master function needs service. Information on what is needed can be found in the adjacent MSTSTATE field.</description>
                <name>SERVICE_NEEDED_THE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master State code. Each value of this field indicates a specific required service for the Master function.  All other values are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The Master function is available to be used for a new transaction.</description>
                <name>IDLE_THE_MASTER_FUN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Receive ready. Received data  available (Master Receiver mode). Address plus Read was previously sent and Acknowledged by slave.</description>
                <name>RECEIVE_READY_RECEI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Transmit ready. Data can be transmitted (Master Transmitter mode). Address plus Write was previously sent and Acknowledged by slave.</description>
                <name>TRANSMIT_READY_DATA</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Address. Slave Nacked address.</description>
                <name>ADDRESS_SLAVE_NACKE</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data. Slave Nacked transmitted data.</description>
                <name>DATA_SLAVE_NACKED_T</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MSTCONTINUE.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No loss. No Arbitration Loss has occurred.</description>
                <name>NO_LOSS_NO_ARBITRAT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Arbitration loss. The Master function has experienced an Arbitration Loss. At this point, the Master function has already stopped driving the bus and gone to an idle state. Software can respond by doing nothing, or by sending a Start in order to attempt to gain control of the bus when it next becomes idle.</description>
                <name>ARBITRATION_LOSS_TH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag. This flag can be cleared by software writing a 1 to this bit. It is also cleared automatically a 1 is written to MstContinue.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No Start/Stop Error has occurred.</description>
                <name>NO_STARTSTOP_ERROR_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start/stop error has occurred. The Master function has experienced a Start/Stop Error. A Start or Stop was detected at a time when it is not allowed by the I2C specification. The Master interface has stopped driving the bus and gone to an idle state, no action is required. A request for a Start could be made, or software could attempt to insure that the bus has not stalled.</description>
                <name>STARTSTOP_ERROR_HAS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending. Indicates whether the Slave function needs software service. This flag will cause an interrupt when set if enabled via INTENSET.  The SLVPENDING flag is read-only and is automatically cleared when a 1 is written to the SLVCONTINUE bit in the MSTCTL register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No service needed. The Slave function does not currently need service.</description>
                <name>NO_SERVICE_NEEDED_T</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Service needed. The Slave function needs service. Information on what is needed can be found in the adjacent SLVSTATE field.</description>
                <name>SERVICE_NEEDED_THE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave State code. Each value of this field indicates a specific required service for the Slave function. All other values are reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Received. Address plus R/W received. At least one of the four slave addresses has been matched by hardware.</description>
                <name>RECEIVED_ADDRESS_PL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data available. Received data is available (Slave Receiver mode).</description>
                <name>DATA_AVAILABLE_RECE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data ready for transmit. Data can be transmitted (Slave Transmitter mode).</description>
                <name>DATA_READY_FOR_TRANS</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSTATE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching. Indicates when the slave function is stretching the I2C clock. This is needed in order to gracefully invoke Deep Sleep or Power-down modes during slave operation. This read-only flag reflects the slave function status in real time.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stretching. The slave function is currently stretching the I2C bus clock. Deep-Sleep or Power-down mode cannot be entered at this time.</description>
                <name>STRETCHING_THE_SLAV</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not stretching. The slave function is not currently stretching the I 2C bus clock. Deep-sleep or Power-down mode could be entered at this time.</description>
                <name>NOT_STRETCHING_THE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Slave address match Index. This field is valid when the I2C slave function has been selected by receiving an address that matches one of the slave addresses defined by any enabled slave address registers, and provides an identification of the address that was matched. It is possible that more than one address could be matched, but only one match can be reported here.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address 0 was matched.</description>
                <name>SLAVE_ADDRESS_0_WAS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address 1 was matched.</description>
                <name>SLAVE_ADDRESS_1_WAS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address 2 was matched.</description>
                <name>SLAVE_ADDRESS_2_WAS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave address 3 was matched.</description>
                <name>SLAVE_ADDRESS_3_WAS_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVIDX</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave selected flag. SLVSEL is set after an address match when software tells the Slave function to acknowledge the address. It is cleared when another address cycle presents an address that does not match an enabled address on the Slave function, when slave software decides to Nack a matched address, or when there is a Stop detected on the bus. SLVSEL is not cleared if software Nacks data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not selected. The Slave function is not currently selected.</description>
                <name>NOT_SELECTED_THE_SL</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selected. The Slave function is currently selected.</description>
                <name>SELECTED_THE_SLAVE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag. This flag will cause an interrupt when set if enabled via INTENSET. This flag can be cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not deselected. The Slave function has not become deselected. This does not mean that it is currently selected. That information can be found in the SLVSEL flag.</description>
                <name>NOT_DESELECTED_THE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Deselected. The Slave function has become deselected. This is specifically caused by the SLVSEL flag changing from 1 to 0. See the description of SLVSEL for details on when that event occurs.</description>
                <name>DESELECTED_THE_SLAV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready. This flag is cleared when the MONRXDAT register is read.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No data. The Monitor function does not currently have data available.</description>
                <name>NO_DATA_THE_MONITOR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data waiting. The Monitor function has data waiting to be read.</description>
                <name>DATA_WAITING_THE_MO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No overrun. Monitor data has not overrun.</description>
                <name>NO_OVERRUN_MONITOR_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Overrun. A Monitor data overrun has occurred. This can only happen when Monitor clock stretching not enabled via the MONCLKSTR bit in the CFG register. Writing 1 to this bit clears the flag.</description>
                <name>OVERRUN_A_MONITOR_D</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Active flag. This flag indicates when the Monitor function considers the I2C bus to be active. Active is defined here as when some Master is on the bus: a bus Start has occurred more recently than a bus Stop.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Inactive. The Monitor function considers the I2C bus to be inactive.</description>
                <name>INACTIVE_THE_MONITO</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Active. The Monitor function considers the I2C bus to be active.</description>
                <name>ACTIVE_THE_MONITOR_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONACTIVE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag. This flag is set when the Monitor function sees the I2C bus change from active to inactive. This can be used by software to decide when to process data accumulated by the Monitor function. This flag will cause an interrupt when set if enabled via the INTENSET register . The flag can be cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not idle. The I2C bus is not idle, or this flag has been cleared by software.</description>
                <name>NOT_IDLE_THE_I2C_BU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Idle. The I2C bus has gone idle at least once since the last time this flag was cleared by software.</description>
                <name>IDLE_THE_I2C_BUS_HA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Time-out Interrupt flag. Indicates when the time between events has been longer than the time specified by the TIMEOUT register. Events include Start, Stop, and clock edges. The case of SCL remaining low longer than TIMEOUT is not reported by this flag, it is reported in by the SCL Time-out flag. The flag is cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. I2C bus events have not caused a timeout.</description>
                <name>NO_TIME_OUT_I2C_BUS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event time-out. The time between I2C bus events has been longer than the time specified by the I2C Timeout register.</description>
                <name>EVENT_TIME_OUT_THE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Time-out Interrupt flag. Indicates when SCL has remained low longer than the time specific by the TIMEOUT register. The flag is cleared by writing a 1 to this bit.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No time-out. SCL low time has not caused a timeout.</description>
                <name>NO_TIME_OUT_SCL_LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Time-out. SCL low time has caused a timeout.</description>
                <name>TIME_OUT_SCL_LOW_TI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x801</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Interrupt Enable Set and read register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MstPending interrupt is disabled.</description>
                <name>THE_MSTPENDING_INTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MstPending interrupt is enabled.</description>
                <name>THE_MSTPENDING_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MstArbLoss interrupt is disabled.</description>
                <name>THE_MSTARBLOSS_INTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MstArbLoss interrupt is enabled.</description>
                <name>THE_MSTARBLOSS_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTARBLOSSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MstStStpErr interrupt is disabled.</description>
                <name>THE_MSTSTSTPERR_INTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MstStStpErr interrupt is enabled.</description>
                <name>THE_MSTSTSTPERR_INTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTSTPERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SlvPending interrupt is disabled.</description>
                <name>THE_SLVPENDING_INTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SlvPending interrupt is enabled.</description>
                <name>THE_SLVPENDING_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVPENDINGEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SlvNotStr interrupt is disabled.</description>
                <name>THE_SLVNOTSTR_INTERR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SlvNotStr interrupt is enabled.</description>
                <name>THE_SLVNOTSTR_INTERR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVNOTSTREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SlvDeSel interrupt is disabled.</description>
                <name>THE_SLVDESEL_INTERRU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SlvDeSel interrupt is enabled.</description>
                <name>THE_SLVDESEL_INTERRU</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SLVDESELEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MonRdy interrupt is disabled.</description>
                <name>THE_MONRDY_INTERRUPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MonRdy interrupt is enabled.</description>
                <name>THE_MONRDY_INTERRUPT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MonOv interrupt is disabled.</description>
                <name>THE_MONOV_INTERRUPT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MonOv interrupt is enabled.</description>
                <name>THE_MONOV_INTERRUPT_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MonIdle interrupt is disabled.</description>
                <name>THE_MONIDLE_INTERRUP</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The MonIdle interrupt is enabled.</description>
                <name>THE_MONIDLE_INTERRUP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONIDLEEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Timeout interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Event Timeout interrupt is disabled.</description>
                <name>THE_EVENT_TIMEOUT_IN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The Event Timeout interrupt is enabled.</description>
                <name>THE_EVENT_TIMEOUT_IN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EVENTTIMEOUTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Timeout interrupt Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCL Timeout interrupt is disabled.</description>
                <name>THE_SCL_TIMEOUT_INTE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCL Timeout interrupt is enabled.</description>
                <name>THE_SCL_TIMEOUT_INTE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SCLTIMEOUTEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable Clear register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending interrupt clear. Writing 1 to this bit clears the corresponding bit in the INTENSET register if implemented.</description>
            <name>MSTPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss interrupt clear.</description>
            <name>MSTARBLOSSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error interrupt clear.</description>
            <name>MSTSTSTPERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending interrupt clear.</description>
            <name>SLVPENDINGCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching interrupt clear.</description>
            <name>SLVNOTSTRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselect interrupt clear.</description>
            <name>SLVDESELCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor data Ready interrupt clear.</description>
            <name>MONRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overrun interrupt clear.</description>
            <name>MONOVCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle interrupt clear.</description>
            <name>MONIDLECLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Timeout interrupt clear.</description>
            <name>EVENTTIMEOUTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Timeout interrupt clear.</description>
            <name>SCLTIMEOUTCLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Time-out value register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Timeout time value, bottom four bits. These are hard-wired to 0xF. This gives a minimum timeout of 16 I2C function clocks and also a timeout resolution of 16 I2C function clocks.</description>
            <name>TOMIN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0xC</bitWidth>
            <description>Timeout time value. Specifies the timeout interval value in increments of 16 I2C function clocks, as defined by the CLKDIV register. To change this value while I2C is in operation, disable all time-outs, write a new value to TIMEOUT, then re-enable time-outs. 0x000 = A time-out will occur after 16 counts of the I2C function clock. 0x001 = A time-out will occur after 32 counts of the I2C function clock. ... 0xFFF = A timeout will occur after 65,536 counts of the I2C function clock.</description>
            <name>TO</name>
          </field>
        </fields>
        <name>TIMEOUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>Clock pre-divider for the entire I2C block. This determines what time increments are used for the MSTTIME and SLVTIME registers.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This field controls how the clock (PCLK) is used by the I2C functions that need an internal clock in order to operate. 0x0000 = PCLK is used directly by the I2C function. 0x0001 = PCLK is divided by 2 before use by the I 2C function. 0x0002 = PCLK is divided by 3 before use by the I 2C function. ... 0xFFFF = PCLK is divided by 65,536 before use by the I2C function.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>DIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Interrupt Status register for Master, Slave, and Monitor functions.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Pending.</description>
            <name>MSTPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Arbitration Loss flag.</description>
            <name>MSTARBLOSS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start/Stop Error flag.</description>
            <name>MSTSTSTPERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Pending.</description>
            <name>SLVPENDING</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Not Stretching status.</description>
            <name>SLVNOTSTR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Deselected flag.</description>
            <name>SLVDESEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Ready.</description>
            <name>MONRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Overflow flag.</description>
            <name>MONOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Idle flag.</description>
            <name>MONIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Event Timeout Interrupt flag.</description>
            <name>EVENTTIMEOUT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x19</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCL Timeout Interrupt flag.</description>
            <name>SCLTIMEOUT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Master control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Continue. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Master function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation.</description>
                <name>CONTINUE_INFORMS_TH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTCONTINUE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Start control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start. A Start will be generated on the I2C bus at the next allowed time.</description>
                <name>START_A_START_WILL_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master Stop control. This bit is write-only.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Stop. A Stop will be generated on the I2C bus at the next allowed time, preceded by a Nack to the slave if the master is receiving data from the slave (Master Receiver mode).</description>
                <name>STOP_A_STOP_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSTOP</name>
          </field>
        </fields>
        <name>MSTCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Master timing configuration.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL Low time. Specifies the minimum low time that will be asserted by this master on SCL. Other devices on the bus (masters or slaves) could lengthen this time. This corresponds to the parameter t LOW in the I2C bus specification. I2C bus specification parameters tBUF and tSU;STA have the same values and are also controlled by MSTSCLLOW.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL low time is 2 clocks of the I2C clock pre-divider.</description>
                <name>2_CLOCKS_MINIMUM_SC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL low time is 3 clocks of the I2C clock pre-divider.</description>
                <name>3_CLOCKS_MINIMUM_SC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL low time is 4 clocks of the I2C clock pre-divider.</description>
                <name>4_CLOCKS_MINIMUM_SC</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL low time is 5 clocks of the I2C clock pre-divider.</description>
                <name>5_CLOCKS_MINIMUM_SC</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL low time is 6 clocks of the I2C clock pre-divider.</description>
                <name>6_CLOCKS_MINIMUM_SC</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL low time is 7 clocks of the I2C clock pre-divider.</description>
                <name>7_CLOCKS_MINIMUM_SC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL low time is 8 clocks of the I2C clock pre-divider.</description>
                <name>8_CLOCKS_MINIMUM_SC</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL low time is 9 clocks of the I2C clock pre-divider.</description>
                <name>9_CLOCKS_MINIMUM_SC</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLLOW</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Master SCL High time. Specifies the minimum high time that will be asserted by this master on SCL. Other masters in a multi-master system could shorten this time. This corresponds to the parameter tHIGH in the I2C bus specification. I2C bus specification parameters tSU;STO and tHD;STA have the same values and are also controlled by MSTSCLHIGH.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 clocks. Minimum SCL high time is 2 clock of the I2C clock pre-divider.</description>
                <name>2_CLOCKS_MINIMUM_SC</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>3 clocks. Minimum SCL high time is 3 clocks of the I2C clock pre-divider .</description>
                <name>3_CLOCKS_MINIMUM_SC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>4 clocks. Minimum SCL high time is 4 clock of the I2C clock pre-divider.</description>
                <name>4_CLOCKS_MINIMUM_SC</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>5 clocks. Minimum SCL high time is 5 clock of the I2C clock pre-divider.</description>
                <name>5_CLOCKS_MINIMUM_SC</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>6 clocks. Minimum SCL high time is 6 clock of the I2C clock pre-divider.</description>
                <name>6_CLOCKS_MINIMUM_SC</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 clocks. Minimum SCL high time is 7 clock of the I2C clock pre-divider.</description>
                <name>7_CLOCKS_MINIMUM_SC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 clocks. Minimum SCL high time is 8 clock of the I2C clock pre-divider.</description>
                <name>8_CLOCKS_MINIMUM_SC</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 clocks. Minimum SCL high time is 9 clocks of the I2C clock pre-divider.</description>
                <name>9_CLOCKS_MINIMUM_SC</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MSTSCLHIGH</name>
          </field>
        </fields>
        <name>MSTTIME</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x77</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>Combined Master receiver and transmitter data register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Master function data register. Read: read the most recently received data for the Master function. Write: transmit data using the Master function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>MSTDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>Slave control register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Continue.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continue. Informs the Slave function to continue to the next operation. This must done after writing transmit data, reading received data, or any other housekeeping related to the next bus operation.</description>
                <name>CONTINUE_INFORMS_TH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SlvContinue</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Nack.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No effect.</description>
                <name>NO_EFFECT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Nack. Causes the Slave function to Nack the master when the slave is receiving data from the master (Slave Receiver mode).</description>
                <name>NACK_CAUSES_THE_SLA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SlvNack</name>
          </field>
        </fields>
        <name>SLVCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>Combined Slave receiver and transmitter data register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Slave function data register. Read: read the most recently received data for the Slave function. Write: transmit data using the Slave function.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>SLVDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>Slave Qualification for address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Reserved. Read value is undefined, only zero should be written.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SLVQUAL0 field is used as a logical mask for matching address 0.</description>
                <name>THE_SLVQUAL0_FIELD_I</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SLVQUAL0 field is used to extend address 0 matching in a range of addresses.</description>
                <name>THE_SLVQUAL0_FIELD_I</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>QUALMODE0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Slave address Qualifier for address 0. A value of 0 causes the address in SLVADR0 to be used as-is, assuming that it is enabled. If QUALMODE0 = 0, any bit in this field which is set to 1 will cause an automatic match of the corresponding bit of the received address when it is compared to the SLVADR0 register. If QUALMODE0 = 1, an address range is matched for address 0. This range extends from the value defined by SLVADR0 to the address defined by SLVQUAL0 (address matches when SLVADR0[7:1] less or equal than  received address less or equal than SLVQUAL0[7:1]).</description>
            <name>SLVQUAL0</name>
          </field>
        </fields>
        <name>SLVQUAL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x80</addressOffset>
        <description>Monitor receiver data register.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Monitor function Receiver Data. This reflects every data byte that passes on the I2C pins, and adds indication of Start, Repeated Start, and data Nack.</description>
            <name>MONRXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No detect. The monitor function has not detected a Start event on the I2C bus.</description>
                <name>NO_DETECT_THE_MONIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Start detect. The monitor function has detected a Start event on the I2C bus.</description>
                <name>START_DETECT_THE_MO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONSTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Repeated Start.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No start detect. The monitor function has not detected a Repeated Start event on the I2C bus.</description>
                <name>NO_START_DETECT_THE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Repeated start detect. The monitor function has detected a Repeated Start event on the I 2C bus.</description>
                <name>REPEATED_START_DETEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONRESTART</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Monitor Received Nack.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Acknowledged. The data currently being provided by the monitor function was acknowledged by at least one master or slave receiver.</description>
                <name>ACKNOWLEDGED_THE_DA</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not acknowledged. The data currently being provided by the monitor function was not acknowledged by any receiver.</description>
                <name>NOT_ACKNOWLEDGED_TH</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>MONNACK</name>
          </field>
        </fields>
        <name>MONRXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x48</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register.</description>
                <name>ENABLED_SLAVE_ADDRE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Seven bit slave address that is compared to received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register.</description>
                <name>ENABLED_SLAVE_ADDRE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Seven bit slave address that is compared to received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register.</description>
                <name>ENABLED_SLAVE_ADDRE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Seven bit slave address that is compared to received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>Slave address 0.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Address n Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. Slave Address n is enabled and will be recognized with any changes specified by the SLVQUAL0 register.</description>
                <name>ENABLED_SLAVE_ADDRE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignored Slave Address n is ignored.</description>
                <name>IGNORED_SLAVE_ADDRES</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SADISABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>Seven bit slave address that is compared to received addresses if enabled.</description>
            <name>SLVADR</name>
          </field>
        </fields>
        <name>SLVADR3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x1</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40058000</baseAddress>
    <description>SPI</description>
    <groupName>SPI</groupName>
    <interrupts>
      <interrupt>
        <name>SPI0</name>
        <value>0x0</value>
      </interrupt>
    </interrupts>
    <name>SPI0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SPI Configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SPI is disabled and the internal state machine and counters are reset.</description>
                <name>DISABLED_THE_SPI_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SPI is enabled for operation.</description>
                <name>ENABLED_THE_SPI_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>Enable</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master mode select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output.</description>
                <name>SLAVE_MODE_THE_SPI_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input.</description>
                <name>MASTER_MODE_THE_SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>Master</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. Data is transmitted and received in standard MSB first order.</description>
                <name>STANDARD_DATA_IS_TR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reverse. Data is transmitted and received in reverse order (LSB first).</description>
                <name>REVERSE_DATA_IS_TRA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LSBF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Phase select. .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Change. The SPI captures serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is changed on the following edge.</description>
                <name>CHANGE_THE_SPI_CAPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture. The SPI changes serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is captured on the following edge.</description>
                <name>CAPTURE_THE_SPI_CHA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The rest state of the clock (between frames) is low.</description>
                <name>LOW_THE_REST_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The rest state of the clock (between frames) is high.</description>
                <name>HIGH_THE_REST_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>Loop</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL pin is active low. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is not inverted relative to the pins.</description>
                <name>LOW_THE_SSEL_PIN_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL pin is active high. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is inverted relative to the pins.</description>
                <name>HIGH_THE_SSEL_PIN_I</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SPI Delay register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between SSEL assertion and the beginning of a data frame.  There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>PRE_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between the end of a data frame and SSEL deassertion.  0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>POST_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the minimum amount of time between adjacent data frames.  0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>FRAME_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the minimum amount of time that the SSELs are deasserted between transfers.  0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times.</description>
            <name>TRANSFER_DELAY</name>
          </field>
        </fields>
        <name>DLY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SPI Status. Some status flags can be cleared by writing a 1 to that bit position</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT register.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT or TXDATCTL until the data is moved to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag. This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TxUr flag is set. Data transmitted by the SPI should be considered undefined if TxUr is set.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software.</description>
            <name>SSD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stalled status flag. This indicates whether the SPI is currently in a stall condition.</description>
            <name>STALLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes Idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FrameDelay and TransferDelay to be inserted.</description>
            <name>ENDTRANSFER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data.</description>
            <name>IDLE</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x102</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when receiver data is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when receiver data is available.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when receiver data is available in the RXDAT register.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when the transmitter holding register is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when the transmitter holding register is available.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when data may be written to TXDAT.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when a receiver overrun occurs.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated if a receiver overrun occurs.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when the transmitter underruns.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated if the transmitter underruns.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when one or more Slave Select is asserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when any Slave Select transitions from deasserted to asserted.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when any Slave Select transitions from deasserted to asserted.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when all Slave Selects are deasserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when all asserted Slave Selects transition to deasserted.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when all asserted Slave Selects transition to deasserted.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSDEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>SSDEN</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>SPI Receive Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Receiver Data. This contains the next piece of received data. The number of bits that are used depends on the FLen setting in TXCTL / TXDATCTL.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of the  SSEL pin to be saved along with received data. The value will reflect the SSEL pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
            <name>RXSSELN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start of Transfer flag. This flag will be 1 if this is the first frame after SSEL went from  deasserted to  asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the frame length is greater than 16 bit.</description>
            <name>SOT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>SPI Transmit Data with Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 1 to 16 bits of data to be transmitted.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select . This field controls what is output for SSEL in master mode.  The active state of the SSEL function is configured by bits in the CFG register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL  asserted.</description>
                <name>SSEL_ASSERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL not asserted.</description>
                <name>SSEL_NOT_ASSERTED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSELN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data.</description>
                <name>SSEL_NOT_DEASSERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL deasserted. This piece of data is treated as the end of a transfer. SSELs will be deasserted at the end of this piece of data.</description>
                <name>SSEL_DEASSERTED_THI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame. Between frames, a delay may be inserted, as defined by the Frame_delay value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data not EOF. This piece of data transmitted is not treated as the end of a frame.</description>
                <name>DATA_NOT_EOF_THIS_P</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted.</description>
                <name>DATA_EOF_THIS_PIECE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver to simplify the transmit process.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received.</description>
                <name>READ_RECEIVED_DATA_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated.</description>
                <name>IGNORE_RECEIVED_DATA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Frame Length. Specifies the frame length from 1 to 16 bits. Note that frame lengths greater than 16 bits are supported by multiple sequential frames Note that if a 1-bit frame is selected, the master function will always insert a delay with a length of one SCK time following the single clock seen on the SCK pin. 0x0 = Data frame is 1 bit in length. 0x1 = Data frame is 1 bit in length. 0x2 = Data frame is 3 bits in length. ... 0xF = Data frame is 16 bits in length.</description>
            <name>FLEN</name>
          </field>
        </fields>
        <name>TXDATCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>SPI Transmit Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 4 to 16 bits of data to be transmitted.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI Transmit Control</description>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select.</description>
            <name>TX_SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer.</description>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame.</description>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore.</description>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Frame Length.</description>
            <name>FLEN</name>
          </field>
        </fields>
        <name>TXCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI clock Divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Rate divider value -1. Specifies how the PCLK for the SPI is divided to produce the SPI clock rate in master mode.  DIVVAL is -1 encoded such that the value 0 results in PCLK/1, the value 1 results in PCLK/2, etc. the maximum possible divide is for the value 0xFFFF, which results in PCLK/65536.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>DIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>SPI Interrupt Status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert.</description>
            <name>SSD</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4005C000</baseAddress>
    <derivedFrom>SPI0</derivedFrom>
    <description>SPI</description>
    <groupName>SPI</groupName>
    <interrupts>
      <interrupt>
        <name>SPI1</name>
        <value>0x1</value>
      </interrupt>
    </interrupts>
    <name>SPI1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SPI Configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SPI enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The SPI is disabled and the internal state machine and counters are reset.</description>
                <name>DISABLED_THE_SPI_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The SPI is enabled for operation.</description>
                <name>ENABLED_THE_SPI_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>Enable</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Master mode select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave mode. The SPI will operate in slave mode. SCK, MOSI, and the SSEL signals are inputs, MISO is an output.</description>
                <name>SLAVE_MODE_THE_SPI_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master mode. The SPI will operate in master mode. SCK, MOSI, and the SSEL signals are outputs, MISO is an input.</description>
                <name>MASTER_MODE_THE_SPI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>Master</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>LSB First mode enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Standard. Data is transmitted and received in standard MSB first order.</description>
                <name>STANDARD_DATA_IS_TR</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reverse. Data is transmitted and received in reverse order (LSB first).</description>
                <name>REVERSE_DATA_IS_TRA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LSBF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Phase select. .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Change. The SPI captures serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is changed on the following edge.</description>
                <name>CHANGE_THE_SPI_CAPT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Capture. The SPI changes serial data on the first clock transition of the frame (when the clock changes away from the rest state). Data is captured on the following edge.</description>
                <name>CAPTURE_THE_SPI_CHA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPHA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clock Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The rest state of the clock (between frames) is low.</description>
                <name>LOW_THE_REST_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The rest state of the clock (between frames) is high.</description>
                <name>HIGH_THE_REST_STATE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Loopback mode enable. Loopback mode applies only to Master mode, and connects transmit and receive data connected together to allow simple software testing.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled.</description>
                <name>DISABLED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled.</description>
                <name>ENABLED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>Loop</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SSEL Polarity select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low. The SSEL pin is active low. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is not inverted relative to the pins.</description>
                <name>LOW_THE_SSEL_PIN_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High. The SSEL pin is active high. The value in the SSEL fields of the RXDAT, TXDATCTL, and TXCTL registers related to SSEL is inverted relative to the pins.</description>
                <name>HIGH_THE_SSEL_PIN_I</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SPOL</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SPI Delay register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between SSEL assertion and the beginning of a data frame.  There is always one SPI clock time between SSEL assertion and the first clock edge. This is not considered part of the pre-delay. 0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>PRE_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the amount of time between the end of a data frame and SSEL deassertion.  0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>POST_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the minimum amount of time between adjacent data frames.  0x0 = No additional time is inserted. 0x1 = 1 SPI clock time is inserted. 0x2 = 2 SPI clock times are inserted. ... 0xF = 15 SPI clock times are inserted.</description>
            <name>FRAME_DELAY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Controls the minimum amount of time that the SSELs are deasserted between transfers.  0x0 = The minimum time that SSEL is deasserted is 1 SPI clock time. (Zero added time.) 0x1 = The minimum time that SSEL is deasserted is 2 SPI clock times. 0x2 = The minimum time that SSEL is deasserted is 3 SPI clock times. ... 0xF = The minimum time that SSEL is deasserted is 16 SPI clock times.</description>
            <name>TRANSFER_DELAY</name>
          </field>
        </fields>
        <name>DLY</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SPI Status. Some status flags can be cleared by writing a 1 to that bit position</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDAT register.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDAT or TXDATCTL until the data is moved to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag. This flag is set when the beginning of a received character is detected while the receiver buffer is still in use. If this occurs, the receiver buffer contents are preserved, and the incoming data is lost. Data received by the SPI should be considered undefined if RxOv is set.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag. This flag applies only to slave mode (Master = 0). In this case, the transmitter must begin sending new data on the next input clock if the transmitter is idle. If that data is not available in the transmitter holding register at that point, there is no data to transmit and the TxUr flag is set. Data transmitted by the SPI should be considered undefined if TxUr is set.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert. This flag is set whenever any slave select transitions from deasserted to asserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become busy, and allows waking up the device from reduced power modes when a slave mode access begins. This flag is cleared by software.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert. This flag is set whenever any asserted slave selects transition to deasserted, in both master and slave modes. This allows determining when the SPI transmit/receive functions become idle. This flag is cleared by software.</description>
            <name>SSD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Stalled status flag. This indicates whether the SPI is currently in a stall condition.</description>
            <name>STALLED</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End Transfer control bit. Software can set this bit to force an end to the current transfer when the transmitter finishes any activity already in progress, as if the EOT flag had been set prior to the last transmission. This capability is included to support cases where it is not known when transmit data is written that it will be the end of a transfer. The bit is cleared when the transmitter becomes Idle as the transfer comes to an end. Forcing an end of transfer in this manner causes any specified FrameDelay and TransferDelay to be inserted.</description>
            <name>ENDTRANSFER</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Idle status flag. This bit is 1 whenever the SPI master function is fully idle. This means that the transmit holding register is empty and the transmitter is not in the process of sending data.</description>
            <name>IDLE</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x102</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SPI Interrupt Enable read and Set. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when receiver data is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when receiver data is available.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when receiver data is available in the RXDAT register.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when the transmitter holding register is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when the transmitter holding register is available.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when data may be written to TXDAT.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when a receiver overrun occurs. This happens in slave mode when there is a need for the receiver to move newly received data to the RXDAT register when it is already in use. The interface prevents receiver overrun in Master mode by not allowing a new transmission to begin when a receiver overrun would otherwise occur.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when a receiver overrun occurs.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated if a receiver overrun occurs.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when a transmitter underrun occurs. This happens in slave mode when there is a need to transmit data when none is available.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when the transmitter underruns.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated if the transmitter underruns.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when one or more Slave Select is asserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when any Slave Select transitions from deasserted to asserted.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when any Slave Select transitions from deasserted to asserted.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Determines whether an interrupt occurs when all Slave Selects are deasserted.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No interrupt will be generated when all asserted Slave Selects transition to deasserted.</description>
                <name>NO_INTERRUPT_WILL_BE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>An interrupt will be generated when all asserted Slave Selects transition to deasserted.</description>
                <name>AN_INTERRUPT_WILL_BE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SSDEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>SPI Interrupt Enable Clear. Writing a 1 to any implemented bit position causes the corresponding bit in INTENSET to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>RXOVEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>TXUREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>SSAEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bits in the INTENSET register.</description>
            <name>SSDEN</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>SPI Receive Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Receiver Data. This contains the next piece of received data. The number of bits that are used depends on the FLen setting in TXCTL / TXDATCTL.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select for receive. This field allows the state of the  SSEL pin to be saved along with received data. The value will reflect the SSEL pin for both master and slave operation. A zero indicates that a slave select is active. The actual polarity of each slave select pin is configured by the related SPOL bit in CFG.</description>
            <name>RXSSELN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Start of Transfer flag. This flag will be 1 if this is the first frame after SSEL went from  deasserted to  asserted (i.e., any previous transfer has ended). This information can be used to identify the first piece of data in cases where the frame length is greater than 16 bit.</description>
            <name>SOT</name>
          </field>
        </fields>
        <name>RXDAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x18</addressOffset>
        <description>SPI Transmit Data with Control</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 1 to 16 bits of data to be transmitted.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select . This field controls what is output for SSEL in master mode.  The active state of the SSEL function is configured by bits in the CFG register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL  asserted.</description>
                <name>SSEL_ASSERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL not asserted.</description>
                <name>SSEL_NOT_ASSERTED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXSSELN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer. The asserted SSEL will be deasserted at the end of a transfer, and remain so for at least the time specified by the Transfer_delay value in the DLY register.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL not deasserted. This piece of data is not treated as the end of a transfer. SSEL will not be deasserted at the end of this data.</description>
                <name>SSEL_NOT_DEASSERTED_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>SSEL deasserted. This piece of data is treated as the end of a transfer. SSELs will be deasserted at the end of this piece of data.</description>
                <name>SSEL_DEASSERTED_THI</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame. Between frames, a delay may be inserted, as defined by the Frame_delay value in the DLY register. The end of a frame may not be particularly meaningful if the FRAME_DELAY value = 0. This control can be used as part of the support for frame lengths greater than 16 bits.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data not EOF. This piece of data transmitted is not treated as the end of a frame.</description>
                <name>DATA_NOT_EOF_THIS_P</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Data EOF. This piece of data is treated as the end of a frame, causing the FRAME_DELAY time to be inserted before subsequent data is transmitted.</description>
                <name>DATA_EOF_THIS_PIECE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore. This allows data to be transmitted using the SPI without the need to read unneeded data from the receiver to simplify the transmit process.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Read received data. Received data must be read in order to allow transmission to progress. In slave mode, an overrun error will occur if received data is not read before new data is received.</description>
                <name>READ_RECEIVED_DATA_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Ignore received data. Received data is ignored, allowing transmission without reading unneeded received data. No receiver flags are generated.</description>
                <name>IGNORE_RECEIVED_DATA</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Frame Length. Specifies the frame length from 1 to 16 bits. Note that frame lengths greater than 16 bits are supported by multiple sequential frames Note that if a 1-bit frame is selected, the master function will always insert a delay with a length of one SCK time following the single clock seen on the SCK pin. 0x0 = Data frame is 1 bit in length. 0x1 = Data frame is 1 bit in length. 0x2 = Data frame is 3 bits in length. ... 0xF = Data frame is 16 bits in length.</description>
            <name>FLEN</name>
          </field>
        </fields>
        <name>TXDATCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>SPI Transmit Data</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Transmit Data. This field provides from 4 to 16 bits of data to be transmitted.</description>
            <name>DATA</name>
          </field>
        </fields>
        <name>TXDAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>SPI Transmit Control</description>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Slave Select.</description>
            <name>TX_SSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Transfer.</description>
            <name>EOT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>End of Frame.</description>
            <name>EOF</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x16</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receive Ignore.</description>
            <name>RXIGNORE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Frame Length.</description>
            <name>FLEN</name>
          </field>
        </fields>
        <name>TXCTL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>SPI clock Divider</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>Rate divider value -1. Specifies how the PCLK for the SPI is divided to produce the SPI clock rate in master mode.  DIVVAL is -1 encoded such that the value 0 results in PCLK/1, the value 1 results in PCLK/2, etc. the maximum possible divide is for the value 0xFFFF, which results in PCLK/65536.</description>
            <name>DIVVAL</name>
          </field>
        </fields>
        <name>DIV</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x28</addressOffset>
        <description>SPI Interrupt Status</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Overrun interrupt flag.</description>
            <name>RXOV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Underrun interrupt flag.</description>
            <name>TXUR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Assert.</description>
            <name>SSA</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Slave Select Deassert.</description>
            <name>SSD</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x2</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40064000</baseAddress>
    <description>USART</description>
    <groupName>USART</groupName>
    <interrupts>
      <interrupt>
        <name>UART0</name>
        <value>0x3</value>
      </interrupt>
    </interrupts>
    <name>USART0</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts  are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt if  enabled because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED_THE_USART_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED_THE_USART_I</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL register.</description>
                <name>9_BIT_DATA_LENGTH_T</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY_ADDS_A_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY_ADDS_A_B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS_THIS_SE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 16.7.3 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL_THE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses external or internal CTS for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS_MODE_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS_MODE_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE_UN_RXD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE_UN_RXD_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE_WHEN_SYNCHRON</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master. In asynchronous mode, the baud rate clock will be output on SCLK if it is connected to a pin.</description>
                <name>MASTER_WHEN_SYNCHRO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE_THIS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTRL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver is enabled for all incoming data.</description>
                <name>ENABLED_THE_USART_R</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>DISABLED_THE_USART_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED_USART_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED_USART_TRAN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK_SC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No affect on the CC bit.</description>
                <name>NO_AFFECT_ON_THE_CC_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR_THE_CC_B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCC</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing 1s clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDATA or RXDATASTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDATA until the data is moved to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input and subsequently confirmed by a mid-bit sample. Its purpose is primarily to allow wakeup from Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character, if parity is enabled via the Parity field in the CFG register.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. The Noise bit is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception. RXNOISEINT is not updated during a received break.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDATA register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDATA register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 164.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATA</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit in Table 164.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATASTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x40068000</baseAddress>
    <derivedFrom>USART0</derivedFrom>
    <description>USART</description>
    <groupName>USART</groupName>
    <interrupts>
      <interrupt>
        <name>UART1</name>
        <value>0x4</value>
      </interrupt>
    </interrupts>
    <name>USART1</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts  are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt if  enabled because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED_THE_USART_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED_THE_USART_I</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL register.</description>
                <name>9_BIT_DATA_LENGTH_T</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY_ADDS_A_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY_ADDS_A_B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS_THIS_SE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 16.7.3 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL_THE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses external or internal CTS for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS_MODE_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS_MODE_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE_UN_RXD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE_UN_RXD_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE_WHEN_SYNCHRON</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master. In asynchronous mode, the baud rate clock will be output on SCLK if it is connected to a pin.</description>
                <name>MASTER_WHEN_SYNCHRO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE_THIS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTRL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver is enabled for all incoming data.</description>
                <name>ENABLED_THE_USART_R</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>DISABLED_THE_USART_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED_USART_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED_USART_TRAN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK_SC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No affect on the CC bit.</description>
                <name>NO_AFFECT_ON_THE_CC_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR_THE_CC_B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCC</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing 1s clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDATA or RXDATASTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDATA until the data is moved to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input and subsequently confirmed by a mid-bit sample. Its purpose is primarily to allow wakeup from Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character, if parity is enabled via the Parity field in the CFG register.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. The Noise bit is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception. RXNOISEINT is not updated during a received break.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDATA register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDATA register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 164.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATA</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit in Table 164.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATASTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x4006C000</baseAddress>
    <derivedFrom>USART0</derivedFrom>
    <description>USART</description>
    <groupName>USART</groupName>
    <interrupts>
      <interrupt>
        <name>UART2</name>
        <value>0x5</value>
      </interrupt>
    </interrupts>
    <name>USART2</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>USART Configuration register. Basic USART configuration settings that typically are not changed during operation.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>USART Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART is disabled and the internal state machine and counters are reset. While Enable = 0, all USART interrupts  are disabled. When Enable is set again, CFG and most other control bits remain unchanged. For instance, when re-enabled, the USART will immediately generate a TxRdy interrupt if  enabled because the transmitter has been reset and is therefore available.</description>
                <name>DISABLED_THE_USART_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART is enabled for operation.</description>
                <name>ENABLED_THE_USART_I</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENABLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the data size for the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>7 bit Data length.</description>
                <name>7_BIT_DATA_LENGTH_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>8 bit Data length.</description>
                <name>8_BIT_DATA_LENGTH_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>9 bit data length. The 9th bit is commonly used for addressing in multidrop mode. See the ADDRDET bit in the CTRL register.</description>
                <name>9_BIT_DATA_LENGTH_T</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DATALEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects what type of parity is used by the USART.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No parity.</description>
                <name>NO_PARITY_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Even parity. Adds a bit to each character such that the number of 1s in a transmitted character is even, and the number of 1s in a received character is expected to be even.</description>
                <name>EVEN_PARITY_ADDS_A_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Odd parity. Adds a bit to each character such that the number of 1s in a transmitted character is odd, and the number of 1s in a received character is expected to be odd.</description>
                <name>ODD_PARITY_ADDS_A_B</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>PARITYSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Number of stop bits appended to transmitted data. Only a single stop bit is required for received data.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>1 stop bit.</description>
                <name>1_STOP_BIT_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>2 stop bits. This setting should only be used for asynchronous communication.</description>
                <name>2_STOP_BITS_THIS_SE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STOPLEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CTS Enable. Determines whether CTS is used for flow control. CTS can be from the input pin, or from the USART's own RTS if loopback mode is enabled. See Section 16.7.3 for more information.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No flow control. The transmitter does not receive any automatic flow control signal.</description>
                <name>NO_FLOW_CONTROL_THE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Flow control enabled. The transmitter uses external or internal CTS for flow control purposes.</description>
                <name>FLOW_CONTROL_ENABLED</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects synchronous or asynchronous operation.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Asynchronous mode is selected.</description>
                <name>ASYNCHRONOUS_MODE_IS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Synchronous mode is selected.</description>
                <name>SYNCHRONOUS_MODE_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects the clock polarity and sampling edge of received data in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Un_RXD is sampled on the falling edge of SCLK.</description>
                <name>FALLING_EDGE_UN_RXD</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Un_RXD is sampled on the rising edge of SCLK.</description>
                <name>RISING_EDGE_UN_RXD_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKPOL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Synchronous mode Master select.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Slave. When synchronous mode is enabled, the USART is a slave.</description>
                <name>SLAVE_WHEN_SYNCHRON</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Master. When synchronous mode is enabled, the USART is a master. In asynchronous mode, the baud rate clock will be output on SCLK if it is connected to a pin.</description>
                <name>MASTER_WHEN_SYNCHRO</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SYNCMST</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Selects data loopback mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Loopback mode. This provides a mechanism to perform diagnostic loopback testing for USART data. Serial data from the transmitter (Un_TXD) is connected internally to serial input of the receive (Un_RXD). Un_TXD and Un_RTS activity will also appear on external pins if these functions are configured to appear on device pins. The receiver RTS signal is also looped back to CTS and performs flow control if enabled by CTSEN.</description>
                <name>LOOPBACK_MODE_THIS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>LOOP</name>
          </field>
        </fields>
        <name>CFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>USART Control register. USART control settings that are more likely to change during operation.</description>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Break Enable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Normal operation.</description>
                <name>NORMAL_OPERATION_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous break is sent immediately when this bit is set, and remains until this bit is cleared. A break may be sent without danger of corrupting any currently transmitting character if the transmitter is first disabled (TXDIS in CTRL is set) and then waiting for the transmitter to be disabled (TXDISINT in STAT = 1) before writing 1 to TXBRKEN.</description>
                <name>CONTINUOUS_BREAK_IS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enable address detect mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. The USART receiver is enabled for all incoming data.</description>
                <name>ENABLED_THE_USART_R</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. The USART receiver ignores incoming data that does not have the most significant bit of the data (typically the 9th bit) = 1. When the data MSB bit = 1, the receiver treats the incoming data normally, generating a received data interrupt. Software can then check the data to see if this is an address that should be handled. If it is, the ADDRDET bit is cleared by software and further incoming data is handled normally.</description>
                <name>DISABLED_THE_USART_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ADDRDET</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmit Disable.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Not disabled. USART transmitter is not disabled.</description>
                <name>NOT_DISABLED_USART_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. USART transmitter is disabled after any character currently being transmitted is complete. This feature can be used to facilitate software flow control.</description>
                <name>DISABLED_USART_TRAN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>TXDIS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Continuous Clock generation. By default, SCLK is only output while data is being transmitted in synchronous mode.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clock on character. In synchronous mode, SCLK cycles only when characters are being sent on Un_TXD or to complete a character that is being received.</description>
                <name>CLOCK_ON_CHARACTER_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Continuous clock. SCLK runs continuously in synchronous mode, allowing characters to be received on Un_RxD independently from transmission on Un_TXD).</description>
                <name>CONTINUOUS_CLOCK_SC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Clear Continuous Clock.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No affect on the CC bit.</description>
                <name>NO_AFFECT_ON_THE_CC_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Auto-clear. The CC bit is automatically cleared when a complete character has been received. This bit is cleared at the same time.</description>
                <name>AUTO_CLEAR_THE_CC_B</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLRCC</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>USART Status register. The complete status value can be read here. Writing 1s clears some bits in the register. Some bits can be cleared by writing a 1 to them.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag. When 1, indicates that data is available to be read from the receiver buffer. Cleared after a read of the RXDATA or RXDATASTAT registers.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Idle. When 0, indicates that the receiver is currently in the process of receiving data. When 1, indicates that the receiver is not currently in the process of receiving data.</description>
            <name>RXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag. When 1, this bit indicates that data may be written to the transmit buffer. Previous data may still be in the process of being transmitted. Cleared when data is written to TXDATA until the data is moved to the transmit shift register.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Idle. When 0, indicates that the transmitter is currently in the process of sending data.When 1, indicate that the transmitter is not currently in the process of sending data.</description>
            <name>TXIDLE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit reflects the current state of the CTS signal, regardless of the setting of the CTSEN bit in the CFG register. This will be the value of the CTS input pin unless loopback mode is enabled.</description>
            <name>CTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state is detected for the CTS flag above. This bit is cleared by software.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag. When 1, this bit indicates that the USART transmitter is fully idle after being disabled via the TXDIS in the CFG register (TXDIS = 1).</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag. This flag is set when a new character is received while the receiver buffer is still in use. If this occurs, the newly received character in the shift register is lost.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Break. This bit reflects the current state of the receiver break detection logic. It is set when the Un_RXD pin remains low for 16 bit times. Note that FRAMERRINT will also be set when this condition occurs because the stop bit(s) for the character would be missing. RXBRK is cleared when the Un_RXD pin goes high.</description>
            <name>RXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs. Cleared by software.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input and subsequently confirmed by a mid-bit sample. Its purpose is primarily to allow wakeup from Power-down mode immediately when a start is detected. Cleared by software.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag. This flag is set when a character is received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag. This flag is set when a parity error is detected in a received character, if parity is enabled via the Parity field in the CFG register.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. Three samples of received data are taken in order to determine the value of each received data bit, except in synchronous mode. This acts as a noise filter if one sample disagrees. The Noise bit is set when a received data bit contains one disagreeing sample. This could indicate line noise, a baud rate or character format mismatch, or loss of synchronization during data reception. RXNOISEINT is not updated during a received break.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <name>STAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xE</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Interrupt Enable read and Set register. Contains an individual interrupt enable bit for each potential USART interrupt. A complete value may be read from this register. Writing a 1 to any implemented bit position causes that bit to be set.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a received character available to be read from the RXDATA register.</description>
            <name>RXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the TXDATA register is available to take another character to transmit.</description>
            <name>TXRDYEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when there is a change in the state of the CTS input.</description>
            <name>DELTACTSEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when the transmitter is fully disabled as indicated by the TXDISINT flag in STAT. See description of the TXDISINT bit for details.</description>
            <name>TXDISINTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when an overrun error occurred.</description>
            <name>OVERRUNEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a change of state has occurred in the detection of a received break condition (break condition asserted or deasserted).</description>
            <name>DELTARXBRKEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a received start bit has been detected.</description>
            <name>STARTEN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a framing error has been detected.</description>
            <name>FRAMERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when a parity error has been detected.</description>
            <name>PARITYERREN</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When 1, enables an interrupt when noise is detected. See description of the RXNOISEINT bit in Table 164.</description>
            <name>RXNOISEEN</name>
          </field>
        </fields>
        <name>INTENSET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x10</addressOffset>
        <description>Interrupt Enable Clear register. Allows clearing any combination of bits in the INTENSET register. Writing a 1 to any implemented bit position causes the corresponding bit to be cleared.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXRDYCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTACTSCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>TXDISINTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>OVERRUNCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>DELTARXBRKCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>STARTCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>FRAMERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>PARITYERRCLR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing 1 clears the corresponding bit in the INTENSET register.</description>
            <name>RXNOISECLR</name>
          </field>
        </fields>
        <name>INTENCLR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Receiver Data register. Contains the last character received.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <name>RXDATA</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Receiver Data with Status register. Combines the last character received with the current USART receive status. Allows software to recover incoming data and status together.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>The USART Receiver Data register contains the next received character. The number of bits that are relevant depends on the USART configuration settings.</description>
            <name>RXDAT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will set when the character in RXDAT was received with a missing stop bit at the expected location. This could be an indication of a baud rate or configuration mismatch with the transmitting source.</description>
            <name>FRAMERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error status flag. This bit is valid when there is a character to be read in the RXDATA register and reflects the status of that character. This bit will be set when a parity error is detected in a received character.</description>
            <name>PARITYERR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise flag. See description of the RxNoiseInt bit in Table 164.</description>
            <name>RXNOISE</name>
          </field>
        </fields>
        <name>RXDATASTAT</name>
        <readAction>modify</readAction>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Transmit Data register. Data to be transmitted is written here.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x9</bitWidth>
            <description>Writing to the USART Transmit Data Register causes the data to be transmitted as soon as the transmit shift register is available.</description>
            <name>TXDAT</name>
          </field>
        </fields>
        <name>TXDATA</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Baud Rate Generator register. 16-bit integer baud rate divisor value.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>This value is used to divide the USART input clock to determine the baud rate, based on the input clock from the FRG. 0 = The FRG clock is used directly by the USART function. 1 = The FRG clock is divided by 2 before use by the USART function. 2 = The FRG clock is divided by 3 before use by the USART function. ... 0xFFFF = The FRG clock is divided by 65,536 before use by the USART function.</description>
            <name>BRGVAL</name>
          </field>
        </fields>
        <name>BRG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x24</addressOffset>
        <description>Interrupt status register. Reflects interrupts that are currently enabled.</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Receiver Ready flag.</description>
            <name>RXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Ready flag.</description>
            <name>TXRDY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of the CTS input is detected.</description>
            <name>DELTACTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Transmitter Disabled Interrupt flag.</description>
            <name>TXDISINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Overrun Error interrupt flag.</description>
            <name>OVERRUNINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a change in the state of receiver break detection occurs.</description>
            <name>DELTARXBRK</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is set when a start is detected on the receiver input.</description>
            <name>START</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xD</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Framing Error interrupt flag.</description>
            <name>FRAMERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Parity Error interrupt flag.</description>
            <name>PARITYERRINT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Received Noise interrupt flag.</description>
            <name>RXNOISEINT</name>
          </field>
        </fields>
        <name>INTSTAT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x5</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50000000</baseAddress>
    <description>Cyclic Redundancy Check (CRC) engine</description>
    <groupName>CRC</groupName>
    <interrupts></interrupts>
    <name>CRC</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>CRC mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>CRC polynom: 1X= CRC-32 polynomial 01= CRC-16 polynomial 00= CRC-CCITT polynomial</description>
            <name>CRC_POLY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data bit order: 1= Bit order reverse for CRC_WR_DATA (per byte) 0= No bit order reverse for CRC_WR_DATA (per byte)</description>
            <name>BIT_RVS_WR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Data complement: 1= 1's complement for CRC_WR_DATA 0= No 1's complement for CRC_WR_DATA</description>
            <name>CMPL_WR</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC sum bit order: 1= Bit order reverse for CRC_SUM 0= No bit order reverse for CRC_SUM</description>
            <name>BIT_RVS_SUM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>CRC sum complement: 1= 1's complement for CRC_SUM 0=No 1's complement for CRC_SUM</description>
            <name>CMPL_SUM</name>
          </field>
        </fields>
        <name>MODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>CRC seed register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>A write access to this register will load CRC seed value to CRC_SUM register with selected bit order and 1's complement pre-processes. A write access to this register will overrule the CRC calculation in progresses.</description>
            <name>CRC_SEED</name>
          </field>
        </fields>
        <name>SEED</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CRC checksum register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>The most recent CRC sum can be read through this register with selected bit order and 1's complement post-processes.</description>
            <name>CRC_SUM</name>
          </field>
        </fields>
        <name>SUM</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0xFFFF</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>CRC data register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Data written to this register will be taken to perform CRC calculation with selected bit order and 1's complement pre-process. Any write size 8, 16 or 32-bit are allowed and accept back-to-back transactions.</description>
            <name>CRC_WR_DATA</name>
          </field>
        </fields>
        <name>WR_DATA</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0x50004000</baseAddress>
    <description>State Configurable Timer (SCT)</description>
    <groupName>SCT</groupName>
    <interrupts>
      <interrupt>
        <name>SCT</name>
        <value>0x9</value>
      </interrupt>
    </interrupts>
    <name>SCT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>SCT configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>SCT operation</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT operates as two 16-bit counters named L and H.</description>
                <name>THE_SCT_OPERATES_AS_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT operates as a unified 32-bit counter.</description>
                <name>THE_SCT_OPERATES_AS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>UNIFY</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>SCT clock mode</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The bus clock clocks the SCT and prescalers.</description>
                <name>THE_BUS_CLOCK_CLOCKS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The SCT clock is the bus clock, but the prescalers are  enabled to count only when sampling of the input selected by  the CKSEL field finds the selected edge. The minimum pulse  width on the clock input is 1 bus clock period. This mode is the high-performance  sampled-clock mode.</description>
                <name>THE_SCT_CLOCK_IS_THE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The input selected by  CKSEL clocks the SCT and prescalers. The input is synchronized to the bus clock and possibly inverted.  The minimum pulse width on the clock input is 1 bus clock  period. This mode is the low-power sampled-clock mode.</description>
                <name>THE_INPUT_SELECTED_B</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Reserved.</description>
                <name>RESERVED_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>SCT clock select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 0.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 0.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 1.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 1.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 2.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 2.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edges on input 3.</description>
                <name>RISING_EDGES_ON_INPU</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edges on input 3.</description>
                <name>FALLING_EDGES_ON_INP</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CLKSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x7</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the lower match registers from being  reloaded from their respective reload registers. Software can  write to set or clear this bit at any time. This bit applies to both the  higher and lower registers when the UNIFY bit is set.</description>
            <name>NORELAOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A 1 in this bit prevents the higher match registers from being  reloaded from their respective reload registers. Software can  write to set or clear this bit at any time. This bit is not used when  the UNIFY bit is set.</description>
            <name>NORELOAD_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x9</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Synchronization for input N (bit 9 = input 0, bit 10 = input 1,..., bit 16 = input 7). A 1 in one of these bits subjects the corresponding input to  synchronization to the SCT clock, before it is used to create an  event. If an input is synchronous to the SCT clock, keep its bit 0 for  faster response. When the CKMODE field is 1x, the bit in this field, corresponding  to the input selected by the CKSEL field, is not used.</description>
            <name>INSYNC</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit causes a match on match register 0 to be treated  as a de-facto LIMIT condition without the need to define an  associated event. As with any LIMIT event, this automatic limit causes the  counter to be cleared to zero in uni-directional mode or to change  the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit  applies to both the higher and lower registers when the UNIFY bit  is set.</description>
            <name>AUTOLIMIT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>A one in this bit will cause a match on match register 0 to be treated  as a de-facto LIMIT condition without the need to define an  associated event. As with any LIMIT event, this automatic limit causes the  counter to be cleared to zero in uni-directional mode or to change  the direction of count in bi-directional mode. Software can write to set or clear this bit at any time. This bit is  not used when the UNIFY bit is set.</description>
            <name>AUTOLIMIT_H</name>
          </field>
        </fields>
        <name>CONFIG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x7E00</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>SCT control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the L or unified counter is counting down. Hardware sets this bit   when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.</description>
            <name>DOWN_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the L or unified counter does not run, but I/O  events related to the counter can occur. If such an event matches  the mask in the Start register, this bit is cleared and counting  resumes.</description>
            <name>STOP_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the L or unified counter does not run and no events can occur.  A reset sets this bit. When the HALT_L bit is one, the STOP_L bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, only software can clear this bit to restore counter operation.</description>
            <name>HALT_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the L or unified counter. This bit always reads as 0.</description>
            <name>CLRCTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>L or unified counter direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter counts up to its limit condition, then is cleared to zero.</description>
                <name>THE_COUNTER_COUNTS_U</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The counter counts up to its limit, then counts down to a limit condition or to 0.</description>
                <name>THE_COUNTER_COUNTS_U</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to produce the  L or unified counter clock. The counter clock is clocked at the rate of the SCT  clock divided by PRE_L+1. Clear the counter (by writing a 1  to the CLRCTR bit) whenever changing the PRE value.</description>
            <name>PRE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit is 1 when the H counter is counting down. Hardware sets this bit   when the counter limit is reached and BIDIR is 1. Hardware clears this bit when the counter is counting down and a limit condition occurs or when the counter reaches 0.</description>
            <name>DOWN_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1 and HALT is 0, the H counter does not, run but I/O  events related to the counter can occur. If such an event matches  the mask in the Start register, this bit is cleared and counting  resumes.</description>
            <name>STOP_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>When this bit is 1, the H counter does not run and no events can occur.  A reset sets this bit. When the HALT_H bit is one, the STOP_H bit is cleared. If you want to remove the halt condition and keep the SCT in the stop condition (not running), then you can change the halt and stop condition with one single write to this register. Once set, this bit can only be cleared by software to restore counter operation.</description>
            <name>HALT_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Writing a 1 to this bit clears the H counter. This bit always reads as 0.</description>
            <name>CLRCTR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Direction select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>The H counter counts up to its limit condition, then is cleared to zero.</description>
                <name>THE_H_COUNTER_COUNTS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>The H counter counts up to its limit, then counts down to a limit condition or to 0.</description>
                <name>THE_H_COUNTER_COUNTS</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>BIDIR_H</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Specifies the factor by which the SCT clock is prescaled to produce the  H counter clock. The counter clock is clocked at the rate of the SCT  clock divided by PRELH+1. Clear the counter (by writing a 1  to the CLRCTR bit) whenever changing the PRE value.</description>
            <name>PRE_H</name>
          </field>
        </fields>
        <name>CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x40004</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>SCT limit register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n is used as a counter limit for the L or unified counter (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>LIMMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit n is one, event n is used as a counter limit for the H counter (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20).</description>
            <name>LIMMSK_H</name>
          </field>
        </fields>
        <name>LIMIT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>SCT halt condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the HALT_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>HALTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit n is one, event n sets the HALT_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20).</description>
            <name>HALTMSK_H</name>
          </field>
        </fields>
        <name>HALT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>SCT stop condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n sets the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>STOPMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit n is one, event n sets the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20).</description>
            <name>STOPMSK_H</name>
          </field>
        </fields>
        <name>STOP</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x14</addressOffset>
        <description>SCT start condition register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit n is one, event n clears the STOP_L bit in the CTRL register (event 0 = bit 0, event 1 = bit 1, event 5 = bit 5).</description>
            <name>STARTMSK_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit n is one, event n clears the STOP_H bit in the CTRL register (event 0 = bit 16, event 1 = bit 17, event 5 = bit 20).</description>
            <name>STARTMSK_H</name>
          </field>
        </fields>
        <name>START</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x40</addressOffset>
        <description>SCT counter register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit L counter value. When UNIFY = 1, read or write the lower 16 bits of the 32-bit unified counter.</description>
            <name>CTR_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit H counter value. When UNIFY = 1, read or write the upper 16 bits of the 32-bit unified counter.</description>
            <name>CTR_H</name>
          </field>
        </fields>
        <name>COUNT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x44</addressOffset>
        <description>SCT state register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>State variable.</description>
            <name>STATE_H</name>
          </field>
        </fields>
        <name>STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-only</access>
        <addressOffset>0x48</addressOffset>
        <description>SCT input register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 0.</description>
            <name>AIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 1.</description>
            <name>AIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 2.</description>
            <name>AIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x3</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Real-time status of input 3.</description>
            <name>AIN3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 0 state synchronized to the SCT clock.</description>
            <name>SIN0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 1 state synchronized to the SCT clock.</description>
            <name>SIN1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x12</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 2 state synchronized to the SCT clock.</description>
            <name>SIN2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x13</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input 3 state synchronized to the SCT clock.</description>
            <name>SIN3</name>
          </field>
        </fields>
        <name>INPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4C</addressOffset>
        <description>SCT match/capture registers mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>Each bit controls one pair of match/capture registers (register 0 = bit 0, register 1 = bit 1,..., register 4 = bit 4).  0 = registers operate as match registers. 1 = registers operate as capture registers.</description>
            <name>REGMOD_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Each bit controls one pair of match/capture registers (register 0 = bit 16, register 1 = bit 17,..., register 4 = bit 19). 0 = registers operate as match registers. 1 = registers operate as capture registers.</description>
            <name>REGMOD_H</name>
          </field>
        </fields>
        <name>REGMODE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50</addressOffset>
        <description>SCT output register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Writing a 1 to bit n makes the corresponding output HIGH. 0 makes the corresponding output LOW (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>OUT</name>
          </field>
        </fields>
        <name>OUTPUT</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x54</addressOffset>
        <description>SCT output counter direction control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 0. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 1. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 2. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Set/clear operation on output 3. Value 0x3 is reserved. Do not program this value.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear do not depend on any counter.</description>
                <name>SET_AND_CLEAR_DO_NOT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter L or the unified counter is counting down.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set and clear are reversed when counter H is counting down. Do not use if UNIFY = 1.</description>
                <name>SET_AND_CLEAR_ARE_RE</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SETCLR3</name>
          </field>
        </fields>
        <name>OUTPUTDIRCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x58</addressOffset>
        <description>SCT conflict resolution register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR0 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR0 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O0RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x2</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR1 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR1 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O1RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR2 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output n (or set based on the SETCLR2 field).</description>
                <name>CLEAR_OUTPUT_N_OR_S</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O2RES</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Effect of simultaneous set and clear on output 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>No change.</description>
                <name>NO_CHANGE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Set output (or clear based on the SETCLR3 field).</description>
                <name>SET_OUTPUT_OR_CLEAR</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Clear output (or set based on the SETCLR3 field).</description>
                <name>CLEAR_OUTPUT_OR_SET</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Toggle output.</description>
                <name>TOGGLE_OUTPUT_</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>O3RES</name>
          </field>
        </fields>
        <name>RES</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF0</addressOffset>
        <description>SCT event enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>The SCT requests an interrupt when bit n of this register and the event flag register are both one (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>IEN</name>
          </field>
        </fields>
        <name>EVEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF4</addressOffset>
        <description>SCT event flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>Bit n is one if event n has occurred since reset or a 1 was last written to this bit (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>FLAG</name>
          </field>
        </fields>
        <name>EVFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF8</addressOffset>
        <description>SCT conflict enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>The SCT requests interrupt when bit n of this register and the SCT conflict flag register are both one (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>NCEN</name>
          </field>
        </fields>
        <name>CONEN</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xFC</addressOffset>
        <description>SCT conflict flag register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Bit n is one if a no-change conflict event occurred on output n since  reset or a 1 was last written to this bit (output 0 = bit 0, output 1 = bit 1,..., output 3 = bit 3).</description>
            <name>NCFLAG</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1E</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing CTR  L/Unified, STATE L/Unified, MATCH L/Unified, or the Output register when the  L/U counter was not halted. A word write to certain L  and H registers can be half successful and half unsuccessful.</description>
            <name>BUSERRL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1F</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>The most recent bus error from this SCT involved writing CTR H,  STATE H, MATCH H, or the Output register when the H  counter was not halted.</description>
            <name>BUSERRH</name>
          </field>
        </fields>
        <name>CONFLAG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x300</addressOffset>
        <description>SCT event state register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1).</description>
            <name>STATEMSKm</name>
          </field>
        </fields>
        <name>EV0_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x304</addressOffset>
        <description>SCT event control register 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR_THE_EVENT_OCCURS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH_USES_THE_SPEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO_USES_THE_SPECIFI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND_THE_EVENT_OCCUR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP_THIS_EV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN_THIS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV0_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x308</addressOffset>
        <description>SCT event state register 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1).</description>
            <name>STATEMSKm</name>
          </field>
        </fields>
        <name>EV1_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30C</addressOffset>
        <description>SCT event control register 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR_THE_EVENT_OCCURS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH_USES_THE_SPEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO_USES_THE_SPECIFI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND_THE_EVENT_OCCUR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP_THIS_EV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN_THIS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV1_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x310</addressOffset>
        <description>SCT event state register 2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1).</description>
            <name>STATEMSKm</name>
          </field>
        </fields>
        <name>EV2_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x314</addressOffset>
        <description>SCT event control register 2</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR_THE_EVENT_OCCURS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH_USES_THE_SPEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO_USES_THE_SPECIFI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND_THE_EVENT_OCCUR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP_THIS_EV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN_THIS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV2_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x318</addressOffset>
        <description>SCT event state register 3</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1).</description>
            <name>STATEMSKm</name>
          </field>
        </fields>
        <name>EV3_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x31C</addressOffset>
        <description>SCT event control register 3</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR_THE_EVENT_OCCURS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH_USES_THE_SPEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO_USES_THE_SPECIFI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND_THE_EVENT_OCCUR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP_THIS_EV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN_THIS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV3_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x320</addressOffset>
        <description>SCT event state register 4</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1).</description>
            <name>STATEMSKm</name>
          </field>
        </fields>
        <name>EV4_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x324</addressOffset>
        <description>SCT event control register 4</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR_THE_EVENT_OCCURS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH_USES_THE_SPEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO_USES_THE_SPECIFI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND_THE_EVENT_OCCUR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP_THIS_EV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN_THIS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV4_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x328</addressOffset>
        <description>SCT event state register 5</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>If bit m is one, event n (n= 0 to 5) happens in state m of the counter selected by the HEVENT bit (m = state number; state 0 = bit 0, state 1= bit 1).</description>
            <name>STATEMSKm</name>
          </field>
        </fields>
        <name>EV5_STATE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x32C</addressOffset>
        <description>SCT event control register 5</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the Match register associated with this event (if any). A  match can occur only when the counter selected by the HEVENT  bit is running.</description>
            <name>MATCHSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x4</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Select L/H counter. Do not set this bit if UNIFY = 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the L state and the L match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_L_STATE_</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the H state and the H match register selected by MATCHSEL.</description>
                <name>SELECTS_THE_H_STATE_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>HEVENT</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x5</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Input/output select</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the inputs elected by IOSEL.</description>
                <name>SELECTS_THE_INPUTS_E</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Selects the outputs selected by IOSEL.</description>
                <name>SELECTS_THE_OUTPUTS_</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>OUTSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x6</bitOffset>
            <bitWidth>0x4</bitWidth>
            <description>Selects the input or output signal associated with this event (if  any). Do not select an input in this register, if CKMODE is 1x. In this case the clock input is an implicit ingredient of  every event.</description>
            <name>IOSEL</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xA</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects the I/O condition for event n. (The detection of edges on outputs lag the conditions that switch the outputs by one SCT clock). In order to guarantee proper edge/state detection, an input must have a minimum pulse width of at least one SCT  clock period .</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>LOW</description>
                <name>LOW</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rise</description>
                <name>RISE</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Fall</description>
                <name>FALL</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>HIGH</description>
                <name>HIGH</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>IOCOND</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xC</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Selects how the specified match and I/O condition are used and combined.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>OR. The event occurs when either the specified match or I/O condition occurs.</description>
                <name>OR_THE_EVENT_OCCURS</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>MATCH. Uses the specified match only.</description>
                <name>MATCH_USES_THE_SPEC</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>IO. Uses the specified I/O condition only.</description>
                <name>IO_USES_THE_SPECIFI</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>AND. The event occurs when the specified match and I/O condition occur simultaneously.</description>
                <name>AND_THE_EVENT_OCCUR</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>COMBMODE</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>This bit controls how the STATEV value modifies the state  selected by HEVENT when this event is the highest-numbered  event occurring for that state.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is added into STATE (the carry-out is ignored).</description>
                <name>STATEV_VALUE_IS_ADDE</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>STATEV value is loaded into STATE.</description>
                <name>STATEV_VALUE_IS_LOAD</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>STATELD</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xF</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>This value is loaded into or added to the state selected by  HEVENT, depending on STATELD, when this event is the  highest-numbered event occurring for that state. If STATELD and  STATEV are both zero, there is no change to the STATE value.</description>
            <name>STATEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>If this bit is one and the COMBMODE field specifies a match  component to the triggering of this event, then a match is considered to be active whenever the counter value is  GREATER THAN OR EQUAL TO the value specified in the  match register when counting up, LESS THEN OR EQUAL TO  the match value when counting down. If this bit is zero, a match is only be active during the cycle  when the counter is equal to the match value.</description>
            <name>MATCHMEM</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x15</bitOffset>
            <bitWidth>0x2</bitWidth>
            <description>Direction qualifier for event generation. This field only applies when the counters are operating in BIDIR  mode. If BIDIR = 0, the SCT ignores this field. Value 0x3 is reserved.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Direction independent. This event is triggered regardless of the count direction.</description>
                <name>DIRECTION_INDEPENDEN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting up. This event is triggered only during up-counting when BIDIR = 1.</description>
                <name>COUNTING_UP_THIS_EV</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Counting down. This event is triggered only during down-counting when BIDIR = 1.</description>
                <name>COUNTING_DOWN_THIS_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>DIRECTION</name>
          </field>
        </fields>
        <name>EV5_CTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x500</addressOffset>
        <description>SCT output 0 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT0_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x504</addressOffset>
        <description>SCT output 0 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT0_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x508</addressOffset>
        <description>SCT output 1 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT1_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x50C</addressOffset>
        <description>SCT output 1 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT1_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x510</addressOffset>
        <description>SCT output 2 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT2_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x514</addressOffset>
        <description>SCT output 2 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT2_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x518</addressOffset>
        <description>SCT output 3 set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to set output n (or clear it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>SET</name>
          </field>
        </fields>
        <name>OUT3_SET</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x51C</addressOffset>
        <description>SCT output 3 clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>A 1 in bit m selects event m to clear output n (or set it if SETCLRn = 0x1 or 0x2) event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5.</description>
            <name>CLR</name>
          </field>
        </fields>
        <name>OUT3_CLR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT match value register of match channels 0 to 4; REGMOD0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the L counter. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be  compared to the H counter. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be compared to the unified counter.</description>
            <name>MATCHn_H</name>
          </field>
        </fields>
        <name>MATCH4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x104</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x108</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10C</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x110</addressOffset>
        <description>SCT capture register of capture channel 0 to 4; REGMOD0 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the lower 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read the 16-bit counter value at which this register was last captured. When UNIFY = 1, read the upper 16 bits of the 32-bit value at which this register was last captured.</description>
            <name>CAPn_H</name>
          </field>
        </fields>
        <name>CAP4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT match reload value register 0 to 4 REGMOD0 = 0 to REGMODE4 = 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit value to be loaded into the SCTMATCHn_L register. When UNIFY = 1, read or write the lower 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x10</bitWidth>
            <description>When UNIFY = 0, read or write the 16-bit to be loaded into the MATCHn_H register. When UNIFY = 1, read or write the upper 16 bits of the 32-bit value to be loaded into the MATCHn register.</description>
            <name>RELOADn_H</name>
          </field>
        </fields>
        <name>MATCHREL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x200</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONm_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20).</description>
            <name>CAPCONm_H</name>
          </field>
        </fields>
        <name>CAPCTRL0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x204</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONm_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20).</description>
            <name>CAPCONm_H</name>
          </field>
        </fields>
        <name>CAPCTRL1</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x208</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONm_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20).</description>
            <name>CAPCONm_H</name>
          </field>
        </fields>
        <name>CAPCTRL2</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20C</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONm_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20).</description>
            <name>CAPCONm_H</name>
          </field>
        </fields>
        <name>CAPCTRL3</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x210</addressOffset>
        <description>SCT capture control register 0 to 4; REGMOD0 = 1 to REGMODE4 = 1</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x6</bitWidth>
            <description>If bit m is one, event m causes the CAPn_L (UNIFY = 0) or the CAPn (UNIFY = 1) register to be loaded (event 0 = bit 0, event 1 = bit 1,..., event 5 = bit 5).</description>
            <name>CAPCONm_L</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x10</bitOffset>
            <bitWidth>0x5</bitWidth>
            <description>If bit m is one, event m causes the CAPn_H (UNIFY = 0) register to be loaded (event 0 = bit 16, event 1 = bit 17,..., event 5 = bit 20).</description>
            <name>CAPCONm_H</name>
          </field>
        </fields>
        <name>CAPCTRL4</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0xA0000000</baseAddress>
    <description>General Purpose I/O port (GPIO)</description>
    <groupName>GPIO_PORT</groupName>
    <interrupts></interrupts>
    <name>GPIO_PORT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2000</addressOffset>
        <description>Direction registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Selects pin direction for pin P0_n (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = input. 1 = output.</description>
            <name>DIRP0</name>
          </field>
        </fields>
        <name>DIR0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2080</addressOffset>
        <description>Mask register port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Controls which bits corresponding to P0_n are active in the P0MPORT register (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read MPORT: pin state; write MPORT: load output bit. 1 = Read MPORT: 0; write MPORT: output bit not affected.</description>
            <name>MASKP0</name>
          </field>
        </fields>
        <name>MASK0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2100</addressOffset>
        <description>Port pin register port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Reads pin states or loads output bits (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read: pin is low; write: clear output bit. 1 = Read: pin is high; write: set output bit.</description>
            <name>PORT0</name>
          </field>
        </fields>
        <name>PIN0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2180</addressOffset>
        <description>Masked port register port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Masked port register (bit 0 = P0_0, bit 1 = P0_1, ..., bit 17 = P0_17). 0 = Read: pin is LOW and/or the corresponding bit in the MASK register is 1; write: clear output bit if the corresponding bit in the MASK register is 0. 1 = Read: pin is HIGH and the corresponding bit in the MASK register is 0; write: set output bit if the corresponding bit in the MASK register is 0.</description>
            <name>MPORTP0</name>
          </field>
        </fields>
        <name>MPIN0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2200</addressOffset>
        <description>Write: Set register for port 0 Read: output bits for port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Read or set output bits. 0 = Read: output bit: write: no operation. 1 = Read: output bit; write: set output bit.</description>
            <name>SETP0</name>
          </field>
        </fields>
        <name>SET0</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2280</addressOffset>
        <description>Clear port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Clear output bits: 0 = No operation. 1 = Clear output bit.</description>
            <name>CLRP0</name>
          </field>
        </fields>
        <name>CLR0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x2300</addressOffset>
        <description>Toggle port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x12</bitWidth>
            <description>Toggle output bits: 0 = no operation. 1 = Toggle output bit.</description>
            <name>NOTP0</name>
          </field>
        </fields>
        <name>NOT0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x3</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x5</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x6</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x7</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x8</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x9</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xA</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xB</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xC</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xD</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xE</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0xF</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x11</addressOffset>
        <description>Byte pin registers port 0; pins PIO0_0 to PIO0_17</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Read: state of the pin P0_n, regardless of direction, masking, or alternate function, except that pins configured as analog I/O always read as 0. Write: loads the pin's output bit.</description>
            <name>PBYTE</name>
          </field>
        </fields>
        <name>B17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x8</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1000</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W0</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1004</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W1</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1008</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W2</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x100C</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W3</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1010</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W4</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1014</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W5</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1018</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W6</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x101C</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W7</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1020</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W8</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1024</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W9</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1028</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W10</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x102C</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W11</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1030</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W12</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1034</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W13</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1038</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W14</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x103C</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W15</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1040</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W16</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1044</addressOffset>
        <description>Word pin registers port 0</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x20</bitWidth>
            <description>Read 0: pin is LOW.  Write 0: clear output bit. Read 0xFFFF FFFF: pin is HIGH.  Write any value 0x0000 0001 to 0xFFFF FFFF: set output bit. Only 0 or 0xFFFF FFFF can be read. Writing any value other than 0 will set the output bit.</description>
            <name>PWORD</name>
          </field>
        </fields>
        <name>W17</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<peripherals>
  <peripheral>
    <addressBlock>
      <offset>0x0</offset>
      <size>0xFFF</size>
      <usage>registers</usage>
    </addressBlock>
    <baseAddress>0xA0004000</baseAddress>
    <description>Pin interrupt and  pattern match engine</description>
    <groupName>GPIO_PIN_INT</groupName>
    <interrupts>
      <interrupt>
        <name>PININT0</name>
        <value>0x18</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT1</name>
        <value>0x19</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT2</name>
        <value>0x1A</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT3</name>
        <value>0x1B</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT4</name>
        <value>0x1C</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT5</name>
        <value>0x1D</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT6</name>
        <value>0x1E</value>
      </interrupt>
    </interrupts>
    <interrupts>
      <interrupt>
        <name>PININT7</name>
        <value>0x1F</value>
      </interrupt>
    </interrupts>
    <name>PIN_INT</name>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x0</addressOffset>
        <description>Pin Interrupt Mode register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Selects the interrupt mode for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Edge sensitive 1 = Level sensitive</description>
            <name>PMODE</name>
          </field>
        </fields>
        <name>ISEL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x4</addressOffset>
        <description>Pin interrupt level or rising edge interrupt enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Enables the rising edge or level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable rising edge or level interrupt. 1 = Enable rising edge or level interrupt.</description>
            <name>ENRL</name>
          </field>
        </fields>
        <name>IENR</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x8</addressOffset>
        <description>Pin interrupt level (rising edge) interrupt set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address set bits in the IENR, thus enabling interrupts. Bit n sets bit n in the IENR register. 0 = No operation. 1 = Enable rising edge or level interrupt.</description>
            <name>SETENRL</name>
          </field>
        </fields>
        <name>SIENR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0xC</addressOffset>
        <description>Pin interrupt level  or rising edge interrupt clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address clear bits in the IENR, thus disabling the interrupts. Bit n clears bit n in the IENR register. 0 = No operation. 1 = Disable rising edge or level interrupt.</description>
            <name>CENRL</name>
          </field>
        </fields>
        <name>CIENR</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x10</addressOffset>
        <description>Pin interrupt active level or falling edge interrupt enable register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Enables the falling edge or configures the active level interrupt for each pin interrupt. Bit n configures the pin interrupt selected in PINTSELn. 0 = Disable falling edge interrupt or set active interrupt level LOW. 1 = Enable falling edge interrupt enabled or set active interrupt level HIGH.</description>
            <name>ENAF</name>
          </field>
        </fields>
        <name>IENF</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x14</addressOffset>
        <description>Pin interrupt active level or falling edge interrupt set register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address set bits in the IENF, thus enabling interrupts. Bit n sets bit n in the IENF register. 0 = No operation. 1 = Select HIGH-active interrupt or enable falling edge interrupt.</description>
            <name>SETENAF</name>
          </field>
        </fields>
        <name>SIENF</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>write-only</access>
        <addressOffset>0x18</addressOffset>
        <description>Pin interrupt active level (falling edge) interrupt clear register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Ones written to this address clears bits in the IENF, thus disabling interrupts. Bit n clears bit n in the IENF register. 0 = No operation. 1 = LOW-active interrupt selected or falling edge interrupt disabled.</description>
            <name>CENAF</name>
          </field>
        </fields>
        <name>CIENF</name>
        <resetMask>0x0</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x1C</addressOffset>
        <description>Pin interrupt rising edge register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Rising edge detect. Bit n detects the rising edge of the pin selected in PINTSELn. Read 0: No rising edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a rising edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear rising edge detection for this pin.</description>
            <name>RDET</name>
          </field>
        </fields>
        <name>RISE</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x20</addressOffset>
        <description>Pin interrupt falling edge register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Falling edge detect. Bit n detects the falling edge of the pin selected in PINTSELn. Read 0: No falling edge has been detected on this pin since Reset or the last time a one was written to this bit. Write 0: no operation. Read 1: a falling edge has been detected since Reset or the last time a one was written to this bit. Write 1: clear falling edge detection for this pin.</description>
            <name>FDET</name>
          </field>
        </fields>
        <name>FALL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x24</addressOffset>
        <description>Pin interrupt status register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>Pin interrupt status. Bit n returns the status, clears the edge interrupt, or inverts the active level of the pin selected in PINTSELn. Read 0: interrupt is not being requested for this interrupt pin.  Write 0: no operation. Read 1: interrupt is being requested for this interrupt pin. Write 1 (edge-sensitive): clear rising- and falling-edge detection for this pin. Write 1 (level-sensitive): switch the active level for this pin (in the IENF register).</description>
            <name>PSTAT</name>
          </field>
        </fields>
        <name>IST</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x28</addressOffset>
        <description>GPIO pattern match interrupt control register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Specifies whether the 8 pin interrupts are controlled by the pin interrupt function or by the pattern match function.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pin interrupt. Interrupts are driven in response to the standard pin interrupt function</description>
                <name>PIN_INTERRUPT_INTER</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Pattern match. Interrupts are driven in response to pattern matches.</description>
                <name>PATTERN_MATCH_INTER</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SEL_PMATCH</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1</bitOffset>
            <bitWidth>0x1</bitWidth>
            <description>Enables the RxEv output to the ARM cpu and/or to a GPIO output when the specified boolean expression evaluates to true.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Disabled. RxEv output to the cpu is disabled.</description>
                <name>DISABLED_RXEV_OUTPU</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Enabled. RxEv output to the cpu is enabled.</description>
                <name>ENABLED_RXEV_OUTPUT</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>ENA_RXEV</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x18</bitOffset>
            <bitWidth>0x8</bitWidth>
            <description>This field displays the current state of pattern matches. A 1 in any bit of this field indicates that the corresponding product term is matched by the current state of the appropriate inputs.</description>
            <name>PMAT</name>
          </field>
        </fields>
        <name>PMCTRL</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x2C</addressOffset>
        <description>GPIO pattern match interrupt bit-slice source register</description>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 0</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 0.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 0.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 0.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 0.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 0.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 0.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 0.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 0.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 1</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 1.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 1.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 1.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 1.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 1.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 1.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 1.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 1.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 2</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 2.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 2.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 2.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 2.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 2.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 2.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 2.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 2.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 3</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 3.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 3.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 3.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 3.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 3.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 3.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 3.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 3.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 4</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 4.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 4.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 4.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 4.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 4.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 4.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 4.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 4.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 5</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 5.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 5.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 5.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 5.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 5.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 5.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 5.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 5.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 6</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 6.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 6.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 6.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 6.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 6.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 6.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 6.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 6.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Selects the input source for bit slice 7</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 0. Selects pin interrupt input 0 as the source to bit slice 7.</description>
                <name>INPUT_0_SELECTS_PIN</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 1. Selects pin interrupt input 1 as the source to bit slice 7.</description>
                <name>INPUT_1_SELECTS_PIN</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 2. Selects pin interrupt input 2 as the source to bit slice 7.</description>
                <name>INPUT_2_SELECTS_PIN</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 3. Selects pin interrupt input 3 as the source to bit slice 7.</description>
                <name>INPUT_3_SELECTS_PIN</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 4. Selects pin interrupt input 4 as the source to bit slice 7.</description>
                <name>INPUT_4_SELECTS_PIN</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 5. Selects pin interrupt input 5 as the source to bit slice 7.</description>
                <name>INPUT_5_SELECTS_PIN</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 6. Selects pin interrupt input 6 as the source to bit slice 7.</description>
                <name>INPUT_6_SELECTS_PIN</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Input 7. Selects pin interrupt input 7 as the source to bit slice 7.</description>
                <name>INPUT_7_SELECTS_PIN</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>SRC7</name>
          </field>
        </fields>
        <name>PMSRC</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <registers>
      <register>
        <access>read-write</access>
        <addressOffset>0x30</addressOffset>
        <description>GPIO pattern match interrupt bit slice configuration register</description>
        <fields>
          <field>
            <bitOffset>0x0</bitOffset>
            <bitWidth>0x7</bitWidth>
            <description>A 1 in any bit of this field causes the corresponding bit slice to be the final component of a product term in the boolean expression.  This has two effects: 1. The interrupt request associated with this bit-slice will be asserted whenever a match to that product term is detected. 2. The next bit slice will start a new, independent product term in the boolean expression (i.e. an OR will be inserted in the boolean expression following the element controlled by this bit slice).</description>
            <name>PROD_ENDPTS</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x8</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 0.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG0</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xB</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 1.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG1</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0xE</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 2.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG2</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x11</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 3.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG3</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x14</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 4.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG4</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x17</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 5.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG5</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1A</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 6.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG6</name>
          </field>
        </fields>
        <fields>
          <field>
            <bitOffset>0x1D</bitOffset>
            <bitWidth>0x3</bitWidth>
            <description>Specifies the match-contribution condition for bit slice 7.</description>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 1. This bit slice always contributes to a product term match.</description>
                <name>CONSTANT_1_THIS_BIT</name>
                <value>0x0</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising edge. Match occurs if a rising edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_EDGE_MATCH_O</name>
                <value>0x1</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Falling edge. Match occurs if a falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>FALLING_EDGE_MATCH_</name>
                <value>0x2</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Rising or falling edge. Match occurs if either a rising or falling edge on the specified input has occurred since the last time the edge detection for this bit slice was cleared.</description>
                <name>RISING_OR_FALLING_ED</name>
                <value>0x3</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>High level. Match (for this bit slice) occurs when there is a high level on the input specified for this bit slice in the PMSRC register.</description>
                <name>HIGH_LEVEL_MATCH_F</name>
                <value>0x4</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Low level. Match occurs when there is a low level on the specified input.</description>
                <name>LOW_LEVEL_MATCH_OCC</name>
                <value>0x5</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Constant 0. This bit slice never contributes to a match (should be used to disable any unused bit slices)</description>
                <name>CONSTANT_0_THIS_BIT</name>
                <value>0x6</value>
              </enumeratedValue>
            </enumeratedValues>
            <enumeratedValues>
              <enumeratedValue>
                <description>Event. Match occurs on an event - i.e. when either a rising or falling edge is first detected on the specified input (this is a non-sticky version of option 3)</description>
                <name>EVENT_MATCH_OCCURS_</name>
                <value>0x7</value>
              </enumeratedValue>
            </enumeratedValues>
            <name>CFG7</name>
          </field>
        </fields>
        <name>PMCFG</name>
        <resetMask>0xFFFFFFFF</resetMask>
        <resetValue>0x0</resetValue>
        <size>0x20</size>
      </register>
    </registers>
    <size>0x20</size>
  </peripheral>
</peripherals>
<size>0x20</size>
<version>0.2</version>
<width>0x20</width></device>